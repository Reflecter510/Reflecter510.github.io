<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android热缓解框架</title>
      <link href="/2023/05/07/androidu-re-huan-jie-kuang-jia/"/>
      <url>/2023/05/07/androidu-re-huan-jie-kuang-jia/</url>
      
        <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>随着CPU/GPU核心频率和集成水平不断提高、系统功能和算法日益复杂，而设备的构造和尺寸不断缩小，热缓解的重要性日益凸显，适当的热缓解策略能够减少对设备性能和用户体验产生负面影响。</p><p>在Android设备中，存在许多配备有温度传感器的硬件，包括电池、GPU、CPU 和 USB 端口和热敏电阻。Android 实现了一套热缓解框架，用于将底层热子系统硬件设备的接口抽象化。借助该框架，设备制造商和应用开发者可以主动获取这些系统硬件设备的温度数据，或者通过注册监听器接收高温通知，进而在设备开始过热时调整系统及应用执行策略，降低系统负载。</p><p>本文主要介绍Android原生热缓解框架的设计思路，在设备过热时通过哪些策略来进行热缓解，涉及到的相关模块以及这些模块在过热时的行为变化。</p><h2 id="零层设计"><a href="#零层设计" class="headerlink" title="零层设计"></a>零层设计</h2><p><img src="/2023/05/07/androidu-re-huan-jie-kuang-jia/%E8%8D%89%E7%A8%BF.drawio.png"></p><ul><li><p>应用层：热缓解提示，执行自定义的热缓解行为</p></li><li><p>框架层：处理底层上报的温度信息，判断和执行系统层面的热缓解行为。</p></li><li><p>Kernel层：内核的Thermal子系统从硬件设备获取到温度，通过HAL上报给Framework，并负责底层的降温策略。</p><blockquote><p>“HAL”代表硬件抽象层（Hardware Abstraction Layer），是Android系统架构中位于操作系统内核和设备驱动程序之间的一个抽象层。它主要负责提供一组标准化的接口，以便上层应用程序（包括框架层和应用层）可以与底层硬件交互，而无需了解底层硬件的具体实现细节。通过使用HAL，Android系统可以在不同的硬件平台上实现高度的可移植性，并且可以更容易地进行系统级别的优化和修改，同时减少了应用开发者的工作量。</p></blockquote></li></ul><h2 id="一层设计"><a href="#一层设计" class="headerlink" title="一层设计"></a>一层设计</h2><p>框架中的热服务利用来自 Thermal HAL 2.0 的各种缓解信号不断进行监控，并向其客户端提供有关限制严重级别的反馈，其中包括内部组件和 Android 应用。下图为热缓解处理流程的框架图。</p><p><img src="/2023/05/07/androidu-re-huan-jie-kuang-jia/therm_mitigation_flow.png" alt="Android 10 及更高版本中的热缓解处理流程。Android 10 采用了回调监听器，以便获取更精细的缓解响应（相对于之前的 Android 级别）。"></p><h2 id="二层设计"><a href="#二层设计" class="headerlink" title="二层设计"></a>二层设计</h2><h3 id="Thermal-HAL-2-0"><a href="#Thermal-HAL-2-0" class="headerlink" title="Thermal HAL 2.0"></a>Thermal HAL 2.0</h3><p>设备制造商必须实现 Thermal HAL 2.0 里的 HIDL 方法（ IThermal.hal 中提供的方法）。内核热子系统通过获取设备温度传感器和限制状态，在温度状态变化超过设定阈值时，将这些信息通过IThermalChangedCallback上报给ThermalService，执行分发流程，进而上层应用监听者能够获取这些状态信息，从而做出相应决策。上报的信息按照热器件进行分类，具体数据有温度值以及热状态字段等。</p><h4 id="热器件类型"><a href="#热器件类型" class="headerlink" title="热器件类型"></a>热器件类型</h4><p>包括CPU、GPU、电池、手机表面温度、USB端口、、NPU等，具体代码定义如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Keep in sync with hardware/interfaces/thermal/2.0/types.hal */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TYPE_UNKNOWN</span> <span class="operator">=</span> TemperatureType.UNKNOWN;           <span class="comment">// 默认值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TYPE_CPU</span> <span class="operator">=</span> TemperatureType.CPU;<span class="comment">// CPU</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TYPE_GPU</span> <span class="operator">=</span> TemperatureType.GPU;                  <span class="comment">// GPU</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TYPE_BATTERY</span> <span class="operator">=</span> TemperatureType.BATTERY;           <span class="comment">// 电池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TYPE_SKIN</span> <span class="operator">=</span> TemperatureType.SKIN;                 <span class="comment">// 表面温度，即壳温</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TYPE_USB_PORT</span> <span class="operator">=</span> TemperatureType.USB_PORT;         <span class="comment">// USB端口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TYPE_POWER_AMPLIFIER</span> <span class="operator">=</span> TemperatureType.POWER_AMPLIFIER;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TYPE_BCL_VOLTAGE</span> <span class="operator">=</span> TemperatureType.BCL_VOLTAGE;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TYPE_BCL_CURRENT</span> <span class="operator">=</span> TemperatureType.BCL_CURRENT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TYPE_BCL_PERCENTAGE</span> <span class="operator">=</span> TemperatureType.BCL_PERCENTAGE;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TYPE_NPU</span> <span class="operator">=</span> TemperatureType.NPU;                        <span class="comment">// NPU</span></span><br></pre></td></tr></tbody></table></figure><h4 id="热状态级别："><a href="#热状态级别：" class="headerlink" title="热状态级别："></a>热状态级别：</h4><p>共有8个级别，其中 SEVERE 级别以上温控开始加强。</p><table><thead><tr><th align="left">热状态代码</th><th>值</th><th align="left">说明和建议用法</th></tr></thead><tbody><tr><td align="left">NONE</td><td>0x0</td><td align="left">未限制。 此状态代码可用于实施保护操作</td></tr><tr><td align="left">LIGHT</td><td>0x1</td><td align="left">轻微限制。用户体验不受影响。在此阶段，请对设备采取温和的缓解操作。例如，不要提频或采用低效频率（仅适用于大核心）。</td></tr><tr><td align="left">MODERATE</td><td>0x2</td><td align="left">中等限制。用户体验没有受到很大影响。 执行的热缓解操作会影响前台 Activity，因此应用应立即减少耗电量。</td></tr><tr><td align="left">SEVERE</td><td>0x3</td><td align="left">严重限制。用户体验在很大程度上受到影响。在此阶段，设备热缓解措施应该会限制系统容量。这可能会导致显示卡顿和音频抖动等负面影响。</td></tr><tr><td align="left">CRITICAL</td><td>0x4</td><td align="left">平台已采取一切措施减少耗电量。设备热缓解软件已经以最低容量运行所有组件。</td></tr><tr><td align="left">EMERGENCY</td><td>0x5</td><td align="left">平台中的关键组件因热状况而即将关闭。设备功能受限。这是系统在设备关机前发出的最后一次警告。在此阶段，调制解调器和移动数据网络等一些功能会完全关闭。</td></tr><tr><td align="left">SHUTDOWN</td><td>0x6</td><td align="left">立即关机。鉴于此阶段的严重级别，应用可能无法收到此通知。</td></tr></tbody></table><p>在HAL文件里的定义如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** Keep in sync with hardware/interfaces/thermal/2.0/types.hal */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROTTLING_NONE</span> <span class="operator">=</span> ThrottlingSeverity.NONE;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROTTLING_LIGHT</span> <span class="operator">=</span> ThrottlingSeverity.LIGHT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROTTLING_MODERATE</span> <span class="operator">=</span> ThrottlingSeverity.MODERATE;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROTTLING_SEVERE</span> <span class="operator">=</span> ThrottlingSeverity.SEVERE;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROTTLING_CRITICAL</span> <span class="operator">=</span> ThrottlingSeverity.CRITICAL;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROTTLING_EMERGENCY</span> <span class="operator">=</span> ThrottlingSeverity.EMERGENCY;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROTTLING_SHUTDOWN</span> <span class="operator">=</span> ThrottlingSeverity.SHUTDOWN;</span><br></pre></td></tr></tbody></table></figure><h4 id="内核热子系统的热缓解策略"><a href="#内核热子系统的热缓解策略" class="headerlink" title="内核热子系统的热缓解策略"></a>内核热子系统的热缓解策略</h4><p>主要分为三个部分，分别负责温度获取、策略选择、降温措施执行的功能。</p><ul><li><p>Thermal Zone<br>Thermal Zone代表一个温控管理区间，可以将其看做一个虚拟意义上的温度Sensor， 需要有对应的物理 Sensor 与其关联才能发挥作用。<br>一个Thermal Zone最多可以关联一个Sensor，但该Sensor可以是多个硬件Sensor的混合。</p></li><li><p>Thermal Governal</p><p>Thermal Governal代表对温控策略的抽象。常用的有 Step-wise governor和 IPA（Intelligent Power Allocator）</p><ul><li>Step-wise将温度趋势分为三种：上升、下降、稳定，根据配置的温度触发点 (TripPoint) 及温度趋势以步进的方式调节CPU的状态，具体来讲就是调节频率。</li><li>Intelligent Power Allocator：IPA实现了多个 IP core 之间 Power 的动态分配，实现资源的优化配置；以小核、大核、GPU为控制对象来讲，即使温度已经达到目标温度，但是根据各个小核、大核、GPU的负载情况，最需要性能的处理器仍然有可能跑到最高频率，这种基于负载的Power动态分配策略对性能比较友好。</li></ul></li><li><p>Cooling Device<br>实际对系统实施降温措施的驱动，温控的执行者。Cooling Device 维护一个Cooling等级，即state，一般state越高即系统的冷却需求越高。Cooling Device根据不同等级的冷却需求进行降温行为。Cooling Device只根据state进行降温操作，是实施者，而state的计算由Thermal Governor完成，以限制CPU和GPU作为主要措施。</p></li></ul><h3 id="ThermalManagerService"><a href="#ThermalManagerService" class="headerlink" title="ThermalManagerService"></a>ThermalManagerService</h3><p>这是一个运行在SystemServer中的系统服务，用于监听 Thermal HAL的热事件并将这些事件发送给监听者，同时根据热事件触发一些操作（比如限制jobscheduler 、直接关机）。主要流程如下：</p><h4 id="1-服务启动"><a href="#1-服务启动" class="headerlink" title="#1 服务启动"></a>#1 服务启动</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SystemServer.java</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startBootstrapServices</span><span class="params">(<span class="meta">@NonNull</span> TimingsTraceAndSlog t)</span> {</span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">// 在SystemServer启动时，启动ThermalManagerService。</span></span><br><span class="line">        t.traceBegin(<span class="string">"StartThermalManager"</span>);</span><br><span class="line">        mSystemServiceManager.startService(ThermalManagerService.class);</span><br><span class="line">        t.traceEnd();</span><br><span class="line">    ......</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThermalManagerService.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onBootPhase</span><span class="params">(<span class="type">int</span> phase)</span> {</span><br><span class="line">        <span class="keyword">if</span> (phase == SystemService.PHASE_ACTIVITY_MANAGER_READY) {</span><br><span class="line">            <span class="comment">// 在AMS就绪后，执行初始化逻辑</span></span><br><span class="line">            onActivityManagerReady();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onActivityManagerReady</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) {</span><br><span class="line">        <span class="comment">// 连接到Thermal HAL</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">halConnected</span> <span class="operator">=</span> (mHalWrapper != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!halConnected) {</span><br><span class="line">            mHalWrapper = <span class="keyword">new</span> <span class="title class_">ThermalHal20Wrapper</span>();</span><br><span class="line">            halConnected = mHalWrapper.connectToHal();</span><br><span class="line">        }</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 向Thermal HAL注册监听器</span></span><br><span class="line">        mHalWrapper.setCallback(<span class="built_in">this</span>::onTemperatureChangedCallback);</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h4 id="2-热服务处理流程"><a href="#2-热服务处理流程" class="headerlink" title="#2 热服务处理流程"></a>#2 热服务处理流程</h4><p><img src="/C:/Users/Refle/AppData/Roaming/Typora/typora-user-images/image-20230625002822286.png" alt="image-20230625002822286"></p><p>在服务初始化的时候，我们向HAL注册了一个回调方法，该回调传递一个Temperature变量。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HwBinder callback **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onTemperatureChangedCallback</span><span class="params">(Temperature temperature)</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">token</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 处理底层上报，分发事件。</span></span><br><span class="line">        onTemperatureChanged(temperature, <span class="literal">true</span>);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        Binder.restoreCallingIdentity(token);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中，Temperature类主要有以下信息：</p><table><thead><tr><th>字段</th><th>含义</th><th>取值</th></tr></thead><tbody><tr><td>mValue</td><td>温度值</td><td>float, 通常是以摄氏度为单位的温度</td></tr><tr><td>mType</td><td>器件类型</td><td>int, 与前文的热器件类型对应。</td></tr><tr><td>mName</td><td>器件名称</td><td>String</td></tr><tr><td>mStatus</td><td>热状态</td><td>int, 与前文的热状态对应。</td></tr></tbody></table><p>热事件上报后分发，然后计算出表面温度最大热状态分发</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onTemperatureChanged</span><span class="params">(Temperature temperature, <span class="type">boolean</span> sendStatus)</span> {</span><br><span class="line">    <span class="comment">// #2.1 检查是否满足高温关机</span></span><br><span class="line">    shutdownIfNeeded(temperature);</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) {</span><br><span class="line">        <span class="type">Temperature</span> <span class="variable">old</span> <span class="operator">=</span> mTemperatureMap.put(temperature.getName(), temperature);</span><br><span class="line">        <span class="keyword">if</span> (old == <span class="literal">null</span> || old.getStatus() != temperature.getStatus()) {</span><br><span class="line">            <span class="comment">// #2.2 分发热事件给已注册的监听器</span></span><br><span class="line">            notifyEventListenersLocked(temperature);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (sendStatus) {</span><br><span class="line">            <span class="comment">// #2.3 分发热状态给已注册的监听器</span></span><br><span class="line">            onTemperatureMapChangedLocked();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="2-1-高温关机"><a href="#2-1-高温关机" class="headerlink" title="#2.1 高温关机"></a>#2.1 高温关机</h5><p>底层上报的Temperature的状态为<code>THROTTLING_SHUTDOWN</code>(0x6)，将会立即调用PowerManager执行关机。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">shutdownIfNeeded</span><span class="params">(Temperature temperature)</span> {</span><br><span class="line">    <span class="keyword">if</span> (temperature.getStatus() != Temperature.THROTTLING_SHUTDOWN) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> <span class="type">PowerManager</span> <span class="variable">powerManager</span> <span class="operator">=</span> getContext().getSystemService(PowerManager.class);</span><br><span class="line">    <span class="keyword">switch</span> (temperature.getType()) {</span><br><span class="line">        <span class="keyword">case</span> Temperature.TYPE_CPU:</span><br><span class="line">            <span class="comment">// Fall through</span></span><br><span class="line">        <span class="keyword">case</span> Temperature.TYPE_GPU:</span><br><span class="line">            <span class="comment">// Fall through</span></span><br><span class="line">        <span class="keyword">case</span> Temperature.TYPE_NPU:</span><br><span class="line">            <span class="comment">// Fall through</span></span><br><span class="line">        <span class="keyword">case</span> Temperature.TYPE_SKIN:</span><br><span class="line">            powerManager.shutdown(<span class="literal">false</span>, PowerManager.SHUTDOWN_THERMAL_STATE, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Temperature.TYPE_BATTERY:</span><br><span class="line">            powerManager.shutdown(<span class="literal">false</span>, PowerManager.SHUTDOWN_BATTERY_THERMAL_STATE, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="2-2-热事件分发"><a href="#2-2-热事件分发" class="headerlink" title="#2.2  热事件分发"></a>#2.2  热事件分发</h5><p>对于热事件的监听，所有类型的热事件都会触发回调。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyEventListenersLocked</span><span class="params">(Temperature temperature)</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> mThermalEventListeners.beginBroadcast();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 为每一个监听者触发回调</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IThermalEventListener</span> <span class="variable">listener</span> <span class="operator">=</span> mThermalEventListeners.getBroadcastItem(i);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">type</span> <span class="operator">=</span> (Integer) mThermalEventListeners.getBroadcastCookie(i);</span><br><span class="line">            postEventListener(temperature, listener, type);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        mThermalEventListeners.finishBroadcast();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postEventListener</span><span class="params">(Temperature temperature,</span></span><br><span class="line"><span class="params">        IThermalEventListener listener,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> Integer type)</span> {</span><br><span class="line">    <span class="comment">// Skip if listener registered with a different type</span></span><br><span class="line">    <span class="keyword">if</span> (type != <span class="literal">null</span> &amp;&amp; type != temperature.getType()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">thermalCallbackQueued</span> <span class="operator">=</span> FgThread.getHandler().post(() -&gt; {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 最终调用监听者的notify方法，传入Temperature变量。</span></span><br><span class="line">            listener.notifyThrottling(temperature);</span><br><span class="line">        } <span class="keyword">catch</span> (RemoteException | RuntimeException e) {</span><br><span class="line">            Slog.e(TAG, <span class="string">"Thermal callback failed to call"</span>, e);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">if</span> (!thermalCallbackQueued) {</span><br><span class="line">        Slog.e(TAG, <span class="string">"Thermal callback failed to queue"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="2-3-热状态分发"><a href="#2-3-热状态分发" class="headerlink" title="#2.3  热状态分发"></a>#2.3  热状态分发</h5><p>热状态的监听则只是在表面温度的热状态变化时回调。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onTemperatureMapChangedLocked</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 计算表面温度热状态的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newStatus</span> <span class="operator">=</span> Temperature.THROTTLING_NONE;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mTemperatureMap.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) {</span><br><span class="line">        <span class="type">Temperature</span> <span class="variable">t</span> <span class="operator">=</span> mTemperatureMap.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (t.getType() == Temperature.TYPE_SKIN &amp;&amp; t.getStatus() &gt;= newStatus) {</span><br><span class="line">            newStatus = t.getStatus();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="comment">// 这个Override字段用于shell模拟热状态命令时不响应HAL上报。</span></span><br><span class="line">    <span class="keyword">if</span> (!mIsStatusOverride) {</span><br><span class="line">        setStatusLocked(newStatus);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setStatusLocked</span><span class="params">(<span class="type">int</span> newStatus)</span> {</span><br><span class="line">    <span class="keyword">if</span> (newStatus != mStatus) {</span><br><span class="line">        mStatus = newStatus;</span><br><span class="line">        <span class="comment">// 与热事件类似，为每一个监听者触发回调</span></span><br><span class="line">        notifyStatusListenersLocked();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postStatusListener</span><span class="params">(IThermalStatusListener listener)</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">thermalCallbackQueued</span> <span class="operator">=</span> FgThread.getHandler().post(() -&gt; {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 最终回调这个onStatusChange方法，传入热状态</span></span><br><span class="line">            listener.onStatusChange(mStatus);</span><br><span class="line">        } <span class="keyword">catch</span> (RemoteException | RuntimeException e) {</span><br><span class="line">            Slog.e(TAG, <span class="string">"Thermal callback failed to call"</span>, e);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">if</span> (!thermalCallbackQueued) {</span><br><span class="line">        Slog.e(TAG, <span class="string">"Thermal callback failed to queue"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="热状态-热事件的监听接口"><a href="#热状态-热事件的监听接口" class="headerlink" title="热状态/热事件的监听接口"></a>热状态/热事件的监听接口</h4><p>Thermal HAL 2.0 的各种缓解信号上报给框架层后，框架层通过监听回调向其客户端提供有关限制严重级别的反馈，其中包括内部组件和 Android 应用。</p><ol><li>对于上层Android应用来说，可通过 <code>PowerManager</code> 来添加<code>IThermalStatusListener</code>监听器回调或主动获取获取热状态等信息，方法如下：</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getCurrentThermalStatus()，以整数形式返回设备的当前热状态（除非该设备正处于受限状态）。</span><br><span class="line">addThermalStatusListener()，添加监听器。</span><br><span class="line">removeThermalStatusListener()，移除之前添加的监听器。   </span><br></pre></td></tr></tbody></table></figure><p>以上监听器触发后或主动获取返回的值为当前状态热状态码信息。使用回调接口，设备的当前热状态能够以整数值的形式检索到，该值的范围为 <code>0x0（未限制）到 </code>0x6`（设备关机）。只有可信系统服务（例如 Android API 或设备制造商 API）才能访问详细的热传感器和热事件信息。</p><p>应用层调用以上接口方法，假如收到返回值为<code>0x2</code>，说明当前手机热等级为MODERATE (0x2) 中等限制，应用可以根据对应的热等级建议，调整自身逻辑，降低系统负载，缓解手机发热，进而增强在高温状态下的用户体验。</p><ol start="2"><li>对于Android系统内部组件来说，可以注册<code>IThermalEventListener</code>回调接口等方法，监听获取更加详细的热传感器和热事件信息；例如，SystemUI注册<code>IThermalEventListener</code>事件，监听手机表面温度变化，当表面温度超过系统底层设置的阈值档位时，从而提示用户系统将限制某些功能:</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mThermalService == <span class="literal">null</span>) {</span><br><span class="line">    mThermalService = IThermalService.Stub.asInterface(</span><br><span class="line">        ServiceManager.getService(Context.THERMAL_SERVICE));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (mEnableSkinTemperatureWarning) {</span><br><span class="line">    ret = mThermalService.registerThermalEventListenerWithType(</span><br><span class="line">            mSkinThermalEventListener, Temperature.TYPE_SKIN);</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SkinThermalEventListener</span> <span class="keyword">extends</span> <span class="title class_">IThermalEventListener</span>.Stub {</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyThrottling</span><span class="params">(Temperature temp)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> temp.getStatus();</span><br><span class="line">        <span class="keyword">if</span> (status &gt;= Temperature.THROTTLING_EMERGENCY) {</span><br><span class="line">            ......</span><br><span class="line">            mWarnings.showHighTemperatureWarning();</span><br><span class="line">            Slog.d(TAG, <span class="string">"SkinThermalEventListener: notifyThrottling was called "</span></span><br><span class="line">                    + <span class="string">", current skin status = "</span> + status</span><br><span class="line">                    + <span class="string">", temperature = "</span> + temp.getValue());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此外，Android系统内部组件还可以调用thermalHal支持的其他功能接口：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;CoolingDevice&gt; <span class="title function_">getCurrentCoolingDevices</span><span class="params">()</span>; <span class="comment">//返回由于触发温控阈值而被限频的硬件设备信息，如BATTERY，CPU，GPU，MODEM，NPU等。</span></span><br><span class="line">CpuUsageInfo[] getCpuUsages()； <span class="comment">// 获取CPU每个核的负载</span></span><br><span class="line"><span class="type">float</span>[] getDeviceTemperatures(<span class="meta">@DeviceTemperatureType</span> <span class="type">int</span> type,<span class="meta">@TemperatureSource</span> <span class="type">int</span> source) <span class="comment">//获取指定节点设备当前温度值</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="SystemServer中的热缓解策略"><a href="#SystemServer中的热缓解策略" class="headerlink" title="SystemServer中的热缓解策略"></a>SystemServer中的热缓解策略</h3><table><thead><tr><th>类名</th><th>类型</th><th>执行动作</th></tr></thead><tbody><tr><td>ThermalManagerService</td><td></td><td>当达到SHUTDOWN状态，立即关机。参见前文热服务处理流程。</td></tr><tr><td>ThermalStatusRestriction</td><td>监听热状态</td><td>1.当达到LIGHT状态，限制低优先级Job。 2. 当达到MODERATE状态，限制低优先级和高优先级Job。 3. 当达到SEVERE状态，限制所有Job</td></tr><tr><td>BackgroundDexOptService</td><td>主动获取热状态</td><td>在达到moderate状态及以上时，中止后台<code>dexopt</code>任务。</td></tr><tr><td>BlurController</td><td>监听热状态</td><td>当达到CRITICAL状态，禁用窗口高斯模糊。</td></tr><tr><td>BrightnessThrottler</td><td>监听热事件</td><td>根据配置，限制最大亮度</td></tr><tr><td>HighBrightnessModeController</td><td>监听热事件</td><td>在未开启HDR时，根据配置条件判断是否设备过热，限制HighBrightnessMode。</td></tr><tr><td>DisplayModeDirector</td><td>监听热事件</td><td>当达到CRITICAL状态，限制刷新率为60Hz</td></tr><tr><td>SystemUI</td><td>监听热事件</td><td>1.当表面温度达到 EMERGENCY状态以上，发送高温通知。 2. 当USB温度达到 EMERGENCY状态以上，展示提示弹窗</td></tr></tbody></table><h4 id="Job限制（ThermalStatusRestriction）"><a href="#Job限制（ThermalStatusRestriction）" class="headerlink" title="Job限制（ThermalStatusRestriction）:"></a>Job限制（ThermalStatusRestriction）:</h4><ol><li>当达到LIGHT状态，限制所有最低优先级Job和所有尚未运行的低优先级Job。</li><li>当达到MODERATE状态，仅让已经在运行的紧急Job和高优先级的常规Job运行。</li><li>当达到SEVERE状态，限制所有Job。</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThermalStatusRestriction.java</span></span><br><span class="line">    <span class="comment">/** 开始限制低优先级和最低优先级Job的阈值 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOW_PRIORITY_THRESHOLD</span> <span class="operator">=</span> PowerManager.THERMAL_STATUS_LIGHT;</span><br><span class="line">    <span class="comment">/** 开始限制低高优先级Job的阈值 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HIGHER_PRIORITY_THRESHOLD</span> <span class="operator">=</span> PowerManager.THERMAL_STATUS_MODERATE;</span><br><span class="line">    <span class="comment">/** 开始限制Job的最低阈值 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LOWER_THRESHOLD</span> <span class="operator">=</span> LOW_PRIORITY_THRESHOLD;</span><br><span class="line">    <span class="comment">/** 开始限制所有Job的阈值 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UPPER_THRESHOLD</span> <span class="operator">=</span> PowerManager.THERMAL_STATUS_SEVERE;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSystemServicesReady</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">PowerManager</span> <span class="variable">powerManager</span> <span class="operator">=</span></span><br><span class="line">                mService.getTestableContext().getSystemService(PowerManager.class);</span><br><span class="line">        <span class="comment">// Use MainExecutor，注册热事件回调</span></span><br><span class="line">        powerManager.addThermalStatusListener(<span class="keyword">new</span> <span class="title class_">OnThermalStatusChangedListener</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onThermalStatusChanged</span><span class="params">(<span class="type">int</span> status)</span> {</span><br><span class="line">                <span class="comment">// 监听回调在主线程内调用，因此不能做耗时操作，这里只是post了一个消息</span></span><br><span class="line">                <span class="comment">// 1. 低于最低阈值、或高于最高阈值内的热状态变化，不会导致Job限制改变，我们不关注这些热状态的变化</span></span><br><span class="line">                <span class="comment">// 2. 需要关注的是热状态在最低阈值和最高阈值之间的变化，以及切换到最低或最高阈值之外的变化</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">significantChange</span> <span class="operator">=</span></span><br><span class="line">                        (status &gt;= LOWER_THRESHOLD &amp;&amp; status &lt;= UPPER_THRESHOLD)</span><br><span class="line">                                || (mThermalStatus &gt;= LOWER_THRESHOLD &amp;&amp; status &lt; LOWER_THRESHOLD)</span><br><span class="line">                                || (mThermalStatus &lt; UPPER_THRESHOLD &amp;&amp; status &gt; UPPER_THRESHOLD);</span><br><span class="line">                mThermalStatus = status;</span><br><span class="line">                <span class="keyword">if</span> (significantChange) {</span><br><span class="line">                    <span class="comment">// 此处的mService为JobSchedulerService</span></span><br><span class="line">                    mService.onControllerStateChanged(<span class="literal">null</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isJobRestricted</span><span class="params">(JobStatus job)</span> {</span><br><span class="line">        <span class="keyword">if</span> (mThermalStatus &gt;= UPPER_THRESHOLD) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">priority</span> <span class="operator">=</span> job.getEffectivePriority();</span><br><span class="line">        <span class="keyword">if</span> (mThermalStatus &gt;= HIGHER_PRIORITY_THRESHOLD) {</span><br><span class="line">            <span class="comment">// 对于moderate热状态，仅让已经在运行的紧急Job和高优先级的常规Job运行。</span></span><br><span class="line">            <span class="keyword">return</span> !job.shouldTreatAsExpeditedJob()</span><br><span class="line">                    &amp;&amp; !(priority == JobInfo.PRIORITY_HIGH</span><br><span class="line">                    &amp;&amp; mService.isCurrentlyRunningLocked(job));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (mThermalStatus &gt;= LOW_PRIORITY_THRESHOLD) {</span><br><span class="line">            <span class="comment">// 对于light热状态，限制所有最低优先级Job和所有尚未运行的低优先级Job。</span></span><br><span class="line">            <span class="keyword">return</span> (priority == JobInfo.PRIORITY_LOW &amp;&amp; !mService.isCurrentlyRunningLocked(job))</span><br><span class="line">                    || priority == JobInfo.PRIORITY_MIN;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h4 id="后台Dexopt优化限制（BackgroundDexOptService）"><a href="#后台Dexopt优化限制（BackgroundDexOptService）" class="headerlink" title="后台Dexopt优化限制（BackgroundDexOptService）"></a>后台Dexopt优化限制（BackgroundDexOptService）</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BackgroundDexOptService.java</span></span><br><span class="line"><span class="comment">// 默认在MODERATE及以上的热状态进行限制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THERMAL_CUTOFF_DEFAULT</span> <span class="operator">=</span> PowerManager.THERMAL_STATUS_MODERATE;</span><br><span class="line"><span class="comment">/** 评估是否应继续空闲优化. */</span></span><br><span class="line">    <span class="meta">@Status</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">abortIdleOptimizations</span><span class="params">(<span class="type">long</span> lowStorageThreshold)</span> {</span><br><span class="line">        <span class="comment">//.......</span></span><br><span class="line">        <span class="comment">// 主动查询热状态，如果设备的热状态处于MODERATE及以上，则中止后台 dexopt。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">thermalStatus</span> <span class="operator">=</span> mInjector.getCurrentThermalStatus();</span><br><span class="line">        <span class="keyword">if</span> (thermalStatus &gt;= mThermalStatusCutoff) {</span><br><span class="line">            <span class="keyword">return</span> STATUS_ABORT_THERMAL;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......  判断低电量和低存储，同样会中止dexopt任务。</span></span><br><span class="line">        <span class="keyword">return</span> STATUS_OK;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h4 id="窗口模糊限制（BlurController）"><a href="#窗口模糊限制（BlurController）" class="headerlink" title="窗口模糊限制（BlurController）"></a>窗口模糊限制（BlurController）</h4><p>CRITICAL状态及以上的热状态，禁用窗口高斯模糊。</p><p>窗口模糊或交叉窗口模糊用于模糊给定窗口后面的屏幕。窗口模糊有两种类型，可以用来实现不同的视觉效果：</p><ul><li><em>背景模糊</em>允许您创建背景模糊的窗口，从而创建磨砂玻璃效果。</li><li><em>Blur behind</em>允许您模糊（对话框）窗口后面的整个屏幕，创建景深效果。</li></ul><p><a href="https://source.android.com/docs/core/display/window-blurs?hl=zh-cn">窗口模糊  | Android 开源项目  | Android Open Source Project</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BlurController.java</span></span><br><span class="line">    BlurController(Context context, PowerManager powerManager) {</span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">// 注册热状态监听</span></span><br><span class="line">        powerManager.addThermalStatusListener((status) -&gt; {</span><br><span class="line">             <span class="comment">// 判断热状态是否为CRITICAL状态及以上，更新窗口高斯模糊开启状态</span></span><br><span class="line">             mCriticalThermalStatus = status &gt;= THERMAL_STATUS_CRITICAL;</span><br><span class="line">             updateBlurEnabled();</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateBlurEnabled</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) {</span><br><span class="line">            <span class="comment">// 如果设备满足窗口模糊不支持、模糊设置被禁用、省电模式开启、TunnelMode开启、热状态限制的任意条件之一，都会关闭窗口模糊。</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">newEnabled</span> <span class="operator">=</span> CROSS_WINDOW_BLUR_SUPPORTED &amp;&amp; !mBlurDisabledSetting</span><br><span class="line">                    &amp;&amp; !mInPowerSaveMode &amp;&amp; !mTunnelModeEnabled &amp;&amp; !mCriticalThermalStatus;</span><br><span class="line">            <span class="keyword">if</span> (mBlurEnabled == newEnabled) {</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            mBlurEnabled = newEnabled;</span><br><span class="line">            notifyBlurEnabledChangedLocked(newEnabled);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h4 id="亮度范围限制（BrightnessThrottler）"><a href="#亮度范围限制（BrightnessThrottler）" class="headerlink" title="亮度范围限制（BrightnessThrottler）"></a>亮度范围限制（BrightnessThrottler）</h4><p>此类监视各种条件，例如手机表面温度限制状态，并相应地限制允许的亮度范围。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BrightnessThrottler.java</span></span><br><span class="line"><span class="comment">//热事件回调</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">thermalStatusChanged</span><span class="params">(<span class="meta">@Temperature</span>.ThrottlingStatus <span class="type">int</span> newStatus)</span> {</span><br><span class="line">        <span class="keyword">if</span> (mThrottlingStatus != newStatus) {</span><br><span class="line">            mThrottlingStatus = newStatus;</span><br><span class="line">            updateThrottling();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateThrottling</span><span class="params">()</span> {</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">brightnessCap</span> <span class="operator">=</span> PowerManager.BRIGHTNESS_MAX;</span><br><span class="line">        <span class="type">int</span> <span class="variable">brightnessMaxReason</span> <span class="operator">=</span> BrightnessInfo.BRIGHTNESS_MAX_REASON_NONE;</span><br><span class="line">        <span class="keyword">if</span> (mThrottlingStatus != THROTTLING_INVALID) {</span><br><span class="line">            <span class="comment">// Throttling levels 是有序递增的，逐级匹配最大的限制级别。此处mThrottlingData为配置信息</span></span><br><span class="line">            <span class="keyword">for</span> (ThrottlingLevel level : mThrottlingData.throttlingLevels) {</span><br><span class="line">                <span class="keyword">if</span> (level.thermalStatus &lt;= mThrottlingStatus) {</span><br><span class="line">                    brightnessCap = level.brightness;</span><br><span class="line">                    brightnessMaxReason = BrightnessInfo.BRIGHTNESS_MAX_REASON_THERMAL;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">// 大于当前状态的限制级别无关紧要</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (mBrightnessCap != brightnessCap || mBrightnessMaxReason != brightnessMaxReason) {</span><br><span class="line">            mBrightnessCap = verifyAndConstrainBrightnessCap(brightnessCap);</span><br><span class="line">            mBrightnessMaxReason = brightnessMaxReason;</span><br><span class="line">            <span class="keyword">if</span> (mThrottlingChangeCallback != <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// 执行在DisplayPowerController创建BrightnessThrottler时，传入的Runnable，触发亮度限制</span></span><br><span class="line">                mThrottlingChangeCallback.run();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h4 id="高亮度模式限制（HighBrightnessModeController）"><a href="#高亮度模式限制（HighBrightnessModeController）" class="headerlink" title="高亮度模式限制（HighBrightnessModeController）"></a>高亮度模式限制（HighBrightnessModeController）</h4><p>控制支持高亮度模式的设备的状态。此类假定即使设备不支持高亮度模式 （HBM），也始终创建实例;如果不支持，则跳过大多数逻辑。在支持 HBM 的设备上，我们跟踪环境照度以及 HBM 的历史使用情况，以确定何时允许和不允许使用 HBM。此类的输出只是一个亮度范围最大值（通过 {@link getCurrentBrightnessMax} 查询），该值根据是否启用 HBM 而变化。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HighBrightnessModeController.SkinThermalStatusObserver</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyThrottling</span><span class="params">(Temperature temp)</span> {</span><br><span class="line">        <span class="comment">// ......  热事件回调</span></span><br><span class="line">            mHandler.post(() -&gt; {</span><br><span class="line">                <span class="comment">// mHbmData为配置信息</span></span><br><span class="line">                mIsThermalStatusWithinLimit = temp.getStatus() &lt;= mHbmData.thermalStatusLimit;</span><br><span class="line">                <span class="comment">// 重新计算 HbmMode， 并在发生变化时运行 mHbmChangeCallback</span></span><br><span class="line">                updateHbmMode();</span><br><span class="line">            });</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HighBrightnessModeController.java</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateHbmMode</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 重新计算 HbmMode</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newHbmMode</span> <span class="operator">=</span> calculateHighBrightnessMode();</span><br><span class="line">        updateHbmStats(newHbmMode);</span><br><span class="line">        <span class="keyword">if</span> (mHbmMode != newHbmMode) {</span><br><span class="line">            mHbmMode = newHbmMode;</span><br><span class="line">            mHbmChangeCallback.run();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calculateHighBrightnessMode</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (!deviceSupportsHbm()) {</span><br><span class="line">            <span class="keyword">return</span> BrightnessInfo.HIGH_BRIGHTNESS_MODE_OFF;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (mIsHdrLayerPresent) {</span><br><span class="line">            <span class="keyword">return</span> BrightnessInfo.HIGH_BRIGHTNESS_MODE_HDR;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (isCurrentlyAllowed()) {</span><br><span class="line">            <span class="keyword">return</span> BrightnessInfo.HIGH_BRIGHTNESS_MODE_SUNLIGHT;</span><br><span class="line">        }</span><br><span class="line"><span class="comment">// 满足未开启HDR，且设备过热时，返回OFF状态</span></span><br><span class="line">        <span class="keyword">return</span> BrightnessInfo.HIGH_BRIGHTNESS_MODE_OFF;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isCurrentlyAllowed</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 如果mIsThermalStatusWithinLimit为false，则禁用HBM。</span></span><br><span class="line">        <span class="comment">// 如果允许 HBM（高于环境照度阈值），并且当前窗口内仍有时间用于额外的 HBM 使用，则返回 true。如果有 HDR 层，我们返回 false，因为我们不希望 HDR 的亮度 MAX 发生变化，HDR 的亮度缩放方式与不需要更改 MAX 的阳光 HBM 不同。 HDR 还需要在手动亮度下工作，该亮度永远不会调整最大亮度;所以我们以不调整最大值的方式实现HDR-HBM。</span></span><br><span class="line">        <span class="keyword">return</span> !mIsHdrLayerPresent</span><br><span class="line">                &amp;&amp; (mIsAutoBrightnessEnabled &amp;&amp; mIsTimeAvailable &amp;&amp; mIsInAllowedAmbientRange</span><br><span class="line">                &amp;&amp; mIsThermalStatusWithinLimit &amp;&amp; !mIsBlockedByLowPowerMode);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h4 id="刷新率限制（DisplayModeDirector）"><a href="#刷新率限制（DisplayModeDirector）" class="headerlink" title="刷新率限制（DisplayModeDirector）"></a>刷新率限制（DisplayModeDirector）</h4><p>DisplayModeDirector 负责根据系统范围和特定于显示器的配置确定系统允许自动选取哪些显示模式。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DisplayModeDirector.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyThrottling</span><span class="params">(Temperature temp)</span> {</span><br><span class="line">            <span class="comment">// 热事件回调</span></span><br><span class="line">            mStatus = temp.getStatus();</span><br><span class="line">            <span class="keyword">final</span> Vote vote;</span><br><span class="line">            <span class="keyword">if</span> (mStatus &gt;= Temperature.THROTTLING_CRITICAL) {</span><br><span class="line">                <span class="comment">// 大于CRITICAL状态，设置刷新率60Hz</span></span><br><span class="line">                vote = Vote.forRefreshRates(<span class="number">0f</span>, <span class="number">60f</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                vote = <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            mBallotBox.vote(GLOBAL_ID, Vote.PRIORITY_SKIN_TEMPERATURE, vote);</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><h2 id="Android-U上新增的变化"><a href="#Android-U上新增的变化" class="headerlink" title="Android U上新增的变化"></a>Android U上新增的变化</h2><p>亮度配置</p><p>DeviceState</p><h2 id="Dump命令"><a href="#Dump命令" class="headerlink" title="Dump命令"></a>Dump命令</h2><p>模拟热状态上报分发（不影响服务内的措施、热事件）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模拟热状态，不响应底层上报，6即代表THROTTLING_SHUTDOWN</span></span><br><span class="line">adb shell cmd thermalservice override-status 6 </span><br><span class="line"><span class="comment"># 退出模拟模式，恢复热状态</span></span><br><span class="line">adb shell cmd thermalservice reset</span><br></pre></td></tr></tbody></table></figure><p>获取当前热状态：<code>adb shell dumpsys thermalservice</code>， 执行结果示例如下：</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">IsStatusOverride: false</span><br><span class="line">ThermalEventListeners:</span><br><span class="line">        callbacks: <span class="number">1</span></span><br><span class="line">        killed: false</span><br><span class="line">        broadcasts count: <span class="literal">-1</span></span><br><span class="line">ThermalStatusListeners:</span><br><span class="line">        callbacks: <span class="number">5</span></span><br><span class="line">        killed: false</span><br><span class="line">        broadcasts count: <span class="literal">-1</span></span><br><span class="line">Thermal Status: <span class="number">0</span></span><br><span class="line">Cached temperatures:</span><br><span class="line">        Temperature{mValue=<span class="number">30.6</span>, mType=<span class="number">2</span>, mName=battery, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">44.5</span>, mType=<span class="number">1</span>, mName=GPU, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">56.0</span>, mType=<span class="number">8</span>, mName=soc, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">50.9</span>, mType=<span class="number">0</span>, mName=CPU0, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">49.0</span>, mType=<span class="number">0</span>, mName=CPU1, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">50.3</span>, mType=<span class="number">0</span>, mName=CPU2, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">48.0</span>, mType=<span class="number">0</span>, mName=CPU3, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">48.3</span>, mType=<span class="number">0</span>, mName=CPU4, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">48.7</span>, mType=<span class="number">0</span>, mName=CPU5, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">57.7</span>, mType=<span class="number">0</span>, mName=CPU6, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">58.7</span>, mType=<span class="number">0</span>, mName=CPU7, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="literal">-0</span>.<span class="number">078</span>, mType=<span class="number">7</span>, mName=ibat, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">41.728</span>, mType=<span class="number">3</span>, mName=skin, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">3.786</span>, mType=<span class="number">6</span>, mName=vbat, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">0.0</span>, mType=<span class="number">3</span>, mName=shell_back, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">0.0</span>, mType=<span class="number">3</span>, mName=shell_frame, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">0.0</span>, mType=<span class="number">3</span>, mName=shell_front, mStatus=<span class="number">0</span>}</span><br><span class="line">HAL Ready: true</span><br><span class="line">HAL connection:</span><br><span class="line">        ThermalHAL <span class="number">2.0</span> connected: yes</span><br><span class="line">Current temperatures from HAL:</span><br><span class="line">        Temperature{mValue=<span class="number">30.0</span>, mType=<span class="number">2</span>, mName=battery, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">3.986</span>, mType=<span class="number">6</span>, mName=vbat, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">32.219</span>, mType=<span class="number">3</span>, mName=shell_frame, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">48.0</span>, mType=<span class="number">8</span>, mName=soc, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="literal">-0</span>.<span class="number">078</span>, mType=<span class="number">7</span>, mName=ibat, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">36.7</span>, mType=<span class="number">0</span>, mName=CPU1, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">34.124</span>, mType=<span class="number">3</span>, mName=skin, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">36.4</span>, mType=<span class="number">1</span>, mName=GPU, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">36.4</span>, mType=<span class="number">0</span>, mName=CPU7, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">30.409</span>, mType=<span class="number">3</span>, mName=shell_front, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">31.943</span>, mType=<span class="number">3</span>, mName=shell_back, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">36.1</span>, mType=<span class="number">0</span>, mName=CPU6, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">36.4</span>, mType=<span class="number">0</span>, mName=CPU5, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">36.4</span>, mType=<span class="number">0</span>, mName=CPU0, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">36.7</span>, mType=<span class="number">0</span>, mName=CPU4, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">36.4</span>, mType=<span class="number">0</span>, mName=CPU3, mStatus=<span class="number">0</span>}</span><br><span class="line">        Temperature{mValue=<span class="number">37.0</span>, mType=<span class="number">0</span>, mName=CPU2, mStatus=<span class="number">0</span>}</span><br><span class="line">Current cooling devices from HAL:</span><br><span class="line">        CoolingDevice{mValue=<span class="number">0</span>, mType=<span class="number">2</span>, mName=thermal<span class="literal">-cpufreq-6</span>}</span><br><span class="line">        CoolingDevice{mValue=<span class="number">0</span>, mType=<span class="number">2</span>, mName=cpu<span class="literal">-isolate7</span>}</span><br><span class="line">        CoolingDevice{mValue=<span class="number">0</span>, mType=<span class="number">2</span>, mName=cpu<span class="literal">-isolate4</span>}</span><br><span class="line">        CoolingDevice{mValue=<span class="number">0</span>, mType=<span class="number">2</span>, mName=cpu<span class="literal">-isolate3</span>}</span><br><span class="line">        CoolingDevice{mValue=<span class="number">0</span>, mType=<span class="number">2</span>, mName=cpu<span class="literal">-isolate1</span>}</span><br><span class="line">        CoolingDevice{mValue=<span class="number">0</span>, mType=<span class="number">3</span>, mName=thermal<span class="literal">-devfreq-0</span>}</span><br><span class="line">        CoolingDevice{mValue=<span class="number">0</span>, mType=<span class="number">2</span>, mName=thermal<span class="literal">-cpufreq-0</span>}</span><br><span class="line">        CoolingDevice{mValue=<span class="number">0</span>, mType=<span class="number">2</span>, mName=cpu<span class="literal">-isolate6</span>}</span><br><span class="line">        CoolingDevice{mValue=<span class="number">0</span>, mType=<span class="number">2</span>, mName=cpu<span class="literal">-isolate5</span>}</span><br><span class="line">        CoolingDevice{mValue=<span class="number">0</span>, mType=<span class="number">2</span>, mName=cpu<span class="literal">-isolate0</span>}</span><br><span class="line">        CoolingDevice{mValue=<span class="number">0</span>, mType=<span class="number">2</span>, mName=cpu<span class="literal">-isolate2</span>}</span><br><span class="line">        CoolingDevice{mValue=<span class="number">0</span>, mType=<span class="number">1</span>, mName=battery}</span><br><span class="line">Temperature <span class="keyword">static</span> thresholds from HAL:</span><br><span class="line">        {.type = BATTERY, .name = battery, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">80.0</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">90.0</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .vrThrottlingThreshold = <span class="number">80.0</span>}</span><br><span class="line">        {.type = BCL_VOLTAGE, .name = vbat, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">3.2</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">3.0</span>], .vrThrottlingThreshold = <span class="number">3.2</span>}</span><br><span class="line">        {.type = SKIN, .name = shell_frame, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">45.0</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">95.0</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .vrThrottlingThreshold = <span class="number">40.0</span>}</span><br><span class="line">        {.type = BCL_PERCENTAGE, .name = soc, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">10.0</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">2.0</span>], .vrThrottlingThreshold = <span class="number">10.0</span>}</span><br><span class="line">        {.type = BCL_CURRENT, .name = ibat, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">4.5</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">9.0</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .vrThrottlingThreshold = <span class="number">4.5</span>}</span><br><span class="line">        {.type = CPU, .name = CPU1, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">95.0</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">115.0</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .vrThrottlingThreshold = <span class="number">95.0</span>}</span><br><span class="line">        {.type = SKIN, .name = skin, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">45.0</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">85.0</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .vrThrottlingThreshold = <span class="number">40.0</span>}</span><br><span class="line">        {.type = GPU, .name = GPU, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">95.0</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">115.0</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .vrThrottlingThreshold = <span class="number">95.0</span>}</span><br><span class="line">        {.type = CPU, .name = CPU7, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">95.0</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">115.0</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .vrThrottlingThreshold = <span class="number">95.0</span>}</span><br><span class="line">        {.type = SKIN, .name = shell_front, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">45.0</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">95.0</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .vrThrottlingThreshold = <span class="number">40.0</span>}</span><br><span class="line">        {.type = SKIN, .name = shell_back, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">45.0</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">95.0</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .vrThrottlingThreshold = <span class="number">40.0</span>}</span><br><span class="line">        {.type = CPU, .name = CPU6, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">95.0</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">115.0</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .vrThrottlingThreshold = <span class="number">95.0</span>}</span><br><span class="line">        {.type = CPU, .name = CPU5, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">95.0</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">115.0</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .vrThrottlingThreshold = <span class="number">95.0</span>}</span><br><span class="line">        {.type = CPU, .name = CPU0, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">95.0</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">115.0</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .vrThrottlingThreshold = <span class="number">95.0</span>}</span><br><span class="line">        {.type = CPU, .name = CPU4, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">95.0</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">115.0</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .vrThrottlingThreshold = <span class="number">95.0</span>}</span><br><span class="line">        {.type = CPU, .name = CPU3, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">95.0</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">115.0</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .vrThrottlingThreshold = <span class="number">95.0</span>}</span><br><span class="line">        {.type = CPU, .name = CPU2, .hotThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">95.0</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="number">115.0</span>], .coldThrottlingThresholds = [<span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>, <span class="type">NaN</span>], .vrThrottlingThreshold = <span class="number">95.0</span>}</span><br></pre></td></tr></tbody></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>通过Android 10热服务框架以及thermal hal 2.0版本的引入，上层应用可以主动获取这些系统硬件设备的温度数据,或者通过注册的回调函数（位于 PowerManager 类中）接收高温通知，进而在设备开始过热时调整系统及应用执行策略。例如，当系统温度较高时，jobscheduler 作业会受到限制，降低系统负载，从而可以有效缓解手机发热问题。</p><p>参考链接：</p><p><a href="https://blog.csdn.net/feelabclihu/article/details/107873407"> Android 热缓解框架解析_thermalservice_内核工匠的博客-CSDN博客</a></p><p><a href="https://source.android.google.cn/docs/core/power/thermal-mitigation?hl=zh-cn">热缓解  | Android 开源项目  | Android Open Source Project (google.cn)</a></p><p><a href="https://blog.csdn.net/zhouhuacai/article/details/78172267">Linux电源管理（五）thermal_小而的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 温控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chatgpt调研</title>
      <link href="/2023/04/01/chatgpt-diao-yan/"/>
      <url>/2023/04/01/chatgpt-diao-yan/</url>
      
        <content type="html"><![CDATA[<p>通过 fine-tune 训练基于 context 识别 prompt 模型，再使用此模型使用 embedding 插入上下文。</p><p><img src="/2023/04/01/chatgpt-diao-yan/image-20230401123658254.png" alt="基于embedding优化的对话流程"></p><p><img src="/2023/04/01/chatgpt-diao-yan/image-20230401202538636.png" alt="fine-tuning对比embedding语义搜索"></p><p>fine-tuning和语义搜索的区别：<a href="https://www.youtube.com/watch?v=9qq6HTr7Ocw&amp;t=592s">OpenAI Q&amp;A: Finetuning GPT-3 vs Semantic Search - which to use, when, and why? - YouTube</a></p><h2 id="1-fine-tuning"><a href="#1-fine-tuning" class="headerlink" title="#1 fine-tuning"></a>#1 fine-tuning</h2><p>作用：<strong>预设prompt到模型里，减少多次对话重复输入prompt</strong></p><p>场景：优化回答的格式、语气、情感</p><blockquote><p>请参考示例和CONTEXT回答下面的问题</p><p>示例:小红喜欢洋娃娃。小红的性别是？</p><p>答案:女的 </p><p>CONTEXT:如果答案是男性，请回答‘男的哈哈哈哈’；如果答案是女性，请直接回答女的；如果无法确定性别，请直接回答’不明确’；假设喜欢洋娃娃的人都是男人。</p><p>下面是问题:小东非常喜欢玩洋娃娃，小东的性别是？ </p></blockquote><p>chatgpt回答：</p><blockquote><p>男的哈哈哈哈</p></blockquote><ul><li><p>实际测试，对于上面这个问题，如果不加入CONTEXT，gpt的回答是性别不明确，需要更多信息。</p></li><li><p>如果在prompt中加入新的Task（假设喜欢洋娃娃的人都是男人），gpt将按照prompt回答。</p></li><li><p>如果在prompt中加入新的Task（假设喜欢洋娃娃的人都是汉子），gpt回答是不明确。但如果单独问汉子性别，回答是男性。</p></li><li><p>如果在prompt中加入新的Task（假设喜欢洋娃娃的人都是白人，并且白人都是男性），gpt回答是不明确</p></li><li><p>在上面的测试中，没有新的知识，都是gpt能理解的概念，只是加入了新的规则。gpt对于CONTEXT的推理能力不如直接问的。</p></li><li><p>微调只适用于GPT3模型</p></li></ul><p>​<a href="https://platform.openai.com/docs/guides/chat/is-fine-tuning-available-for-gpt-3-5-turbo">Is fine-tuning available for <code>gpt-3.5-turbo</code>?</a></p><blockquote><p>自 2023 年 3 月 1 日起，您只能微调基础 GPT-3 模型。有关如何使用微调模型的更多详细信息，请参阅微调指南。 </p><p>No. As of Mar 1, 2023, you can only fine-tune base GPT-3 models. See the <a href="https://platform.openai.com/docs/guides/fine-tuning">fine-tuning guide</a> for more details on how to use fine-tuned models.</p></blockquote><h2 id="2-embedding"><a href="#2-embedding" class="headerlink" title="#2 embedding"></a>#2 embedding</h2><p>作用：<strong>将文本转换为固定长度的连续向量</strong></p><p>使用场景：语义搜索，即在数据集中搜索出与对话内容最相似的提问，作为chatgpt的对话上下文，优化回答结果。</p><h3 id="第一大部分：私有数据切片-存储："><a href="#第一大部分：私有数据切片-存储：" class="headerlink" title="第一大部分：私有数据切片&amp;存储："></a>第一大部分：私有数据切片&amp;存储：</h3><p>1、首先需要将原始文本按照固定长度截取为一段一段文本，原因是希望通过openai的Embedding能力生成对应阶段文本的向量数据集合，由于openai对于输入有文本长度的限制，所以需要截取到固定长度。</p><p>2、调用openai的Embeddings接口，将一段段文本转成vector向量，这样每段文本就有一个向量与之对应。</p><p>3、将原始文本和对应的vector向量存储到之前提到的向量数据库中</p><h3 id="第二大部分：筛选和提问相关性高的内容整合一齐向Openai提问："><a href="#第二大部分：筛选和提问相关性高的内容整合一齐向Openai提问：" class="headerlink" title="第二大部分：筛选和提问相关性高的内容整合一齐向Openai提问："></a>第二大部分：筛选和提问相关性高的内容整合一齐向Openai提问：</h3><p>1、将用户输入的问题字符串当做输入，调用openai的Embeddings能力换取对应的vector向量</p><p>2、将用户输入文本对应的vector向量去向量数据库中查询高相似度的向量集合，即对应的相关性文本列表就都查了出来。</p><p>3、<strong>（？）将从向量数据库中查出来的相关性文本和原始的问题组成一个Prompt直接问chatgpt，既可以得出来结果。</strong></p><p>对应的Prompt的结构如下：</p><blockquote><p>You are a helpful assistant. When given CONTEXT you can answer questions using that information, and you always format your output in markdown. You include code snippets if relevant. If you are unsure and the answer is not explicitly written in the CONTEXT provided, you say “Sorry, I don’t know how to help with that.”  If the CONTEXT includes  source URLs include them under a SOURCES heading at the end of your response. Always include all of the relevant source urls from the CONTEXT, but never list a URL more than once (ignore trailing forward slashes when comparing for uniqueness). Never include URLs that are not in the CONTEXT sections. Never make up URLs`;</p><p>CONTEXT:<br>There are a couple of different ways to calculate a startup’s burn rate. One of the easiest methods is to take the average decrease in the company’s cash position over the past several months, exclusive of any financing events. For example, if a company had $300,000 in the bank, then $275,000 the next month, then $250,000 the last month, then the metric would be $25,000 a month. You should also include other non-checking account balances, such as your payment processor, a money market account, a savings account, etc. that likely contain dollars that should be included in the analysis…</p><p>Q:<br>How to calculate BURN RATE?</p><p>A:</p></blockquote><p>chatgpt回答：</p><blockquote><p>  Burn rate is the average decrease in a company’s cash position over a period of time, exclusive of any financing events. To calculate burn rate, you should add up the company’s cash position in all of its accounts, such as checking, payment processor, money market account, savings account, etc. Then, subtract the sum of the company’s cash position in the same accounts in the next period. Divide the difference by the number of months in the period to get the burn rate. </p><p> SOURCES:<br> None</p></blockquote><ul><li>语料库转换为embedding数据集</li></ul><p>示例代码：<a href="https://github.com/openai/openai-cookbook/blob/main/examples/Semantic_text_search_using_embeddings.ipynb">https://github.com/openai/openai-cookbook/blob/main/examples/Semantic_text_search_using_embeddings.ipynb</a></p><pre><code>1. 使用panda加载csv数据2. 对每一条文本数据，通过get_embedding接口转换为向量3. 重新保存为csv文件 </code></pre><ul><li>搜索最相似的文本</li></ul><p>示例代码：<a href="https://github.com/openai/openai-cookbook/blob/main/examples/Semantic_text_search_using_embeddings.ipynb">https://github.com/openai/openai-cookbook/blob/main/examples/Semantic_text_search_using_embeddings.ipynb</a></p><pre><code>1. 加载csv，读取embedding向量2. 将输入文本转换为embedding向量3. 将该向量依次与数据库中的向量进行比对（cosine_similarity接口），取出相似度最大的文本</code></pre><h2 id="3-Prompt工程"><a href="#3-Prompt工程" class="headerlink" title="# 3 Prompt工程"></a># 3 Prompt工程</h2><p>由于指令遵循<a href="https://beta.openai.com/docs/models">模型</a>的训练方式或训练数据的方式，有一些特定的提示格式能够让chatgpt更好地理解用户提问。</p><p><a href="https://help.openai.com/en/articles/6654000-best-practices-for-prompt-engineering-with-openai-api">Best practices for prompt engineering with OpenAI API | OpenAI Help Center</a></p><h2 id="4-数据合规"><a href="#4-数据合规" class="headerlink" title="#4 数据合规"></a>#4 数据合规</h2><blockquote><p>自 2023 年 3 月 1 日起，我们会将您的 API 数据保留 30 天，但不再使用您通过 API 发送的数据来改进我们的模型。在我们的数据使用政策中了解更多信息。</p><p>As of March 1st, 2023, we retain your API data for 30 days but no longer use your data sent via the API to improve our models. Learn more in our <a href="https://openai.com/policies/usage-policies">data usage policy</a>.</p></blockquote><h2 id="5-疑问"><a href="#5-疑问" class="headerlink" title="#5 疑问"></a>#5 疑问</h2><ol><li>通过在prompt中加入上下文context，可以让gpt从context中获取答案，为什么不能在fine-tunning的时候直接将context加入进去？参考<code>#2 fine-tuning</code>。</li><li>gpt3使用的是2020年8月以前的互联网数据，通过embedding外挂私有数据库，如何确保数据不是gpt3已经训练过的，减少不必要的context.</li><li>gpt将用户数据存储在境外，可能存在合规问题。</li></ol>]]></content>
      
      
      <categories>
          
          <category> AIGC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chatgpt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-整数拆分</title>
      <link href="/2022/05/30/leetcode-zheng-shu-chai-fen/"/>
      <url>/2022/05/30/leetcode-zheng-shu-chai-fen/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（LeetCode-343-）"><a href="#题目（LeetCode-343-）" class="headerlink" title="题目（LeetCode 343.）"></a>题目（<a href="https://leetcode.cn/problems/integer-break/">LeetCode 343.</a>）</h2><p>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。</p><p>返回 你可以获得的最大乘积 。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: n = 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1。</p></blockquote><p><strong>示例&nbsp;2:</strong></p><blockquote><p>输入: n = 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 ×&nbsp;3 ×&nbsp;4 = 36。<br>&nbsp;<br><strong>提示:</strong></p></blockquote><ul><li>2 &lt;= n &lt;= 58</li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>对于 <code>n = 10</code> 的示例，其子问题可拆分为以下情况：</p><ul><li><code>f(10) = 1 * f(9)</code></li><li><code>f(10) = 2 * f(8)</code></li><li>……</li><li><code>f(10) = 9 * f(1)</code></li></ul><p>拿第一种拆分来说，要使<code>f(10)</code>最大，那么<code>f(9)</code>的结果也必须最大，因此满足最优子问题性质。</p><p>而在计算<code>f(10)</code>的结果中用到了<code>f(8)</code>，同理对<code>f(9)</code>拆分子问题<code>f(9) = 1 * f(8)</code>，因此存在重叠子问题。</p><p>按以上思路对问题进行递归搜索，并通过<code>dp[]</code>记录子问题结果以剪枝。</p><ul><li>递归过程需要注意边界问题的判断，比如<code>n = 0</code>，这种结果来自于当<code>i = n </code>时，会有<code>n * f(0)</code>，因此<code>f(0)</code>直接返回<code>1</code>即可.</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">60</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> depth)</span> {</span><br><span class="line">        <span class="comment">// 注意考虑n=0的情况</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (dp[n] != -<span class="number">1</span>) {</span><br><span class="line">            <span class="comment">// 备忘录剪枝</span></span><br><span class="line">            <span class="keyword">return</span> dp[n];</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="comment">// 必须分成 2 段以上</span></span><br><span class="line">            <span class="keyword">if</span> (depth == <span class="number">0</span> &amp;&amp; i == n) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 分解子问题： i * f(n - i)</span></span><br><span class="line">            ans = max(ans, i * solve(n - i, depth + <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n] = ans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt;= n; i++) {</span><br><span class="line">            dp[i] = -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> solve(n, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu20开启自动休眠(Auto Hibernate)</title>
      <link href="/2021/07/07/ubuntu20-kai-qi-zi-dong-xiu-mian-auto-hibernate/"/>
      <url>/2021/07/07/ubuntu20-kai-qi-zi-dong-xiu-mian-auto-hibernate/</url>
      
        <content type="html"><![CDATA[<h2 id="配置交换文件"><a href="#配置交换文件" class="headerlink" title="配置交换文件"></a>配置交换文件</h2><ol><li><p>创建交换文件<br>大小应不小于系统内存大小，这里分配了17G。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先关闭已有的swap空间</span></span><br><span class="line">sudo swapoff -a</span><br><span class="line"><span class="comment"># 分配连续的磁盘空间，fallocate比dd命令更安全快速，空间大小参考后面的表格</span></span><br><span class="line">sudo fallocate -l 17G /swapfile</span><br><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 600 /swapfile</span><br><span class="line"><span class="comment"># 启用swapfile</span></span><br><span class="line">sudo mkswap /swapfile</span><br><span class="line">sudo swapon /swapfile</span><br><span class="line"><span class="comment"># 确认结果</span></span><br><span class="line">sudo swapon --show</span><br><span class="line">free</span><br></pre></td></tr></tbody></table></figure></li><li><p>使系统启动时挂载该交换文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'/swapfile none swap sw 0 0'</span> | sudo <span class="built_in">tee</span> -a /etc/fstab</span><br></pre></td></tr></tbody></table></figure></li><li><p>配置启动内核参数<br>使系统启动时从交换文件中恢复内存</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看swapfile的UUID</span></span><br><span class="line">sudo findmnt -no UUID -T /swapfile</span><br><span class="line"><span class="comment"># 查看swap_file_offset</span></span><br><span class="line">sudo filefrag -v /swapfile | awk <span class="string">'{ if($1=="0:"){print substr($4, 1, length($4)-2)} }'</span></span><br><span class="line"><span class="comment"># 编辑grub文件</span></span><br><span class="line">sudo vim /etc/default/grub</span><br><span class="line"><span class="comment"># 将grub文件中GRUB_CMDLINE_LINUX_DEFAULT参数修改为如下形式</span></span><br><span class="line"><span class="comment"># 其中UUID和resume_offset的值更换为上面两个命令的输出</span></span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">"quiet splash resume=UUID=86e4385d-a028-4027-9edc-a900cbbe090e resume_offset=100069376"</span></span><br><span class="line"><span class="comment"># 保存退出，然后更新grub配置</span></span><br><span class="line">sudo update-grub</span><br><span class="line"><span class="comment"># 编辑initramfs</span></span><br><span class="line">sudo vim /etc/initramfs-tools/conf.d/resume</span><br><span class="line"><span class="comment"># 加入下面一行，UUID替换为实际值</span></span><br><span class="line">resume=UUID=86e4385d-a028-4027-9edc-a900cbbe090e</span><br><span class="line"><span class="comment"># 保存退出，然后更新initramfs配置</span></span><br><span class="line">sudo update-initramfs -u</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">reboot</span><br></pre></td></tr></tbody></table></figure></li><li><p>测试是否可以正常休眠</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl hibernate</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="加入界面按钮"><a href="#加入界面按钮" class="headerlink" title="加入界面按钮"></a>加入界面按钮</h2><ol><li>安装<a href="https://extensions.gnome.org/extension/755/hibernate-status-button/">Hibernate Status Button</a>插件</li><li>增加配置文件<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建配置文件</span></span><br><span class="line">sudo vim /etc/polkit-1/localauthority/50-local.d/com.ubuntu.enable-hibernate.pkla</span><br><span class="line"><span class="comment"># 添加以下内容并保存</span></span><br><span class="line">[Re-<span class="built_in">enable</span> hibernate by default <span class="keyword">in</span> upower]</span><br><span class="line">Identity=unix-user:*</span><br><span class="line">Action=org.freedesktop.upower.hibernate</span><br><span class="line">ResultActive=<span class="built_in">yes</span></span><br><span class="line">[Re-<span class="built_in">enable</span> hibernate by default <span class="keyword">in</span> logind]</span><br><span class="line">Identity=unix-user:*</span><br><span class="line">Action=org.freedesktop.login1.hibernate;org.freedesktop.login1.handle-hibernate-key;org.freedesktop.login1;org.freedesktop.login1.hibernate-multiple-sessions;org.freedesktop.login1.hibernate-ignore-inhibit</span><br><span class="line">ResultActive=<span class="built_in">yes</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="自动挂起改成自动休眠"><a href="#自动挂起改成自动休眠" class="headerlink" title="自动挂起改成自动休眠"></a>自动挂起改成自动休眠</h2><p>打开dconf编辑器，搜索<code>power</code>，转到<code>/org/gnome/settings-daemon/power/</code>，修改下列配置如图：</p><img src="https://tva1.sinaimg.cn/large/008jAwkqgy1gs8las2rwrj30p4091q41.jpg" width="80%" data-width="904" data-height="325"><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://xie.infoq.cn/article/af26942709c82ab1c7cd47f87">https://xie.infoq.cn/article/af26942709c82ab1c7cd47f87</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安装/配置经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-掷骰子的N种方法</title>
      <link href="/2021/03/26/leetcode-zhi-tou-zi-de-n-chong-fang-fa/"/>
      <url>/2021/03/26/leetcode-zhi-tou-zi-de-n-chong-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（LeetCode-1155-）"><a href="#题目（LeetCode-1155-）" class="headerlink" title="题目（LeetCode 1155.）"></a>题目（<a href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/">LeetCode 1155.</a>）</h2><p>这里有&nbsp;d&nbsp;个一样的骰子，每个骰子上都有&nbsp;f&nbsp;个面，分别标号为&nbsp;1, 2, …, f。</p><p>我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。</p><p>如果需要掷出的总点数为&nbsp;target，请你计算出有多少种不同的组合情况（所有的组合情况总共有 f^d 种），<strong>模&nbsp;10^9 + 7</strong>&nbsp;后返回。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong>d = 1, f = 6, target = 3<br><strong>输出：</strong>1</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong>d = 2, f = 6, target = 7<br><strong>输出：</strong>6</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong>d = 2, f = 5, target = 10<br><strong>输出：</strong>1</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p><strong>输入：</strong>d = 1, f = 2, target = 3<br><strong>输出：</strong>0</p></blockquote><p><strong>示例 5：</strong></p><blockquote><p><strong>输入：</strong>d = 30, f = 30, target = 500<br><strong>输出：</strong>222616187<br>&nbsp;<br><strong>提示：</strong></p></blockquote><ul><li>1 &lt;= d, f &lt;= 30</li><li>1 &lt;= target &lt;= 1000</li></ul><h2 id="动态规划-备忘录"><a href="#动态规划-备忘录" class="headerlink" title="动态规划(备忘录)"></a>动态规划(备忘录)</h2><p>假设一共有6个骰子，每个骰子都有6个面，在抛出之后每个骰子的点数都要记录，也就是6x6的矩阵每行都取一个数组成一个序列，需要满足序列的和与target相等，计算这种序列一共有多少个。</p><p>由于target不能预先知道，因此需要构造出每一种可能的序列，判断其是否满足。在这里就存在子问题，比如6个骰子、6个面、求满足target=20的序列个数，若第一个骰子抛出5，问题则变成5个骰子、6个面、求满足target=15的序列个数。子问题重叠性质和最优子结构性质。</p><p>首先考虑暴力搜索，在问题与子问题之间，变化的状态为骰子的个数和target。使用dp[depth][target]表示在抛出第Depth个骰子之后，满足剩余骰子的序列之和等于target的数量。</p><p>最简单的子问题为骰子个数达到d个，当target为0时，此时序列满足条件，因此结果为1，若target&lt;0则不满足，结果为0。另外target一旦小于0即可知道该问题及其子问题都是无意义的，问题的结果置为0。以上即为递归的出口。</p><p>对于一个问题，抛出当前的骰子（对应于dfs中的for循环），骰子个数加1，计算抛出骰子后target的变化，然后递归求子问题的结果，并统计到cnt上，最后更新dp数组并返回结果。</p><p>在此基础上加入备忘录方法，递归求子问题之前首先判断dp数组中是否存在该子问题的解，如存在则直接读取即可。</p><p>需要注意读取dp数组的下标不能为负数。还有取模，如果中间结果溢出会导致运算变慢并结果错误。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">31</span>][<span class="number">1001</span>];</span><br><span class="line">    <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> d)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(d &gt;= depth){</span><br><span class="line">            dp[d][target] = target == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> dp[d][target];</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(target &lt;= <span class="number">0</span>){</span><br><span class="line">            dp[d][target] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=width;i++){</span><br><span class="line">            cnt %= mod;</span><br><span class="line">            <span class="comment">//cnt += dfs(target-i, d+1);</span></span><br><span class="line">            <span class="keyword">if</span> (target-i &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dp[d+<span class="number">1</span>][target-i] &gt;= <span class="number">0</span>)</span><br><span class="line">                cnt += dp[d+<span class="number">1</span>][target-i] % mod;  <span class="comment">//不取模会溢出</span></span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                cnt += <span class="built_in">dfs</span>(target-i, d+<span class="number">1</span>) % mod;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        dp[d][target] = cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> f, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">31</span>;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1001</span>;j++)</span><br><span class="line">                dp[i][j] = <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>-&gt;depth = d;</span><br><span class="line">        <span class="keyword">this</span>-&gt;width = f;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(target, <span class="number">0</span>) % mod;;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序设计周2020</title>
      <link href="/2020/12/15/cheng-xu-she-ji-zhou-2020/"/>
      <url>/2020/12/15/cheng-xu-she-ji-zhou-2020/</url>
      
        <content type="html"><![CDATA[<h2 id="售楼员销售楼房和奖金发放管理"><a href="#售楼员销售楼房和奖金发放管理" class="headerlink" title="售楼员销售楼房和奖金发放管理"></a>售楼员销售楼房和奖金发放管理</h2><p><strong>问题描述：</strong>某房产公司有若干名售楼员（编号：01，02……），销售四种产品：公寓，花园洋房，高层，别墅（编号：1-4，单价分别是60万，200万，140万和500万），每名售楼员都会把上个月销售额和销售的产品以报告形式上交。上交的内容包括：1）售楼员的编号；2）本月销售房子的类型编号和各类房子的销售数量。请编写一个处理系统，对每个月的销售情况进行统计和分析。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database MyHouse;</span><br><span class="line">use MyHouse;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> USERS(userId <span class="type">int</span> <span class="keyword">primary</span> key, userName <span class="type">varchar</span>(<span class="number">15</span>), passWd <span class="type">varchar</span>(<span class="number">15</span>))<span class="keyword">default</span> <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> HOUSES(houseId <span class="type">int</span> <span class="keyword">primary</span> key, houseName <span class="type">varchar</span>(<span class="number">10</span>), price <span class="type">int</span>)<span class="keyword">default</span> <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SALES(saleId <span class="type">int</span> <span class="keyword">primary</span> key AUTO_INCREMENT,</span><br><span class="line">    userId <span class="type">int</span>, </span><br><span class="line">    houseId <span class="type">int</span>, </span><br><span class="line">    saledDate <span class="type">date</span>, </span><br><span class="line">    price <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">foreign</span> key (userId) <span class="keyword">references</span> USERS(userId) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">no</span> action,</span><br><span class="line">    <span class="keyword">foreign</span> key (houseId) <span class="keyword">references</span> HOUSES(houseId) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">no</span> action</span><br><span class="line">    )<span class="keyword">default</span> <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> HOUSES <span class="keyword">values</span>(<span class="number">1</span>, "公寓", <span class="number">60</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> HOUSES <span class="keyword">values</span>(<span class="number">2</span>, "花园洋房", <span class="number">200</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> HOUSES <span class="keyword">values</span>(<span class="number">3</span>, "高层", <span class="number">140</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> HOUSES <span class="keyword">values</span>(<span class="number">4</span>, "别墅", <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> USERS <span class="keyword">values</span>(<span class="number">0</span>, "admin", "1234");</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> USERS <span class="keyword">values</span>(<span class="number">1</span>, "litn", "1234");</span><br></pre></td></tr></tbody></table></figure><ol><li>每个售楼员都可将自己本月的售楼信息输入到系统中，并保存为文件。</li></ol><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*注意，具体的price需要先查house表，然后再插入*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SALES(userId, houseId, saledDate, price) <span class="keyword">values</span>(<span class="number">0</span>, <span class="number">1</span>, "2020-12-10", <span class="number">60</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SALES(userId, houseId, saledDate, price) <span class="keyword">values</span>(<span class="number">0</span>, <span class="number">2</span>, "2020-12-10", <span class="number">200</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SALES(userId, houseId, saledDate, price) <span class="keyword">values</span>(<span class="number">0</span>, <span class="number">3</span>, "2020-12-11", <span class="number">140</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SALES(userId, houseId, saledDate, price) <span class="keyword">values</span>(<span class="number">0</span>, <span class="number">3</span>, "2020-12-12", <span class="number">140</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SALES(userId, houseId, saledDate, price) <span class="keyword">values</span>(<span class="number">0</span>, <span class="number">4</span>, "2020-12-13", <span class="number">500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SALES(userId, houseId, saledDate, price) <span class="keyword">values</span>(<span class="number">0</span>, <span class="number">4</span>, "2020-12-15", <span class="number">500</span>);</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>系统中至少需保留之前3个月，各售楼员的销售业绩信息（包括所销售的各类房型的数量、各类房型的销售额和总销售额）</li></ol><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*售楼员0 所有销售记录*/</span></span><br><span class="line"><span class="keyword">select</span> SALES.userId <span class="keyword">AS</span> userId, SALES.houseID <span class="keyword">AS</span> houseId, houseName, SALES.price <span class="keyword">AS</span> price, saledDate <span class="keyword">from</span> SALES, HOUSES <span class="keyword">where</span> SALES.houseID<span class="operator">=</span>HOUSES.houseID <span class="keyword">and</span> SALES.userId<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*售楼员0 总数量和总销售额*/</span></span><br><span class="line"><span class="keyword">select</span> SALES.userId <span class="keyword">AS</span> userId, <span class="built_in">count</span>(<span class="operator">*</span>), <span class="built_in">sum</span>(price) <span class="keyword">from</span> SALES <span class="keyword">where</span> SALES.userId<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*售楼员0 各房型销售数量、销售额*/</span></span><br><span class="line"><span class="keyword">select</span> userId, houseId, houseName, <span class="built_in">count</span>(<span class="operator">*</span>), <span class="built_in">sum</span>(price) <span class="keyword">from</span> (<span class="keyword">select</span> SALES.userId, SALES.houseId, houseName, SALES.price <span class="keyword">from</span> SALES, HOUSES <span class="keyword">where</span> SALES.houseID<span class="operator">=</span>HOUSES.houseID <span class="keyword">and</span> SALES.userId<span class="operator">=</span><span class="number">0</span>) <span class="keyword">as</span> a <span class="keyword">group</span> <span class="keyword">by</span> houseId;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当月售楼员0 总数量和总销售额*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>), <span class="built_in">sum</span>(price)  <span class="keyword">from</span> SALES <span class="keyword">where</span> <span class="keyword">year</span>(saledDate)<span class="operator">=</span><span class="keyword">year</span>(now()) <span class="keyword">and</span> <span class="keyword">month</span>(saledDate)<span class="operator">=</span><span class="keyword">month</span>(now()) <span class="keyword">and</span> SALES.userId<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当月售楼员0 各房型销售数量、销售额*/</span></span><br><span class="line"><span class="keyword">select</span> userId, houseId, houseName, <span class="built_in">count</span>(<span class="operator">*</span>), <span class="built_in">sum</span>(price)  <span class="keyword">from</span> (<span class="keyword">select</span> SALES.userId,SALES.houseId, houseName, SALES.price <span class="keyword">from</span> SALES, HOUSES <span class="keyword">where</span> SALES.houseID<span class="operator">=</span>HOUSES.houseID <span class="keyword">and</span> <span class="keyword">year</span>(saledDate)<span class="operator">=</span><span class="keyword">year</span>(now()) <span class="keyword">and</span> <span class="keyword">month</span>(saledDate)<span class="operator">=</span><span class="keyword">month</span>(now()) <span class="keyword">and</span> SALES.userId<span class="operator">=</span><span class="number">0</span>) <span class="keyword">as</span> a <span class="keyword">group</span> <span class="keyword">by</span> houseId;</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>系统可根据售楼员的编号以及本月所销售的各类型房子的数量，自动统计出每名售楼员本月的销售额，以及公司的各个房型本月的销量以及总销售额，存入文件中。</li></ol><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*当月公司所有销售记录*/</span></span><br><span class="line"><span class="keyword">select</span> userId, SALES.houseId <span class="keyword">AS</span> houseId, houseName, SALES.price <span class="keyword">AS</span> price, saledDate <span class="keyword">from</span> SALES, HOUSES <span class="keyword">where</span> SALES.houseID<span class="operator">=</span>HOUSES.houseID <span class="keyword">and</span> <span class="keyword">year</span>(saledDate)<span class="operator">=</span><span class="keyword">year</span>(now()) <span class="keyword">and</span> <span class="keyword">month</span>(saledDate)<span class="operator">=</span><span class="keyword">month</span>(now());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*最近5月公司总销售量和销售额(无序)*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>), <span class="built_in">sum</span>(price), CONCAT(<span class="keyword">YEAR</span>(saledDate),<span class="string">'-'</span>,<span class="keyword">MONTH</span>(saledDate)) <span class="keyword">AS</span> YearMonth <span class="keyword">from</span> (<span class="keyword">select</span> userId, SALES.houseId, houseName, SALES.price, saledDate <span class="keyword">from</span> SALES, HOUSES <span class="keyword">where</span> SALES.houseID<span class="operator">=</span>HOUSES.houseID) <span class="keyword">as</span> a <span class="keyword">group</span> <span class="keyword">by</span> YearMonth limit <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当月公司各房型销售数量、销售额*/</span></span><br><span class="line"><span class="keyword">select</span> houseId, houseName, <span class="built_in">count</span>(<span class="operator">*</span>), <span class="built_in">sum</span>(price)  <span class="keyword">from</span> (<span class="keyword">select</span> userId, SALES.houseId, houseName, SALES.price, saledDate <span class="keyword">from</span> SALES, HOUSES <span class="keyword">where</span> SALES.houseID<span class="operator">=</span>HOUSES.houseID <span class="keyword">and</span> <span class="keyword">year</span>(saledDate)<span class="operator">=</span><span class="keyword">year</span>(now()) <span class="keyword">and</span> <span class="keyword">month</span>(saledDate)<span class="operator">=</span><span class="keyword">month</span>(now())) <span class="keyword">as</span> a <span class="keyword">group</span> <span class="keyword">by</span> houseId;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当月各售楼员 总数量和总销售额*/</span></span><br><span class="line"><span class="keyword">select</span> userName, SALES.userId <span class="keyword">AS</span> userId, <span class="built_in">count</span>(<span class="operator">*</span>), <span class="built_in">sum</span>(SALES.price) <span class="keyword">AS</span> sum_price  <span class="keyword">from</span> SALES, HOUSES,USERS <span class="keyword">where</span> SALES.houseID<span class="operator">=</span>HOUSES.houseID <span class="keyword">and</span> SALES.userId<span class="operator">=</span>USERS.userID <span class="keyword">and</span> <span class="keyword">year</span>(saledDate)<span class="operator">=</span><span class="keyword">year</span>(now()) <span class="keyword">and</span> <span class="keyword">month</span>(saledDate)<span class="operator">=</span><span class="keyword">month</span>(now()) <span class="keyword">group</span> <span class="keyword">by</span> SALES.userId <span class="keyword">order</span> <span class="keyword">by</span> sum_price <span class="keyword">desc</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>对本月销售额达到500万元的售楼员发放奖金，公寓，花园洋房，高层和别墅的奖金分别为该房型销售价的2%，6%，3%和10%，显示出可获得提成的销售员姓名、编号与提成金额信息。</li></ol><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*当月销售额达到500万元的售楼员*/</span></span><br><span class="line"><span class="keyword">select</span> userName, SALES.userId, <span class="built_in">count</span>(<span class="operator">*</span>), <span class="built_in">sum</span>(SALES.price) <span class="keyword">AS</span> sum_price <span class="keyword">from</span> SALES, HOUSES,USERS <span class="keyword">where</span> SALES.houseID<span class="operator">=</span>HOUSES.houseID <span class="keyword">and</span> SALES.userId<span class="operator">=</span>USERS.userID <span class="keyword">and</span> <span class="keyword">year</span>(saledDate)<span class="operator">=</span><span class="keyword">year</span>(now()) <span class="keyword">and</span> <span class="keyword">month</span>(saledDate)<span class="operator">=</span><span class="keyword">month</span>(now()) <span class="keyword">group</span> <span class="keyword">by</span> SALES.userId  <span class="keyword">having</span> <span class="built_in">sum</span>(SALES.price)<span class="operator">&gt;=</span><span class="number">500</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(SALES.price) <span class="keyword">desc</span>;</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>允许系统管理员根据市场情况调整当前各房型的销售价格（最多每月调整1次）。</li></ol><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> HOUSES <span class="keyword">set</span> price<span class="operator">=</span>"?" <span class="keyword">where</span> houseId<span class="operator">=</span>?;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 所有房价修改记录的表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> MODIFY(id <span class="type">int</span> <span class="keyword">primary</span> key AUTO_INCREMENT,</span><br><span class="line">    userId <span class="type">int</span>,</span><br><span class="line">    modifyDate <span class="type">date</span>,</span><br><span class="line">    <span class="keyword">foreign</span> key (userId) <span class="keyword">references</span> USERS(userId) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">no</span> action</span><br><span class="line">    )<span class="keyword">default</span> <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入修改房价记录</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> MODIFY(userId, modifyDate) <span class="keyword">values</span>(<span class="number">0</span>, "2020-12-26");</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> MODIFY(userId, modifyDate) <span class="keyword">values</span>(<span class="number">0</span>, "2020-12-12");</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> MODIFY(userId, modifyDate) <span class="keyword">values</span>(<span class="number">0</span>, "2020-12-12");</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询当月修改房价次数</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> MODIFY <span class="keyword">where</span> <span class="keyword">year</span>(modifyDate)<span class="operator">=</span><span class="keyword">year</span>(now()) <span class="keyword">and</span> <span class="keyword">month</span>(modifyDate)<span class="operator">=</span><span class="keyword">month</span>(now()); </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> userName, passWd <span class="keyword">from</span> USERS <span class="keyword">where</span> userId<span class="operator">=</span><span class="operator">%</span>d;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SALES(userId, houseId, saledDate, price) <span class="keyword">values</span>(<span class="operator">%</span>d, <span class="operator">%</span>d, "%s", <span class="operator">%</span>d);</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>), <span class="built_in">sum</span>(price), CONCAT(<span class="keyword">YEAR</span>(saledDate),<span class="string">'-'</span>,<span class="keyword">MONTH</span>(saledDate)) <span class="keyword">AS</span> YearMonth </span><br><span class="line">        <span class="keyword">from</span> </span><br><span class="line">        (<span class="keyword">select</span> userId, SALES.houseId, houseName, SALES.price, saledDate </span><br><span class="line">        <span class="keyword">from</span> SALES, HOUSES <span class="keyword">where</span> SALES.houseID<span class="operator">=</span>HOUSES.houseID <span class="keyword">and</span> userId<span class="operator">=</span><span class="operator">%</span>d) <span class="keyword">as</span> a </span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> YearMonth </span><br><span class="line">        <span class="keyword">order</span> <span class="keyword">by</span> YearMonth </span><br><span class="line">        <span class="keyword">desc</span> limit <span class="number">12</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>), <span class="built_in">sum</span>(price), CONCAT(<span class="keyword">YEAR</span>(saledDate),<span class="string">'-'</span>,<span class="keyword">MONTH</span>(saledDate)) <span class="keyword">AS</span> YearMonth <span class="keyword">from</span> (<span class="keyword">select</span> userId, SALES.houseId, houseName, SALES.price, saledDate <span class="keyword">from</span> SALES, HOUSES <span class="keyword">where</span> SALES.houseID<span class="operator">=</span>HOUSES.houseID) <span class="keyword">as</span> a <span class="keyword">group</span> <span class="keyword">by</span> YearMonth <span class="keyword">order</span> <span class="keyword">by</span> YearMonth <span class="keyword">desc</span> limit <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> userId, houseId, houseName, <span class="built_in">count</span>(<span class="operator">*</span>), <span class="built_in">sum</span>(price)  <span class="keyword">from</span> (<span class="keyword">select</span> SALES.userId,SALES.houseId, houseName, SALES.price <span class="keyword">from</span> SALES, HOUSES <span class="keyword">where</span> SALES.houseID<span class="operator">=</span>HOUSES.houseID <span class="keyword">and</span> <span class="keyword">year</span>(saledDate)<span class="operator">=</span><span class="operator">%</span>d <span class="keyword">and</span> <span class="keyword">month</span>(saledDate)<span class="operator">=</span><span class="operator">%</span>d <span class="keyword">and</span> SALES.userId<span class="operator">=</span><span class="operator">%</span>d) <span class="keyword">as</span> a <span class="keyword">group</span> <span class="keyword">by</span> houseId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> houseId, houseName, <span class="built_in">count</span>(<span class="operator">*</span>), <span class="built_in">sum</span>(price)  <span class="keyword">from</span> (<span class="keyword">select</span> userId, SALES.houseId, houseName, SALES.price, saledDate <span class="keyword">from</span> SALES, HOUSES <span class="keyword">where</span> SALES.houseID<span class="operator">=</span>HOUSES.houseID <span class="keyword">and</span> <span class="keyword">year</span>(saledDate)<span class="operator">=</span><span class="operator">%</span>d <span class="keyword">and</span> <span class="keyword">month</span>(saledDate)<span class="operator">=</span><span class="operator">%</span>d) <span class="keyword">as</span> a <span class="keyword">group</span> <span class="keyword">by</span> houseId</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> saleId, saledDate, SALES.userId <span class="keyword">AS</span> userId, SALES.houseID <span class="keyword">AS</span> houseId, houseName, SALES.price <span class="keyword">AS</span> price, saledDate <span class="keyword">from</span> SALES, HOUSES <span class="keyword">where</span> SALES.houseID<span class="operator">=</span>HOUSES.houseID <span class="keyword">and</span> SALES.userId<span class="operator">=</span><span class="operator">%</span>d <span class="keyword">order</span> <span class="keyword">by</span> saledDate <span class="keyword">desc</span>, saleId <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> saleId, saledDate, SALES.userId <span class="keyword">AS</span> userId, SALES.houseID <span class="keyword">AS</span> houseId, houseName, SALES.price <span class="keyword">AS</span> price, saledDate <span class="keyword">from</span> SALES, HOUSES <span class="keyword">where</span> SALES.houseID<span class="operator">=</span>HOUSES.houseID <span class="keyword">order</span> <span class="keyword">by</span> saledDate <span class="keyword">desc</span>, saleId <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> userName, SALES.userId <span class="keyword">AS</span> userId, <span class="built_in">count</span>(<span class="operator">*</span>), <span class="built_in">sum</span>(SALES.price) <span class="keyword">AS</span> sum_price <span class="keyword">from</span> SALES, HOUSES,USERS <span class="keyword">where</span> SALES.houseID<span class="operator">=</span>HOUSES.houseID <span class="keyword">and</span> SALES.userId<span class="operator">=</span>USERS.userID <span class="keyword">and</span> <span class="keyword">year</span>(saledDate)<span class="operator">=</span><span class="keyword">year</span>(now()) <span class="keyword">and</span> <span class="keyword">month</span>(saledDate)<span class="operator">=</span><span class="keyword">month</span>(now()) <span class="keyword">group</span> <span class="keyword">by</span> SALES.userId  <span class="keyword">having</span> <span class="built_in">sum</span>(SALES.price)<span class="operator">&gt;=</span><span class="number">500</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(SALES.price) <span class="keyword">desc</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-分割数组为连续子序列</title>
      <link href="/2020/12/06/leetcode-fen-ge-shu-zu-wei-lian-xu-zi-xu-lie/"/>
      <url>/2020/12/06/leetcode-fen-ge-shu-zu-wei-lian-xu-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（LeetCode-659-）"><a href="#题目（LeetCode-659-）" class="headerlink" title="题目（LeetCode 659.）"></a>题目（<a href="https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences">LeetCode 659.</a>）</h2><p>给你一个按升序排序的整数数组 <code>num</code>（可能包含重复数字），请你将它们分割成一个或多个长度至少为 3 的子序列，其中每个子序列都由连续整数组成。</p><p>如果可以完成上述分割，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入:</strong>[1,2,3,3,4,5]<br><strong>输出:</strong> True<br><strong>解释:</strong><br>你可以分割出这样两个连续子序列 :<br>1, 2, 3<br>3, 4, 5</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入:</strong> [1,2,3,3,4,4,5,5]<br><strong>输出:</strong> True<br><strong>解释:</strong><br>你可以分割出这样两个连续子序列 :<br>1, 2, 3, 4, 5<br>3, 4, 5</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入:</strong> [1,2,3,4,4,5]<br><strong>输出:</strong> False</p></blockquote><p><strong>提示：</strong></p><ul><li>1 &lt;= nums.length &lt;= 10000</li></ul><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>用哈希表把所有数字出现的次数统计出来，之后就是贪心，使每个子序列尽可能长，只要后一个数字的次数比前一个数字的次数多，那么后一个数字就和前一个数字在同一个子序列中。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPossible</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(size &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hashmap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : nums)</span><br><span class="line">            hashmap[it]++;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> st = nums[<span class="number">0</span>], ed = nums[size<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> pre = INT_MIN;</span><br><span class="line">        <span class="type">int</span> now = INT_MIN;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(st &lt;= ed){                </span><br><span class="line">            now = hashmap[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pre &lt;= now){</span><br><span class="line">                cnt++;</span><br><span class="line">                hashmap[i]--;</span><br><span class="line">                <span class="keyword">if</span>(hashmap[i] &lt;= <span class="number">0</span>)</span><br><span class="line">                    st = i+<span class="number">1</span>;           </span><br><span class="line">                i++;</span><br><span class="line">                pre = now;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">if</span>(cnt &lt; <span class="number">3</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                i = st;</span><br><span class="line">                pre = INT_MIN;</span><br><span class="line">            }</span><br><span class="line">        } </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; <span class="number">3</span>)                   </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FlutterUI:按钮</title>
      <link href="/2020/11/27/flutterui-an-niu/"/>
      <url>/2020/11/27/flutterui-an-niu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-使用RaisedButton实现点击"><a href="#1-使用RaisedButton实现点击" class="headerlink" title="1. 使用RaisedButton实现点击"></a>1. 使用RaisedButton实现点击</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">* ```RoundedRectangleBorder``` ：圆角矩形</span><br><span class="line">* ```CircleBorder``` ：圆形</span><br><span class="line">* ```StadiumBorder``` ：左右两端是半圆的矩形。</span><br><span class="line"></span><br><span class="line">```padding```是相对于```RaisedButton```内的子Widget而言的。</span><br><span class="line"></span><br><span class="line">博客代码高亮没有支持dart语言，只能先用java代替了。</span><br><span class="line">```java</span><br><span class="line">    Widget loginButton2 = Positioned(</span><br><span class="line">        left: MediaQuery.of(context).size.width / 4,</span><br><span class="line">        bottom: 40,</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">          splashColor: Colors.green,</span><br><span class="line">          padding: EdgeInsets.symmetric(vertical: 28, horizontal: 67),</span><br><span class="line">          color: Color.fromRGBO(234, 60, 3, 1),</span><br><span class="line">          shape: RoundedRectangleBorder(</span><br><span class="line">              borderRadius: BorderRadius.circular(9.0)</span><br><span class="line">          ),</span><br><span class="line">          onPressed: ()=&gt;Navigator.of(context).push(MaterialPageRoute(builder: (_) =&gt; RegisterPage())),</span><br><span class="line">          child: Text("Log In",</span><br><span class="line">              style: const TextStyle(</span><br><span class="line">                  color: const Color(0xfffefefe),</span><br><span class="line">                  fontWeight: FontWeight.w600,</span><br><span class="line">                  fontStyle: FontStyle.normal,</span><br><span class="line">                  fontSize: 20.0)),</span><br><span class="line">        )</span><br><span class="line">    );</span><br></pre></td></tr></tbody></table></figure><h2 id="2-使用InkWell实现点击"><a href="#2-使用InkWell实现点击" class="headerlink" title="2. 使用InkWell实现点击"></a>2. 使用InkWell实现点击</h2><p>这种方法在点击之后没有阴影，但是按钮定制更灵活。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Widget</span> <span class="variable">loginButton</span> <span class="operator">=</span> Positioned(</span><br><span class="line">  left: MediaQuery.of(context).size.width / <span class="number">4</span>,</span><br><span class="line">  bottom: <span class="number">40</span>,</span><br><span class="line">  child: InkWell(</span><br><span class="line">    onTap: () {</span><br><span class="line">      Navigator.of(context)</span><br><span class="line">          .push(MaterialPageRoute(builder: (_) =&gt; RegisterPage()));</span><br><span class="line">    },</span><br><span class="line">    child: Container(</span><br><span class="line">      width: MediaQuery.of(context).size.width / <span class="number">2</span>,</span><br><span class="line">      height: <span class="number">80</span>,</span><br><span class="line">      child: Center(</span><br><span class="line">          child: <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">"Log In"</span>,</span><br><span class="line">              style: const <span class="title function_">TextStyle</span><span class="params">(</span></span><br><span class="line"><span class="params">                  color: const Color(<span class="number">0xfffefefe</span>)</span>,</span><br><span class="line">                  fontWeight: FontWeight.w600,</span><br><span class="line">                  fontStyle: FontStyle.normal,</span><br><span class="line">                  fontSize: <span class="number">20.0</span>))),</span><br><span class="line">      decoration: BoxDecoration(</span><br><span class="line">          gradient: LinearGradient(</span><br><span class="line">              colors: [</span><br><span class="line">                Color.fromRGBO(<span class="number">236</span>, <span class="number">60</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">                Color.fromRGBO(<span class="number">234</span>, <span class="number">60</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">                Color.fromRGBO(<span class="number">216</span>, <span class="number">78</span>, <span class="number">16</span>, <span class="number">1</span>),</span><br><span class="line">              ],</span><br><span class="line">              begin: FractionalOffset.topCenter,</span><br><span class="line">              end: FractionalOffset.bottomCenter),</span><br><span class="line">          boxShadow: [</span><br><span class="line">            BoxShadow(</span><br><span class="line">              color: Color.fromRGBO(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.16</span>),</span><br><span class="line">              offset: Offset(<span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">              blurRadius: <span class="number">10.0</span>,</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">          borderRadius: BorderRadius.circular(<span class="number">9.0</span>)),</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>还可以和Card组合，实现点击阴影</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Widget</span> <span class="variable">loginButton3</span> <span class="operator">=</span> Positioned(</span><br><span class="line">    left: MediaQuery.of(context).size.width / <span class="number">4</span>,</span><br><span class="line">    bottom: <span class="number">40</span>,</span><br><span class="line">    child: Card(</span><br><span class="line">      color: Color.fromRGBO(<span class="number">234</span>, <span class="number">60</span>, <span class="number">3</span>, <span class="number">1</span>),</span><br><span class="line">      margin: EdgeInsets.all(<span class="number">0</span>),</span><br><span class="line">      elevation: <span class="number">0.0</span>,</span><br><span class="line">      shape: RoundedRectangleBorder(</span><br><span class="line">        borderRadius: BorderRadius.circular(<span class="number">9.0</span>)</span><br><span class="line">      ),</span><br><span class="line">      child: Container(</span><br><span class="line">        width: MediaQuery.of(context).size.width / <span class="number">2</span>,</span><br><span class="line">        height: <span class="number">80</span>,</span><br><span class="line">        child: InkWell(</span><br><span class="line">          borderRadius: BorderRadius.circular(<span class="number">9.0</span>),</span><br><span class="line">          onTap: () {</span><br><span class="line">            Navigator.of(context)</span><br><span class="line">                .push(MaterialPageRoute(builder: (_) =&gt; RegisterPage()));</span><br><span class="line">          },</span><br><span class="line">          splashColor: Colors.green,</span><br><span class="line">          child: Center(</span><br><span class="line">              child: <span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">"Log In"</span>,</span><br><span class="line">                  style: const <span class="title function_">TextStyle</span><span class="params">(</span></span><br><span class="line"><span class="params">                      color: const Color(<span class="number">0xfffefefe</span>)</span>,</span><br><span class="line">                      fontWeight: FontWeight.w600,</span><br><span class="line">                      fontStyle: FontStyle.normal,</span><br><span class="line">                      fontSize: <span class="number">20.0</span>))),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><img src="https://tvax2.sinaimg.cn/large/007P6MCBgy1gl4193yfskj308004374a.jpg" alt="2020-11-27 21-04-09 的屏幕截图" width="20%" data-width="288" data-height="147">]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu20.04编译Android11</title>
      <link href="/2020/11/27/ubuntu20-04-bian-yi-android11/"/>
      <url>/2020/11/27/ubuntu20-04-bian-yi-android11/</url>
      
        <content type="html"><![CDATA[<blockquote><p>配置：ubuntu20.04 + 锐龙R5_3500U + 20G </p></blockquote><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><h3 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1. 安装Git"></a>1. 安装Git</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">git config –global user.email <span class="string">"test@test.com"</span></span><br><span class="line">git config –global user.name <span class="string">"test"</span></span><br></pre></td></tr></tbody></table></figure><h3 id="2-安装Java"><a href="#2-安装Java" class="headerlink" title="2. 安装Java"></a>2. 安装Java</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:openjdk-r/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></tbody></table></figure><h3 id="3-配置repo"><a href="#3-配置repo" class="headerlink" title="3. 配置repo"></a>3. 配置repo</h3><p>如果你使用的是其他终端，比如zsh，则将下面的<code>.bashrc</code>替换为<code>.zshrc</code>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/bin</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"PATH=~/bin:\$PATH"</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line"><span class="built_in">chmod</span> a+x ~/bin/repo</span><br></pre></td></tr></tbody></table></figure><h3 id="4-修改-bin-repo"><a href="#4-修改-bin-repo" class="headerlink" title="4. 修改~/bin/repo"></a>4. 修改~/bin/repo</h3><p>找到REPO_URL字段，将其替换为</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPO_URL = <span class="string">'https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/'</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-为文件夹初始化repo"><a href="#5-为文件夹初始化repo" class="headerlink" title="5. 为文件夹初始化repo"></a>5. 为文件夹初始化repo</h3><p>创建存放源码的文件夹并进入。<strong>注意</strong>，路径不能有中文名，否则编译时会报错。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/AndroidSrc</span><br><span class="line"><span class="built_in">cd</span> ~/AndroidSrc</span><br></pre></td></tr></tbody></table></figure><p>初始化repo</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-11.0.0_r3</span><br></pre></td></tr></tbody></table></figure><h3 id="6-安装依赖库"><a href="#6-安装依赖库" class="headerlink" title="6. 安装依赖库"></a>6. 安装依赖库</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib</span><br><span class="line">sudo apt-get install -y git flex bison gperf build-essential libncurses5-dev:i386</span><br><span class="line">sudo apt-get install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386</span><br><span class="line">sudo apt-get install dpkg-dev libsdl1.2-dev libesd0-dev</span><br><span class="line">sudo apt-get install git-core gnupg flex bison gperf build-essential</span><br><span class="line">sudo apt-get install zip curl zlib1g-dev gcc-multilib g++-multilib</span><br><span class="line">sudo apt-get install libc6-dev-i386</span><br><span class="line">sudo apt-get install lib32ncurses5-dev x11proto-core-dev libx11-dev</span><br><span class="line">sudo apt-get install libgl1-mesa-dev libxml2-utils xsltproc unzip m4</span><br><span class="line">sudo apt-get install lib32z-dev ccache</span><br><span class="line">sudo apt-get install libssl-dev</span><br></pre></td></tr></tbody></table></figure><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo <span class="built_in">sync</span> –no-tags -j8</span><br></pre></td></tr></tbody></table></figure><p><strong>可能遇到的问题</strong></p><ul><li><code>RPC failed; curl 56 GnuTLS recv error (-9)</code></li></ul><p>网络不好，切换网络重新执行sync。</p><h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><ul><li><p>在AndroidSrc目录下执行下列操作。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">lunch aosp_x86_64-eng</span><br><span class="line">make -j8</span><br></pre></td></tr></tbody></table></figure><p>其中，以无参数执行<code>lunch</code>可以自己选择编译的目标设备，<code>make</code>的<code>-j</code>参数用来指定同时编译的线程数，一般来说设置为CPU核心数x2。</p></li><li><p>运行模拟器</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emulator</span><br></pre></td></tr></tbody></table></figure></li></ul><img src="https://tva1.sinaimg.cn/large/007P6MCBgy1gl40tt0lukj30du0pddjy.jpg" alt="2020-11-27 20-40-22 的屏幕截图" width="30%" data-width="498" data-height="913"><h2 id="编译时可能遇到的问题"><a href="#编译时可能遇到的问题" class="headerlink" title="编译时可能遇到的问题"></a>编译时可能遇到的问题</h2><ol><li><code>'ascii' codec can't decode byte 0xe6 in position 16: ordinal not in...</code></li></ol><p>python2默认是ascii编码，无法识别中文字符，检查源码文件夹路径是否存在中文字符。</p><ol start="2"><li><code>java.lang.reflect.InvocationTargetException Error loading jar file.</code></li></ol><p>在加载doclava.jar文件时报错，我检查了打印出来的目录后发现该文件是存在的，把源码文件夹路径修改为全英文后错误消失。我在安装ubuntu选择语言的时候选了中文，导致一些常用的文件夹全是中文名，刚好把源码放到了文档里，因此出现上面这些奇奇怪怪的错误。</p><ol start="3"><li><code>Exception in thread "main" java.lang.OutOfMemoryError: Java heap</code></li></ol><p>内存不足，可尝试降低-j的值，比如单线程编译<code>make -j1</code>。使用8线程编译内存最高占用12G多，刚开始电脑8G内存，除去AMD显卡占用的2G内存实际只有5.7G，后来加了根16G的内存条正常编译。</p><h2 id="调试源码"><a href="#调试源码" class="headerlink" title="调试源码"></a>调试源码</h2><ol><li>Project Structure中新建一个Module</li><li>Edit Configurations新建一个debug配置，全部选nothing</li><li>最后Attach Debugger to Android Process</li></ol>]]></content>
      
      
      <categories>
          
          <category> 安装/配置经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用mmap将文件复制到标准输出</title>
      <link href="/2020/11/26/yong-mmap-jiang-wen-jian-fu-zhi-dao-biao-zhun-shu-chu/"/>
      <url>/2020/11/26/yong-mmap-jiang-wen-jian-fu-zhi-dao-biao-zhun-shu-chu/</url>
      
        <content type="html"><![CDATA[<p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。</p><p>在使用mmap映射之后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。</p><p>mmap除了可以减少read,write等系统调用以外，还可以减少内存的拷贝次数，比如在read调用时，一个完整的流程是操作系统读磁盘文件到页缓存，再从页缓存将数据拷贝到read传递的buffer里，而如果使用mmap之后，操作系统只需要将磁盘读到页缓存，然后用户就可以直接通过指针的方式操作mmap映射的内存，减少了从内核态到用户态的数据拷贝。</p><h2 id="csapp练习题9-5"><a href="#csapp练习题9-5" class="headerlink" title="csapp练习题9.5"></a>csapp练习题9.5</h2><p>编写一个 C 程序 mrnapcopy.c ,使用 mmap 将一个任意大小的磁盘文件复制到 stdout 。输入文件的名字必须作为一个命令行参数来传递。</p><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>调用<code>open</code>函数可以打开或创建一个文件。</p><ul><li>输入：文件路径<code>path</code>， 打开方式<code>oflag</code> 等</li><li>输出：若成功，返回文件描述符；若出错，返回-1</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>其中常用的oflag有：</p><ul><li><code>O_RDONLY</code> 只读打开</li><li><code>O_WRONLY</code> 只写打开</li><li><code>O_RDWR</code>   读写打开</li><li><code>O_EXEC</code>   只执行打开</li><li><code>O_SEARCH</code> 只搜索打开（应用于目录）</li></ul><blockquote><p><strong>文件描述符</strong>：对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数<br>当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符<br>当读写一个文件时，使用<code>open</code>或<code>create</code>返回的文件描述符标识该文件，将其作为参数传给<code>read</code>或<code>write</code>。</p></blockquote><h2 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h2><p>调用<code>fstat</code>函数可以获得已在描述符<code>fd</code>上打开文件的有关信息。</p><ul><li>输入：文件描述符<code>fd</code>，stat结构体指针</li><li>输出：若成功，返回0，若失败，返回-1</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>其中信息存放在<code>struct stat</code>结构体，里面有一个<code>st_size</code>字段，表示以字节为单位的文件长度，此字段只对普通文件、目录文件、链接文件有意义。</p><h2 id="mmap映射文件"><a href="#mmap映射文件" class="headerlink" title="mmap映射文件"></a>mmap映射文件</h2><p>将文件映射到当前进程的虚拟地址空间。使用<code>mmap</code>函数来创建新的虚拟内存区域，并将对象映射到这些区域中。</p><p>mmap函数要求内核创建一个新的虚拟内存区域，最好是从地址start开始的一个区域，并将文件描述符fd指定的对象的一个连续片段（chunk）映射到这个新的区域</p><ul><li>输入：长度、访问权限位、文件描述符 等</li><li>输出：若成功，返回指向映射区域的指针，若失败，返回MAP_FAILED(-1)</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/man.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ol><li>参数<code>prot</code>包含描述新映射的虚拟内存区域的访问权限位（即在相应区域结构中的vm_prot位）</li></ol><ul><li><code>PROT_EXEC</code> :这个区域内的页面由可以被 CPU 执行的指令组成。</li><li><code>PROT_READ</code> :这个区域内的页面可读。</li><li><code>PROT_WRITE</code> :这个区域内的页面可写。</li><li><code>PROT_NONE</code> :这个区域内的页面不能被访问 。</li></ul><ol start="2"><li>参数 <code>flags</code> 由描述被映射对象类型的位组成。</li></ol><ul><li><code>MAP_ANON</code> 表示被映射的对象就是一个匿名对象,而相应的虚拟页面是请求二进制零的。 </li><li><code>MAP_PRIVATE</code> 表示被映射的对象是一个私有的、写时复制的对象</li><li><code>MAP_SHARED</code> 表示是一个共享对象</li></ul><h2 id="复制到stdout"><a href="#复制到stdout" class="headerlink" title="复制到stdout"></a>复制到stdout</h2><p>调用<code>write</code>向打开文件写数据。这里打开的文件便是标准输出<code>STDOUT_FILENO</code></p><ul><li>输入：文件描述符，存放待写内存的地址，内容大小</li><li>输出：若成功，返回已写的字节数，若失败，返回-1</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>{</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> debug</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"debug\n"</span>);</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>] = <span class="string">"/home/reflecter/Documents/MyCode/Code-Cpp/Aproject/linux_learning/mmapcopy.c"</span>;</span><br><span class="line">    argc = <span class="number">2</span>;</span><br><span class="line">    argv = (<span class="type">char</span>**)<span class="built_in">malloc</span>(<span class="number">2</span>*<span class="built_in">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">    <span class="type">char</span> tmp = argc + <span class="string">'0'</span>;</span><br><span class="line">    argv[<span class="number">0</span>] = &amp;tmp;</span><br><span class="line">    argv[<span class="number">1</span>] = s;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入参数: 文件路径\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件打开失败！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> buf;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">fstat</span>(fd, &amp;buf)){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"获取文件信息失败！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        size = buf.st_size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> debug</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fd = %d\n"</span>, fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"size = %ld\n"</span>, size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *address = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(MAP_FAILED == address){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"内存映射失败！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == <span class="built_in">write</span>(STDOUT_FILENO, address, size)){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"写到标准输出失败！\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-视频拼接</title>
      <link href="/2020/10/24/leetcode-shi-pin-pin-jie/"/>
      <url>/2020/10/24/leetcode-shi-pin-pin-jie/</url>
      
        <content type="html"><![CDATA[<p>今天是10.24，刚好leetcode的每日打卡题就是题库里的第1024道题，嘿嘿。</p><h2 id="题目（LeetCode-1024-）"><a href="#题目（LeetCode-1024-）" class="headerlink" title="题目（LeetCode 1024.）"></a>题目（<a href="https://leetcode-cn.com/problems/video-stitching/">LeetCode 1024.</a>）</h2><p>你将会获得一系列视频片段，这些片段来自于一项持续时长为&nbsp;T&nbsp;秒的体育赛事。这些片段可能有所重叠，也可能长度不一。</p><p>视频片段&nbsp;clips[i]&nbsp;都用区间进行表示：开始于&nbsp;clips[i][0]&nbsp;并于&nbsp;clips[i][1]&nbsp;结束。我们甚至可以对这些片段自由地再剪辑，例如片段&nbsp;[0, 7]&nbsp;可以剪切成&nbsp;[0, 1] +&nbsp;[1, 3] + [3, 7]&nbsp;三部分。</p><p>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回&nbsp;-1 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10<br>输出：3<br>解释：<br>我们选中 [0,2], [8,10], [1,9] 这三个片段。<br>然后，按下面的方案重制比赛片段：<br>将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。<br>现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong>clips = [[0,1],[1,2]], T = 5<br><strong>输出：</strong>-1<br><strong>解释：</strong><br>我们无法只用 [0,1] 和 [1,2] 覆盖 [0,5] 的整个过程。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong>clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9<br><strong>输出：</strong>3<br><strong>解释：</strong><br>我们选取片段 [0,4], [4,7] 和 [6,9] 。</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p><strong>输入：</strong>clips = [[0,4],[2,8]], T = 5<br><strong>输出：</strong>2<br><strong>解释：</strong><br>注意，你可能录制超过比赛结束时间的视频。</p></blockquote><p><strong>提示：</strong></p><ul><li>1 &lt;= clips.length &lt;= 100</li><li>0 &lt;= clips[i][0] &lt;=&nbsp;clips[i][1] &lt;= 100</li><li>0 &lt;= T &lt;= 100</li></ul><h2 id="朴素搜索"><a href="#朴素搜索" class="headerlink" title="朴素搜索"></a>朴素搜索</h2><p>对于clips数组中的每一个元素，可以选或者不选，那么选了就个数加 1 ，不选就个数不变，保证每次选的元素都能和已经选的元素拼接出连续的区间，然后就是选了和不选的情况取最小值。</p><p>在这里，我将clip数组排序，按照区间左部从小到大，那么在每次选择的时候，如果该元素的区间左部大于当前的起点，那么这个子问题就是无解的，返回一个无穷大。因为排序，后续的元素的区间左部肯定大于等于该元素的区间左部，那么就没办法拼接出完整的视频。</p><p>下面是没有加记忆化的朴素搜索，在跑了几十个用例后超时了，其实在这基础上加一个dp数组记忆化就能过了。</p><p>一个错误的贪心：按区间左部从小到大排序，区间右部从大到小排序，然后每次取区间左部最小右部最大的片段来拼接视频。可以举出反例：[0,4], [0,3], [0,2], [2,6], [4,7], T=7。第一步选择[0,4]，区间[0,2]和[0,3]都被包含在[0,4]中，所以不选择；第二步对于区间[2,6]，<code>0&lt;2&lt;4 并且 4&lt;6</code>，故也选择，第三步选择[4,7]，但实际上[2,6]是多余的。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 超时，需要记忆化dp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX = <span class="number">0x6f6f6f6f</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; clips;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rep</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= T)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k &gt;= clips.<span class="built_in">size</span>()){</span><br><span class="line">            <span class="keyword">return</span> MAX;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(clips[k][<span class="number">0</span>] &lt;= i)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">rep</span>(<span class="built_in">max</span>(i,clips[k][<span class="number">1</span>]), k+<span class="number">1</span>)+<span class="number">1</span>, <span class="built_in">rep</span>(i, k+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> MAX;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">videoStitching</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; clips, <span class="type">int</span> T)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>-&gt;clips = clips;</span><br><span class="line">        <span class="keyword">this</span>-&gt;T = T;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;clips.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;clips.<span class="built_in">end</span>(), <span class="keyword">this</span>-&gt;cmp);</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">rep</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans == MAX ? <span class="number">-1</span> : ans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;=b[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="备忘录搜索"><a href="#备忘录搜索" class="headerlink" title="备忘录搜索"></a>备忘录搜索</h2><p>加上dp数组记忆化就能通过了，毕竟视频长度最大才100，<code>dp[i]</code>的定义为拼接出从 i 开始的后续完整视频所需要的最少视频片段。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX = <span class="number">0x6f6f6f6f</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; clips;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dp[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算从 j 开始拼成完整视频所需要的片段</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rep</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= T)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dp[j] != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k &gt;= clips.<span class="built_in">size</span>()){</span><br><span class="line">            <span class="keyword">return</span> MAX;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(clips[k][<span class="number">0</span>] &lt;= j)</span><br><span class="line">            <span class="keyword">return</span> dp[j] = <span class="built_in">min</span>(<span class="built_in">rep</span>(clips[k][<span class="number">0</span>], <span class="built_in">max</span>(clips[k][<span class="number">1</span>],j), k+<span class="number">1</span>)+<span class="number">1</span>, <span class="built_in">rep</span>(i,j,k+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> MAX;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">videoStitching</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; clips, <span class="type">int</span> T)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;clips = clips;</span><br><span class="line">        <span class="keyword">this</span>-&gt;T = T;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;clips.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;clips.<span class="built_in">end</span>(), <span class="keyword">this</span>-&gt;cmp);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">rep</span>(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans &gt;= MAX ? <span class="number">-1</span> : ans;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] != b[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt;= b[<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数指针</title>
      <link href="/2020/10/23/han-shu-zhi-zhen/"/>
      <url>/2020/10/23/han-shu-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>我们在程序中定义了一个函数，那么在编译时编译器就会为这一段函数代码分配一段存储空间，位于代码段之中。</p><p>这段存储空间的首地址就称为这个函数的地址，函数名就能直接表示这个地址。</p><p>而我们知道，指针也是能存储地址的，那么这个函数地址也能通过定义一个指针变量来存放，这个指针变量就叫做函数指针变量，简称函数指针。</p><h2 id="函数指针的定义"><a href="#函数指针的定义" class="headerlink" title="函数指针的定义"></a>函数指针的定义</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*p)(<span class="type">int</span>,<span class="type">int</span>);</span><br></pre></td></tr></tbody></table></figure><p>函数指针的定义与函数声明类似，只是函数名被替换为<code>(*函数指针名)</code>。</p><p>p的类型为<code>int(*)(int,int)</code></p><p>其中括号是不能省略的，因为括号会改变<code>*</code>的运算优先级。如果没有括号，那么就是声明了一个返回值类型为指针型的函数。</p><p><strong>需要注意的是，</strong>指向函数的指针变量没有<code>++</code>和<code>--</code>运算。</p><h2 id="函数指针的使用"><a href="#函数指针的使用" class="headerlink" title="函数指针的使用"></a>函数指针的使用</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">int</span> (*p)(<span class="type">int</span> a, <span class="type">int</span> b);    <span class="comment">//1.定义函数指针</span></span><br><span class="line"></span><br><span class="line">    p = Min;                   <span class="comment">//2.将函数地址赋值给函数指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入两个数:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> c = (*p)(a,b);         <span class="comment">//3.函数指针调用函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"min(%d, %d) = %d"</span>,a,b,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> a&lt;b ? a : b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>做菜顺序</title>
      <link href="/2020/10/19/zuo-cai-shun-xu/"/>
      <url>/2020/10/19/zuo-cai-shun-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（LeetCode-1402-做菜顺序）"><a href="#题目（LeetCode-1402-做菜顺序）" class="headerlink" title="题目（LeetCode 1402. 做菜顺序）"></a>题目（<a href="https://leetcode-cn.com/problems/reducing-dishes/">LeetCode 1402. 做菜顺序</a>）</h2><p>一个厨师收集了他&nbsp;n&nbsp;道菜的满意程度&nbsp;satisfaction&nbsp;，这个厨师做出每道菜的时间都是 1 单位时间。</p><p>一道菜的 「喜爱时间」系数定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是&nbsp;time[i]*satisfaction[i]&nbsp;。</p><p>请你返回做完所有菜 「喜爱时间」总和的最大值为多少。</p><p>你可以按&nbsp;<strong>任意</strong>&nbsp;顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：satisfaction = [-1,-8,0,5,-9]<br>输出：14<br>解释：去掉第二道和最后一道菜，最大的喜爱时间系数和为 (-1*1 + 0*2 + 5*3 = 14) 。每道菜都需要花费 1 单位时间完成。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：satisfaction = [4,3,2]<br>输出：20<br>解释：按照原来顺序相反的时间做菜 (2*1 + 3*2 + 4*3 = 20)</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：satisfaction = [-1,-4,-5]<br>输出：0<br>解释：大家都不喜欢这些菜，所以不做任何菜可以获得最大的喜爱时间系数。</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>输入：satisfaction = [-2,5,-1,0,3,-3]<br>输出：35<br>&nbsp;<br><strong>提示：</strong></p></blockquote><ul><li>n == satisfaction.length</li><li>1 &lt;= n &lt;= 500</li><li>-10^3 &lt;=&nbsp;satisfaction[i] &lt;= 10^3</li></ul><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>先对satisfaction数组按从小到大排序，之后就可以按照 01 背包问题进行求解。</p><p>按题意进行记忆化搜索就可以了，也可以进一步地把dp方程推导出来然后迭代求解。</p><p>对于排序后的satisfaction数组的每一个下标 i，我们都可以选择做或者不做这道菜。</p><ul><li>如果不做，那么所花费的总时间time以及喜爱时间都不会增加；</li><li>如果做，那么time需要加一，并且喜爱时间需要加上 time 乘以下标i指向的满意度。</li></ul><p>然后递归的时候取两者最大值，</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; satisfaction;</span><br><span class="line">    <span class="comment">//map&lt;pair&lt;int,int&gt;, int&gt; dp;  用map最后一个用例会超时</span></span><br><span class="line">    <span class="type">int</span> dp[<span class="number">600</span>][<span class="number">600</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rep</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> time)</span></span>{</span><br><span class="line">        <span class="type">int</span> n = satisfaction.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= n){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dp[i][time]){</span><br><span class="line">            <span class="keyword">return</span> dp[i][time];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[i][time] = <span class="built_in">max</span>(<span class="built_in">rep</span>(i+<span class="number">1</span>, time), <span class="built_in">rep</span>(i+<span class="number">1</span>, time+<span class="number">1</span>)+time*satisfaction[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSatisfaction</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; satisfaction)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>-&gt;satisfaction = satisfaction;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="keyword">this</span>-&gt;satisfaction.<span class="built_in">begin</span>(), <span class="keyword">this</span>-&gt;satisfaction.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rep</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><p>由上述记忆化搜索得来。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSatisfaction</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; satisfaction)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(satisfaction.<span class="built_in">begin</span>(),satisfaction.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=satisfaction.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> time = satisfaction.<span class="built_in">size</span>();time &gt;= <span class="number">1</span>;time--)</span><br><span class="line">                dp[i][time] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][time], dp[i+<span class="number">1</span>][time+<span class="number">1</span>]+time*satisfaction[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>这道题可以贪心…</p><p>排序后寻找这样一个最大区间，负数的前缀和小于等于正数的后缀和。那么对这个区间求喜爱时间就能获得最大值。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSatisfaction</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; satisfaction)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(satisfaction.<span class="built_in">begin</span>(), satisfaction.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(satisfaction.<span class="built_in">back</span>() &lt;= <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = satisfaction.<span class="built_in">size</span>(), back = <span class="number">0</span>, front = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(satisfaction[i]&gt;<span class="number">0</span>)</span><br><span class="line">                back+=satisfaction[i];</span><br><span class="line">            <span class="keyword">if</span>(satisfaction[i]&lt;<span class="number">0</span>)</span><br><span class="line">                front+=satisfaction[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, cnt = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; -front &gt;= back){</span><br><span class="line">            front -= satisfaction[i];</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span>(;i &lt; n;i++)</span><br><span class="line">            ans += (cnt++)*satisfaction[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N皇后</title>
      <link href="/2020/10/18/n-huang-hou/"/>
      <url>/2020/10/18/n-huang-hou/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（LeetCode-51-）"><a href="#题目（LeetCode-51-）" class="headerlink" title="题目（LeetCode 51.）"></a>题目（<a href="https://leetcode-cn.com/problems/n-queens/">LeetCode 51.</a>）</h2><p>n&nbsp;皇后问题研究的是如何将 n&nbsp;个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>给定一个整数 n，返回所有不同的&nbsp;n&nbsp;皇后问题的解决方案。</p><p>每一种解法包含一个明确的&nbsp;n 皇后问题的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。&nbsp;</p><p><strong>示例：</strong></p><blockquote><p><strong>输入：</strong>4<br><strong>输出：</strong>[<br> [“.Q..”,  // 解法 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p><p> [“..Q.”,  // 解法 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]<br><strong>解释:</strong> 4 皇后问题存在两个不同的解法。</p></blockquote><p><strong>提示：</strong></p><ul><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>由于皇后可以横向攻击，所以每一行肯定只能放一个皇后，因此每次从一行中选出一个空位置放皇后，将所有该皇后可能攻击到的位置标记上，递归回溯求解。</p><p>需要注意的是回溯时要还原此行皇后未标记前的矩阵。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">const</span> <span class="type">int</span> &amp;n, <span class="type">int</span> &amp;ans)</span></span>{</span><br><span class="line">        <span class="comment">// 保存原来的矩阵</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; tmp = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ans.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i,j));    </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 横向标记其他皇后不可能的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;n;y++){</span><br><span class="line">            m[i][y] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 纵向标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;n;x++){</span><br><span class="line">            m[x][j] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 倒V标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x+i&lt;n;x++){</span><br><span class="line">            <span class="keyword">if</span>(j+x&lt;n)</span><br><span class="line">                m[i+x][j+x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j-x&gt;=<span class="number">0</span>)</span><br><span class="line">                m[i+x][j-x] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 上V标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;i-x&gt;=<span class="number">0</span>;x++){</span><br><span class="line">            <span class="keyword">if</span>(j+x&lt;n)</span><br><span class="line">                m[i-x][j+x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j-x&gt;=<span class="number">0</span>)</span><br><span class="line">                m[i-x][j-x] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 遍历下一行所有皇后可能的位置，递归求解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;n;y++){</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt; n){</span><br><span class="line">                <span class="keyword">if</span>(m[i+<span class="number">1</span>][y] == <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">solve</span>(i+<span class="number">1</span>, y, n, ans);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        m = tmp;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;ans.<span class="built_in">size</span>() == n){</span><br><span class="line">            <span class="function">string <span class="title">raw</span><span class="params">(n, <span class="string">'.'</span>)</span></span>;</span><br><span class="line">            <span class="function">vector&lt;string&gt; <span class="title">one_ans</span><span class="params">(n,raw)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it : <span class="keyword">this</span>-&gt;ans){</span><br><span class="line">                one_ans[it.first][it.second] = <span class="string">'Q'</span>;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;"("&lt;&lt;it.first&lt;&lt;","&lt;&lt;it.second&lt;&lt;") ";</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(one_ans);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>-&gt;ans.<span class="built_in">pop_back</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) {</span><br><span class="line">        m.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            m.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//对第一行的所有位置依次求解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">            <span class="built_in">solve</span>(<span class="number">0</span>, j, n, ans);</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL2 Ubuntu20.04安装Gnome桌面</title>
      <link href="/2020/10/12/wsl2-ubuntu20-04-an-zhuang-gnome-zhuo-mian/"/>
      <url>/2020/10/12/wsl2-ubuntu20-04-an-zhuang-gnome-zhuo-mian/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考了这篇博客进行安装，<a href="https://www.chengxuzhilu.com/2395.html#an_zhuang_Gnome_zhuo_mian_de_bi_yao_yuan_su">WSL2 下让 Ubuntu20.04 安装 Gnome 桌面</a>。</p><p>但是在安装的过程中遇到了博客中所没有记录的错误，因此记录一下。</p><h2 id="VcXsrv一直黑屏"><a href="#VcXsrv一直黑屏" class="headerlink" title="VcXsrv一直黑屏"></a>VcXsrv一直黑屏</h2><p><strong>解决方法</strong>：</p><ol><li>检查Windows防火墙，Windows安全中心-&gt;防火墙和网络保护-&gt;允许应用通过防火墙，然后将VcXsrv勾选上。</li><li>如果使用的是XDMCP方式，检查XDMCP的 IP 地址有没有配错，使用如下命令可以查看WSL的IP地址。<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname -I | awk <span class="string">'{print $1}'</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="sudo-apt-get-update失败"><a href="#sudo-apt-get-update失败" class="headerlink" title="sudo apt-get update失败"></a>sudo apt-get update失败</h2><p><strong>问题</strong>：<br>Temporary failure in name resolution，然后更新失败</p><p><strong>解决方法</strong>：<br>域名解析失败，可以试试换一个网络，或者重启电脑。</p><h2 id="无法安装Systemd-Genie"><a href="#无法安装Systemd-Genie" class="headerlink" title="无法安装Systemd-Genie"></a>无法安装Systemd-Genie</h2><p><strong>问题：</strong></p><ul><li>执行<code>sudo apt-get install -y systemd-genie</code>之后显示找不到这个包</li><li>然后执行<code>sudo apt-get update</code>，发现更新的源里多了一个<code>packagecloud.io</code>的网址，但是报错<code>Too many Request</code></li></ul><p><strong>解决方法</strong>：<br>估计是这个国外网站对中国IP有限制，直接从Github把压缩包下载下来，解压后，把里面的文件放到相应的目录。</p><ul><li><p>下载<a href="https://github.com/arkane-systems/genie/files/5251229/genie.tar.gz">genie.tar.gz</a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/arkane-systems/genie/files/5251229/genie.tar.gz</span><br></pre></td></tr></tbody></table></figure></li><li><p>解压</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf genie.tar.gz</span><br><span class="line"><span class="built_in">cd</span> systemd-genie</span><br></pre></td></tr></tbody></table></figure></li><li><p>将文件复制到对应目录</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r usr/bin/* /usr/bin/</span><br><span class="line"><span class="built_in">cp</span> -r lib/* /lib/</span><br></pre></td></tr></tbody></table></figure></li><li><p>这个时候就安装好了。</p></li></ul><h2 id="root用户下genie-s报错"><a href="#root用户下genie-s报错" class="headerlink" title="root用户下genie -s报错"></a>root用户下genie -s报错</h2><p><strong>问题</strong>：<br>报错: 找不到这个文件或目录 <code>/usr/sbin/daemonize</code></p><p><strong>解决方法</strong>：<br>新建一个软链接，将<code>/usr/bin/daemonize</code>链接过去。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /usr/bin/daemonize /usr/sbin/daemonize</span><br></pre></td></tr></tbody></table></figure><h2 id="启动Gnome桌面"><a href="#启动Gnome桌面" class="headerlink" title="启动Gnome桌面"></a>启动Gnome桌面</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hostname -I | awk <span class="string">'{print $1}'</span></span><br><span class="line">genie -s</span><br></pre></td></tr></tbody></table></figure><p>然后打开 XLaunch 根据 IP 地址进行配置，可以将上述命令保存到脚本里方便使用。</p><h2 id="退出Gnome桌面"><a href="#退出Gnome桌面" class="headerlink" title="退出Gnome桌面"></a>退出Gnome桌面</h2><p>需要在图形界面中点击关机。</p><h2 id="重启WSL"><a href="#重启WSL" class="headerlink" title="重启WSL"></a>重启WSL</h2><p>以管理员身份打开Windows PowerShell，然后执行</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop lxxsManager</span><br><span class="line">net start lxxsManager</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安装/配置经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android LitePal使用</title>
      <link href="/2020/10/09/android-litepal-shi-yong/"/>
      <url>/2020/10/09/android-litepal-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="配置app-build-gradle文件"><a href="#配置app-build-gradle文件" class="headerlink" title="配置app/build.gradle文件"></a>配置app/build.gradle文件</h2><p>加入LitePal的依赖：</p><figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> {</span><br><span class="line">    implementation <span class="string">'org.litepal.android:core:1.3.2</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><h2 id="配置litepal-xml文件"><a href="#配置litepal-xml文件" class="headerlink" title="配置litepal.xml文件"></a>配置litepal.xml文件</h2><p>在<code>app/src/main</code>目录下新建目录<code>assets</code>，然后新建xml文件<code>litepal.xml</code>。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">litepal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dbname</span> <span class="attr">value</span>=<span class="string">"SmsStore"</span>&gt;</span><span class="tag">&lt;/<span class="name">dbname</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">litepal</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="配置LitePalApplication"><a href="#配置LitePalApplication" class="headerlink" title="配置LitePalApplication"></a>配置LitePalApplication</h2><p>修改<code>AndroidManifest.xml</code>文件</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">      <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"org.litepal.LitePalApplication"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">......</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line">        ......</span><br><span class="line">      <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure><h2 id="添加类"><a href="#添加类" class="headerlink" title="添加类"></a>添加类</h2><ul><li>根据需要新建一个类，继承自<code>org.litepal.crud.DataSupport</code>，并实现相关数据的<code>get</code>方法和<code>set</code>方法</li><li>然后修改<code>litepal.xml</code>文件。使用的是<code>&lt;mapping&gt;</code>标签来声明我们要配置的映射模型类，注意一定要使用完整的类名。</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">litepal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dbname</span> <span class="attr">value</span>=<span class="string">"SmsStore"</span>&gt;</span><span class="tag">&lt;/<span class="name">dbname</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">"com.litnwu.messageblocker.Model.SmsItem"</span>&gt;</span><span class="tag">&lt;/<span class="name">mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">litepal</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="使用LitePal操作数据"><a href="#使用LitePal操作数据" class="headerlink" title="使用LitePal操作数据"></a>使用LitePal操作数据</h2><ul><li>插入或更新数据：<code>实例对象.save();</code></li><li>删除数据：<code>实例对象.delete();</code></li><li>查询所有数据：<code>DataSupport.findAll(映射模型类.class);</code></li><li>通过连缀添加条件查询：例如<code>DataSupport.order("date desc").find(映射模型类.class);</code></li></ul><h2 id="修改表结构或增添表"><a href="#修改表结构或增添表" class="headerlink" title="修改表结构或增添表"></a>修改表结构或增添表</h2><p>修改相关的类之后，将xml文件中的version标签的版本号加一即可。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟内存</title>
      <link href="/2020/10/07/xu-ni-nei-cun/"/>
      <url>/2020/10/07/xu-ni-nei-cun/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h2><p>虚拟内存是对主存的一个抽象概念，是硬件异常、硬件地址翻译、主存、磁盘文件、和内核软件的完美交互，为每个进程提供一个大的、一致的、私有的地址空间。</p><p>对一个进程而言，它好像都可以访问整个系统的所有物理内存。更重要的是，即使单独一个进程，它拥有的地址空间也可以远远大于系统物理内存。</p><h2 id="物理和虚拟寻址"><a href="#物理和虚拟寻址" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h2><ul><li><strong>物理寻址</strong>：计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址。CPU访问内存的最自然的方式就是使用物理地址。</li></ul><p><em>当CPU执行加载指令时，会生成一个有效物理地址，通过内存总线传递给主存。主存取出从该物理地址开始的4字节字，并将它返回给CPU，CPU会将它存放在一个寄存器中。</em></p><ul><li><strong>虚拟寻址</strong>：CPU通过生成一个虚拟地址来访问主存，这个虚拟地址被送到内存之前先转换成适当的物理地址。这个地址转换过程称为地址翻译，需要CPU硬件和操作系统之间的紧密合作。CPU芯片上的内存管理单元（MMU）利用存放在主存上的查询表（该表由操作系统管理）来动态翻译虚拟地址。</li></ul><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>非负整数地址的有序集合，由进程可寻址的虚拟内存空间组成。</p><ul><li>32位虚拟地址空间：2^32个地址</li><li>64位虚拟地址空间：2^64个地址</li><li>物理地址空间：对应于系统物理内存的M个字节</li></ul><p>地址空间清楚地区分了数据对象（字节）和它们的属性（地址）。虚拟内存的<strong>基本思想</strong>是允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。</p><p>比如4021f000，这个值表示的是进程32位地址空间中的一个特定字节。尽管一个进程可以寻址4GB的虚拟内存（在32位地址空间中），但这并不代表它就有权访问所有虚拟地址。</p><h2 id="Linux虚拟内存区域"><a href="#Linux虚拟内存区域" class="headerlink" title="Linux虚拟内存区域"></a>Linux虚拟内存区域</h2><p>Linux 将虚拟内存组织成一些区域（也叫做段）的集合。 一个区域（area）就是已经存在 着的（已分配的）虚拟内存的连续片（chunk），这些页是以某种方式相关联的。</p><img src="https://tvax1.sinaimg.cn/large/005JD0Ejgy1gkhof3s2cqj30ih0mcaq4.jpg" alt="一个Linux进程的虚拟内存" width="50%" data-width="665" data-height="804"><h2 id="进程虚拟内存区域"><a href="#进程虚拟内存区域" class="headerlink" title="进程虚拟内存区域"></a><a href="/2020/03/19/dui-zhan-he-jing-tai-cun-chu-qu/">进程虚拟内存区域</a></h2><h2 id="内核虚拟内存"><a href="#内核虚拟内存" class="headerlink" title="内核虚拟内存"></a>内核虚拟内存</h2><p>这部分虚拟内存位于用户栈之上。</p><p>内核虚拟内存包括内核中的代码和数据结构。内核虚拟内存的某些区域被映射到所有进程共享的物理页面。</p><p>例如，每个进程共享内核的代码和全局数据结构。</p><p>有趣的是，Linux也将一组连续的虚拟页面映射到相应的一组连续的物理页面。这就为内核提供了一种便利的方法来访问物理内存中任何特定的位置，例如，当它需要访问页表，或在一些设备上执行内存映射的IO操作，而这些设备被映射到特定的物理内存位置时。</p><p>内核虚拟内存的其他区域包含每个进程都不同的数据。比如说，页表、内核在进程的上下文中执行代码时使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。</p><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>定义：Linux通过将一个虚拟内存区域（共享库的内存映射区域）与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容。</p><p>虚拟内存区域可以映射到两种类型的对象中的一种：</p><ol><li>Linux文件系统中的普通文件</li><li>匿名文件</li></ol><p>无论哪种情况，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件之间换来换去。交换文件也叫做交换空间或者交换区域。需要意识到，在任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数。</p><p><a href="/2020/11/26/yong-mmap-jiang-wen-jian-fu-zhi-dao-biao-zhun-shu-chu/#mmap%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6">mmap的使用</a></p><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆(Heap)。</p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><h2 id="虚拟内存的三个重要能力"><a href="#虚拟内存的三个重要能力" class="headerlink" title="虚拟内存的三个重要能力"></a>虚拟内存的三个重要能力</h2><ol><li>将主存看成一个存储在磁盘上的地址空间的高速缓存，在主存上只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式高效使用主存。</li><li>为每一个进程提供了一致的地址空间，简化内存管理。</li><li>保护每个进程的地址空间不被其他进程破坏。</li></ol><h2 id="虚拟内存作为缓存的工具"><a href="#虚拟内存作为缓存的工具" class="headerlink" title="虚拟内存作为缓存的工具"></a>虚拟内存作为缓存的工具</h2><p>虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存到主存中。</p><p>和存储器层次结构其他缓存一样，磁盘（较低层）上的数据被分割成块，这些块作为磁盘和主存（较高层）之间的传输单元。而虚拟内存被分割成称为虚拟页的大小固定的块。类似地，物理内存被分割为物理页，大小与虚拟页一样，被称为页帧。</p><ul><li>未分配的页：不占用磁盘空间。</li><li>未缓存的页：未缓存在物理内存中的已分配页。</li><li>缓存的页：已经缓存在物理内存中的已分配页。</li></ul><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>一个存放在物理内存中的数据结构，即一个页表条目的数组，页表将虚拟页映射到物理页。</p><p>实际上，操作系统为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。注意，多个虚拟页面可以映射到同一物理页面上。</p><img src="https://tva1.sinaimg.cn/large/005JD0Ejgy1gjht6i472uj30jo0dgn43.jpg" alt="" width="60%" data-width="708" data-height="484"><h4 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h4><h4 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h4><p>假如 MMU 在试图翻译某个虚拟地址 A，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序开始执行下列步骤：</p><ol><li>检查虚拟地址A是否合法。</li><li>检查进程是否有读、写或者执行这个区域内页面的权限。</li><li>如果这个缺页是由于对合法的虚拟地址进行合法的操作造成的，则：选择一个牺牲页面，如果这个牺牲页面被修改过，那么将它交换出去，换入新的页面并更新页表。当缺页处理程序返回时，CPU重新启动引起缺页的指令，这条指令将再次发送 A 到 MMU。这次MMU就能正常翻译 A，而不会再产生缺页中断。</li></ol><h3 id="局部性原则"><a href="#局部性原则" class="headerlink" title="局部性原则"></a>局部性原则</h3><p>尽管整个运行时刻中程序引用的不同页面的总数可能超过物理内存总的大小，但是局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面集合上工作，这个集合叫做工作集合或者常驻集合。在初始开销，也就是将工作集合页面调入到内存之后，接下来对这个工作集的引用将导致命中，而不会产生额外的磁盘流量。</p><p>如果工作集的大小超过了物理内存的大小，那么程序将产生一种不幸的状态，叫做<strong>抖动</strong>，这时页面将不断地换进换出。</p><h2 id="虚拟内存作为内存管理的工具"><a href="#虚拟内存作为内存管理的工具" class="headerlink" title="虚拟内存作为内存管理的工具"></a>虚拟内存作为内存管理的工具</h2><p>虚拟地址这个有用的机制大大简化了内存管理，并提供一种自然的保护内存的方法。</p><h3 id="简化链接"><a href="#简化链接" class="headerlink" title="简化链接"></a>简化链接</h3><p>独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。</p><p>一个给定的Linux系统上的每个进程都使用类似的内存格式。数据段跟在代码段之后，中间有一段符合要求的对齐空白。栈占据用户进程地址空间最高的部分，并向下生长。这样的一致性大大简化了链接器的设计与实现，允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。</p><h3 id="简化加载"><a href="#简化加载" class="headerlink" title="简化加载"></a>简化加载</h3><p>虚拟内存使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中 .text 和 .data 节加载到一个新创建的进程中， Linux 加载器为代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。</p><blockquote><p>加载器从不从磁盘到内存实际复制任何数据。在每个页初次被引用时，要么是CPU取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调入数据页。</p></blockquote><p>将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称作<strong>内存映射</strong>（memory mapping）。Linux 提供一个称为<code>mmap</code>的系统调用，允许应用程序自己做内存映射。</p><h3 id="简化共享"><a href="#简化共享" class="headerlink" title="简化共享"></a>简化共享</h3><p>独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。</p><p>一般而言，每个进程都有自己私有的代码、数据、堆、栈区域，是不和其他进程共享的。在这种情况下，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面。</p><p>然而在一些情况中，还是需要进程来共享代码和数据。例如，每个进程必须调用相同的操作系统内核代码，而每个C程序都会调用C标准库中的程序，比如printf。</p><p>操作系统通过将不同进程中适当虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本，而不是在每个进程中都包括单独的内核和C标准库的副本。</p><h3 id="简化内存分配"><a href="#简化内存分配" class="headerlink" title="简化内存分配"></a>简化内存分配</h3><p>虚拟内存为向用户进程提供一个简单的分配额外内存的机制。</p><p>当一个运行在用户进程中的程序要求额外的堆空间时（如调用 malloc 的结果），操作系统分配一个适当数字（例如 U个连续的虚拟内存页面，并且将它们映射到物理内存中任意位置的走个任意的物理页面。由于页表工作的方式，操作系统没有必要分配 走个连续的物理内存页面。页面可以随机地分散在物理内存中。</p><blockquote><h5 id="系统剩余2g内存，malloc函数4g能成功吗？"><a href="#系统剩余2g内存，malloc函数4g能成功吗？" class="headerlink" title="系统剩余2g内存，malloc函数4g能成功吗？"></a>系统剩余2g内存，malloc函数4g能成功吗？</h5><p>一个程序申请的内存能超过物理内存大小限制。分配的是虚拟地址（不是物理内存，即使物理内存才0.5G），只有真正使用的话，才会建立页表开始关联物理内存，具体来说与物理内存和交换空间大小有关。</p><p>考虑32位linux情况的话，依据版本的话</p><ul><li>如果是2.4版本之前的话，因为映射区是在1G地址位置，而且映射区与栈相对生长，malloc申请的空间大于128KB的话，调用的是mmap函数，因此分配的地址起始在1G位置，末端为3G，最大2G左右，所以一次最大申请为2G左右，如果小块小块累计申请的话算上堆区128M到1G区间的话，小块申请 malloc调用brk总和就0.9G，累计能申请到的为2.9G。</li><li>2.6到当前版本的话，因为映射区是在顶端靠近栈区，但是生长方向向下，与堆向上相对，一次malloc申请大空间，malloc调用mmap()能最大申请到2.9G左右，算上堆区128M开始向上小块累计的话，（因为2.9G被mmap了）累计就剩下零头，累计申请最大也是2.9G。</li><li>现在分配的才是虚拟地址（不是物理内存，即使物理内存才0.5G），只有真正使用的话，才会建立页表开始关联物理内存。</li></ul></blockquote><h2 id="虚拟内存作为内存保护的工具"><a href="#虚拟内存作为内存保护的工具" class="headerlink" title="虚拟内存作为内存保护的工具"></a>虚拟内存作为内存保护的工具</h2><p>任何现代计算机系统必须提供手段来控制对内存系统的访问。</p><p>不应该允许一个用户进程修改它的只读代码段，而且也不应该允许它读或者修改任何内核中的代码和数据结构，不允许它读或者修改其他进程的私有内存，并且不允许修改任何与其他进程共享的虚拟页面，除非所有的共享者都显示地允许它这么做（通过调用明确的进程间通信系统调用）。</p><p>因为每次CPU生成一个地址时，地址翻译硬件便会读一个页表条目。因此在条目上添加许可位即可实现更好的访问控制。</p><p>如果一条指令违反了这些许可条件，那么CPU就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Linux Shell一般将这种异常报告为“段错误”。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并二叉树</title>
      <link href="/2020/09/23/he-bing-er-cha-shu/"/>
      <url>/2020/09/23/he-bing-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（LeetCode-617-）"><a href="#题目（LeetCode-617-）" class="headerlink" title="题目（LeetCode 617.）"></a>题目（<a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">LeetCode 617.</a>）</h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 <strong>NULL</strong> 的节点将直接作为新二叉树的节点。</p><p><strong>示例 1:</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出:</span><br><span class="line">合并后的树:</span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \   \ </span><br><span class="line"> 5   4   7</span><br></pre></td></tr></tbody></table></figure><p><strong>注意:</strong> 合并必须从两个树的根节点开始。</p><h2 id="新树合并"><a href="#新树合并" class="headerlink" title="新树合并"></a>新树合并</h2><p>很明显，这两个二叉树的结点位置是一一对应的，所以合并时从两棵树的根节点出发同步遍历。这里需要用到的递归来构建合并后的新树，比如当前遍历到某个结点，假设树 1 和树 2 的当前结点都不为空，那么就需要 new 一个结点，然后将递归调用求解左孩子的结果复制给结点的左孩子，递归调用求解右孩子的结果赋值给结点的右孩子，这样就能一步一步地建树。</p><p>其次，如果树 1 和树 2 的当前结点都为空，那么直接返回空指针就好。而如果只有一棵树的结点为空，那么直接返回另一棵树的结点即可。</p><p>不过，这样构建出来的树，有些结点是指向原来两棵树的部分结点的，如果原来的树被修改，那么就会受到影响，但这不并是题目所要求的，如果要避免这这种情况的话，就需要当只要一棵树的结点为空时，不直接返回另一棵树的结点，而是也像两棵树结点都不为空那样 new 一个新结点。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构建新树的方式</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">nullptr</span> &amp;&amp; t2 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">nullptr</span>){</span><br><span class="line">            <span class="comment">// 依次复制结点</span></span><br><span class="line">            <span class="comment">// TreeNode *node = new TreeNode(t2-&gt;val);</span></span><br><span class="line">            <span class="comment">// node-&gt;left = dfs(nullptr, t2-&gt;left);</span></span><br><span class="line">            <span class="comment">// node-&gt;right = dfs(nullptr, t2-&gt;right);</span></span><br><span class="line">            <span class="comment">// return node;</span></span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t2 == <span class="literal">nullptr</span>){</span><br><span class="line">            <span class="comment">// TreeNode *node = new TreeNode(t1-&gt;val);</span></span><br><span class="line">            <span class="comment">// node-&gt;left = dfs(nullptr, t1-&gt;left);</span></span><br><span class="line">            <span class="comment">// node-&gt;right = dfs(nullptr, t1-&gt;right);</span></span><br><span class="line">            <span class="comment">// return node;</span></span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        } </span><br><span class="line"></span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(t1-&gt;val + t2-&gt;val);        </span><br><span class="line">        root-&gt;left = <span class="built_in">dfs</span>(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        root-&gt;right = <span class="built_in">dfs</span>(t1-&gt;right, t2-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(t1,t2);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="原地合并"><a href="#原地合并" class="headerlink" title="原地合并"></a>原地合并</h2><p>如果要优化空间复杂度的话，那么就原地合并，将树 2 合并到树 1 中并返回。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//原地合并到 t1 的方式</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(TreeNode* t1, TreeNode* t2)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(t2 != <span class="literal">nullptr</span>){</span><br><span class="line">            t1-&gt;val += t2-&gt;val;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;left == <span class="literal">nullptr</span>){</span><br><span class="line">            t1-&gt;left = t2-&gt;left;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="built_in">merge</span>(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t1-&gt;right == <span class="literal">nullptr</span>){</span><br><span class="line">            t1-&gt;right = t2-&gt;right;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="built_in">merge</span>(t1-&gt;right, t2-&gt;right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="built_in">swap</span>(t1, t2);</span><br><span class="line">        </span><br><span class="line">        TreeNode *head = t1;</span><br><span class="line">        <span class="built_in">merge</span>(t1, t2);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找两个正序数组的中位数</title>
      <link href="/2020/09/20/xun-zhao-liang-ge-zheng-xu-shu-zu-de-zhong-wei-shu/"/>
      <url>/2020/09/20/xun-zhao-liang-ge-zheng-xu-shu-zu-de-zhong-wei-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（LeetCode-4-）"><a href="#题目（LeetCode-4-）" class="headerlink" title="题目（LeetCode 4.）"></a>题目（<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">LeetCode 4.</a>）</h2><p>给定两个大小为 m 和 n 的正序（从小到大）数组<code>nums1</code> 和<code>nums2</code>。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设<code>nums1</code>和<code>nums2</code>不会同时为空。</p><p><strong>示例 1:</strong></p><blockquote><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>则中位数是 2.0</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>则中位数是 （2 + 3）/2 = 2.5</p></blockquote><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><strong>暴力解法</strong></p><ul><li>最直观的思路是将这个两个有序数组进行合并，类似于归并排序里的合并操作。</li><li>另一个思路是使用双指针，每次将较小的那个指针往后移动一位，直到第<code>(len1+len2)/2</code>个元素（当然需要按数组总长度的奇偶数来谈论），这样只需要<code>O(1)</code>的空间复杂度。</li></ul><p>但是这两种思路都是<code>O(m+n)</code>的时间复杂度，不足以满足题目要求。</p><p><strong>进一步优化，二分思路</strong><br>二分查找在第二种思路上更进一步，我们不需要一个一个地往后移指针。因为我们知道两个数组的长度，所以求中位数的问题可以转换为求在合并后的有序数组中的第 k 个元素的问题（不过并不需要真的合并）。</p><ul><li>对第 k 个元素进行二分，每次找这两个有序数组中<strong>第 k/2 个元素</strong>进行比较。</li><li>较小元素的那个数组前 k/2 个元素肯定不是我们要求的第 k 个元素，因此可以<strong>抛弃这 k/2 个元素</strong>。</li><li>抛弃元素后数组又是一个规模更小的有序数组，并且要寻找的第 k 个元素也更靠前了。返回第一步继续求解，直到问题的规模可以直接求解，也就是下面说的特殊情况。</li></ul><p>但是有可能出现数组长度小于 k/2，此时应取数组长度作为抛弃长度，因此改进一下：</p><ul><li>使用<code>index1</code>和<code>index2</code>来表示分别表示数组的起始下标，下标小于<code>index</code>的元素均视为被抛弃的。</li></ul><ol><li><code>newIndex</code> 为 <code>index+k/2-1</code> 与 <code>len-1</code> 的最小值</li><li>当<code>A[newIndex1] &lt;= B[newIndex2]</code>时，<code>index1 = newIndex1+1</code>，<code>k -= newIndex1-index1+1</code></li><li>否则相反</li><li>重复 1 和 2 直到遇到特殊情况。</li></ol><p>特殊情况（直接求解）：</p><ul><li>k=1，说明取第一个元素，那么在两个数组首部取最小值即可。</li><li>index == len，说明数组为空，在另一个数组取第 k 个元素即可。</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>{</span><br><span class="line">        <span class="type">int</span> len1 = nums1.<span class="built_in">size</span>(), len2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> k = (len1 + len2) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((len1+len2)%<span class="number">2</span> != <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span> + <span class="built_in">getKthElement</span>(nums1, nums2, k+<span class="number">1</span>);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKthElement</span>(nums1, nums2, k) + <span class="built_in">getKthElement</span>(nums1, nums2, k+<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;num1, vector&lt;<span class="type">int</span>&gt; &amp;num2, <span class="type">int</span> k)</span></span>{</span><br><span class="line">        <span class="type">int</span> len1 = num1.<span class="built_in">size</span>(), len2 = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            <span class="comment">//特殊情况</span></span><br><span class="line">            <span class="keyword">if</span>(index1 == len1){   <span class="comment">//num1数组为空，那么直接在num2数组求即可</span></span><br><span class="line">                <span class="keyword">return</span> num2[index2+k<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(index2 == len2){   <span class="comment">//num2数组为空，那么直接在num1数组求即可</span></span><br><span class="line">                <span class="keyword">return</span> num1[index1+k<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">1</span>){           <span class="comment">//k=1时，直接返回两个数组第一个元素的较小者即可</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(num1[index1], num2[index2]);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//正常情况，需要注意有时候数组长度小于 k/2，此时应取数组长度作为抛弃长度</span></span><br><span class="line">            <span class="type">int</span> newIndex1 = index1 + <span class="built_in">min</span>(k/<span class="number">2</span><span class="number">-1</span>, len1<span class="number">-1</span>-index1);</span><br><span class="line">            <span class="type">int</span> newIndex2 = index2 + <span class="built_in">min</span>(k/<span class="number">2</span><span class="number">-1</span>, len2<span class="number">-1</span>-index2);</span><br><span class="line">            <span class="keyword">if</span>(num1[newIndex1] &lt;= num2[newIndex2]){</span><br><span class="line">                k -= newIndex1-index1+<span class="number">1</span>;</span><br><span class="line">                index1  = newIndex1+<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                k -= newIndex2-index2+<span class="number">1</span>;</span><br><span class="line">                index2  = newIndex2+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(log(m+n))，其中 m 和 n 分别是数组 nums1 和 nums2 的长度。初始时有 k=(m+n)/2 或 k=(m+n)/2+1，每一轮循环可以将查找范围减少一半，因此时间复杂度是 O(log(m+n))。</li><li>空间复杂度：O(1)。</li></ul><h2 id="划分数组（更低复杂度的解法）"><a href="#划分数组（更低复杂度的解法）" class="headerlink" title="划分数组（更低复杂度的解法）"></a>划分数组（更低复杂度的解法）</h2><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">官方题解</a>讲得十分细致。</p><p>需要注意二分时 i 的取值，以及数组越界这种特殊情况的讨论。</p><ul><li><code>left = 0</code>，<code> right = len1</code>，<code>i = (left+right)/2</code>;</li><li>对于 i=0、i=m、j=0、j=n 这样的临界条件，我们只需要规定<code> A[−1]=B[−1]=−∞</code>，<code>A[m]=B[n]=∞</code> 即可。这也是比较直观的：当一个数组不出现在前一部分时，对应的值为负无穷，就不会对前一部分的<strong>最大值</strong>产生影响；当一个数组不出现在后一部分时，对应的值为正无穷，就不会对后一部分的<strong>最小值</strong>产生影响。</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>{</span><br><span class="line">        <span class="type">int</span> len1 = nums1.<span class="built_in">size</span>(), len2 = nums2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid1 = <span class="number">0</span>, mid2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = len1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二分找最大的 i 使得 A[i-1] &lt; B[j]</span></span><br><span class="line">        <span class="comment">// i+j = m-i+n-j +1?</span></span><br><span class="line">        <span class="comment">// j = (m+n+1)/2-i;</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right){</span><br><span class="line">            <span class="type">int</span> i = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> j = (len1+len2+<span class="number">1</span>)/<span class="number">2</span>-i;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> vi_pre = i == <span class="number">0</span>? INT_MIN : nums1[i<span class="number">-1</span>];</span><br><span class="line">            <span class="type">int</span> vi = i == len1? INT_MAX : nums1[i];</span><br><span class="line">            <span class="type">int</span> vj_pre = j == <span class="number">0</span>? INT_MIN : nums2[j<span class="number">-1</span>];</span><br><span class="line">            <span class="type">int</span> vj = j == len2? INT_MAX : nums2[j];</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span>(vi_pre &lt;= vj){</span><br><span class="line">                mid1 = <span class="built_in">max</span>(vi_pre, vj_pre);</span><br><span class="line">                mid2 = <span class="built_in">min</span>(vi, vj);</span><br><span class="line">                left = i+<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                right = i<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((len1+len2) %<span class="number">2</span> == <span class="number">1</span>){</span><br><span class="line">            <span class="keyword">return</span> mid1;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="built_in">return</span> (mid1+mid2)/<span class="number">2.0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01背包问题</title>
      <link href="/2020/09/13/01-bei-bao-wen-ti/"/>
      <url>/2020/09/13/01-bei-bao-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有<code>n</code>个重量和价值分别为 $w_i、v_i$ 的物品。从这些物品中挑选出总重量不超过<code>W</code>的物品，求所有挑选方案中价值总和的最大值。</p><blockquote><p>限制条件<br>$1 \le n \le 100$<br>$1 \le w_i、v_i \le 100$<br>$1 \le W \le 10000$</p></blockquote><p><strong>样例</strong></p><blockquote><p>输入格式：$n, W, w_0,v_0,w_1,v_1,…,w_n,v_n$<br>4 5<br>2 3<br>1 2<br>3 4<br>2 2<br>输出：7（选择0、1、3号物品）</p></blockquote><h2 id="朴素搜索"><a href="#朴素搜索" class="headerlink" title="朴素搜索"></a>朴素搜索</h2><p>对于每一个物品，放和不放都试试看，最后取最大值。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="type">int</span> n,W;</span><br><span class="line"><span class="type">int</span> w[MAX_N], v[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//从第i个物品开始选择总重量小于j的部分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rep</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(w[i] &lt;= j){</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">rep</span>(i+<span class="number">1</span>, j), <span class="built_in">rep</span>(i+<span class="number">1</span>, j-w[i])+v[i]);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rep</span>(i+<span class="number">1</span>, j);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>{<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">rep</span>(<span class="number">0</span>,W));}</span><br></pre></td></tr></tbody></table></figure><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>使用一个 dp 数组记录每一个子问题的解，因为原问题中存在重叠子问题，这样可以减少在递归中重复的运算。</p><p><img src="https://tvax3.sinaimg.cn/large/007P6MCBgy1gipfzqg049j31cb0b644h.jpg" alt="递归的调用"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_N = <span class="number">105</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_W = <span class="number">10005</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="type">int</span> n,W;</span><br><span class="line"><span class="type">int</span> w[MAX_N], v[MAX_N];</span><br><span class="line"><span class="comment">//记忆化数组</span></span><br><span class="line"><span class="type">int</span> dp[MAX_N][MAX_W];</span><br><span class="line"></span><br><span class="line"><span class="comment">//从第i个物品开始选择总重量小于j的部分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rep</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">if</span>(dp[i][j] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &gt;= n)</span><br><span class="line">        res =  <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(w[i] &lt;= j){</span><br><span class="line">        res =  <span class="built_in">max</span>(<span class="built_in">rep</span>(i+<span class="number">1</span>, j), <span class="built_in">rep</span>(i+<span class="number">1</span>, j-w[i])+v[i]);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        res =  <span class="built_in">rep</span>(i+<span class="number">1</span>, j);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i][j] = res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">rep</span>(<span class="number">0</span>,W));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="DP方程"><a href="#DP方程" class="headerlink" title="DP方程"></a>DP方程</h2><p>仔细思考上面递归的调用过程，可以发现运算过程是自底向上的，得到递推式：</p><ul><li><code>dp[n][j] = 0</code></li><li><code>dp[i][j] = dp[i+1][j]</code>，当<code>j&lt;w[i]</code>时</li><li><code>dp[i][j] = max(dp[i+1][j], dp[i+1][j-w[i]] + v[i])</code>，其它情况</li></ul><p><img src="https://tvax3.sinaimg.cn/large/007P6MCBgy1gipfyrba1rj319f0bugtt.jpg" alt="dp数组求解"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i][j]: 从第i个物品开始选择总重量小于j的部分,所能得到的最大价值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve1</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=W;j++){</span><br><span class="line">            <span class="keyword">if</span>(w[i] &gt; j)</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j], dp[i+<span class="number">1</span>][j-w[i]]+v[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">0</span>][W]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++编译空类时的行为</title>
      <link href="/2020/09/13/c-bian-yi-kong-lei-shi-de-xing-wei/"/>
      <url>/2020/09/13/c-bian-yi-kong-lei-shi-de-xing-wei/</url>
      
        <content type="html"><![CDATA[<h2 id="空类在定义时会自动生成的成员函数"><a href="#空类在定义时会自动生成的成员函数" class="headerlink" title="空类在定义时会自动生成的成员函数"></a>空类在定义时会自动生成的成员函数</h2><p>当空类<code>Empty</code>定义一个对象<code>e1</code>时，其<code>sizeof(e1)</code>的值为 1 个字节，这个字节其实是一个占位符，为了空类能够被实例化。</p><p>如果在空类里定义一个虚函数，则其值为 4 个字节（在32位系统下），因为多了一个指针（<code>vptr</code>）指向虚函数表，并且取消了一个字节的占位符。</p><p>编译时会自动生成的成员函数如注释中所示：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty_One</span> {};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty_Two</span> { <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>{} };</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Empty_One* e = <span class="keyword">new</span> <span class="built_in">Empty_One</span>();<span class="comment">//无参构造函数  </span></span><br><span class="line"><span class="keyword">delete</span> e;                      <span class="comment">//析构函数  </span></span><br><span class="line">Empty_One e1;                  <span class="comment">//无参构造函数  </span></span><br><span class="line"><span class="function">Empty_One <span class="title">e2</span><span class="params">(e1)</span></span>;              <span class="comment">//拷贝构造函数  </span></span><br><span class="line">e2 = e1;                       <span class="comment">//赋值运算符  </span></span><br><span class="line">Empty_One* pe1 = &amp;e1;          <span class="comment">//取址运算符(非const)  </span></span><br><span class="line"><span class="type">const</span> Empty_One* pe2 = &amp;e2;    <span class="comment">//取址运算符(const) </span></span><br><span class="line">Empty_One &amp;&amp;rr1 = std::<span class="built_in">move</span>(e1);       </span><br><span class="line">    Empty_One e3 = std::<span class="built_in">move</span>(e1);   <span class="comment">//移动赋值函数</span></span><br><span class="line"><span class="function">Empty_One <span class="title">rr2</span><span class="params">(rr1)</span></span>;             <span class="comment">//移动构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Empty_One) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(Empty_Two) &lt;&lt;endl;   <span class="comment">// 4</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>移动语义</title>
      <link href="/2020/09/09/yi-dong-yu-yi/"/>
      <url>/2020/09/09/yi-dong-yu-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><p>新标准的一个主要特性是可以移动而非拷贝对象的能力。很多情况下都会发生对象拷贝，但之后就立即被销毁了，因此移动而非拷贝可以大幅提升性能。</p><blockquote><p>unique_ptr类可以移动但不能拷贝</p></blockquote><p><strong>指针也可以实现内存的移动，为什么不用指针？</strong></p><blockquote><p>C语言中多用指针而不是拷贝，像Java这种自带垃圾回收的语言使用了引用计数，而C++实现了STL库，但是STL里的比如容器里的赋值、函数返回等，拷贝的成本很高。大量使用的STL作为了C++语言的一部分，因此解决这个拷贝成本是十分必要的，使用移动语义，实现的时候偷梁换柱，把资源交换避免了资源的再次创建和销毁。</p></blockquote><p>实际上移动语义更多的是给库作者使用的，对于绝大多数普通开发者了解即可，会用即可。在实际的开发过程中，通常可以搭配智能指针来实现内存管理的自动化。</p><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>为了支持移动操作，新标准引入了一种新的引用类型————右值引用，必须绑定到右值的引用。</p><ul><li>一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。</li><li>此外，虽然某些表达式的求值结果是对象，但它们是右值而非左值。</li><li>当对象被用作左值的时候，用的是对象的身份（在内存中的位置）</li><li>当对象被用作右值的时候，实际使用的是它的内容（值）</li></ul><blockquote><p>右值引用一个重要的性质是，只能绑定到一个将要销毁的对象</p></blockquote><p>类似于任何引用，一个右值引用也不过是某个对象的另一个名字而已。</p><ul><li>对于常规引用（左值引用），我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。</li><li>右值引用有着完全相反的绑定特性：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上。</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i;</span><br><span class="line"><span class="type">int</span> &amp;&amp;rr = i;           <span class="comment">//错误，不能将一个右值引用绑定到一个左值上，需要使用std::move()</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = i * <span class="number">42</span>;       <span class="comment">//错误，i*42是一个右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = i * <span class="number">42</span>; <span class="comment">//正确：可以将一个const引用绑定到一个右值上</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>;     </span><br></pre></td></tr></tbody></table></figure><h2 id="左值持久；右值短暂"><a href="#左值持久；右值短暂" class="headerlink" title="左值持久；右值短暂"></a>左值持久；右值短暂</h2><p>左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时变量</p><p>由于右值引用只能绑定到临时对象，我们得知</p><ul><li>所引用的对象将要被销毁</li><li>该对象没有其他用户</li></ul><p>这两个特性意味着：使用右值引用的代码可以自由接管所引用的对象的资源</p><h2 id="变量是左值"><a href="#变量是左值" class="headerlink" title="变量是左值"></a>变量是左值</h2><p>通常，变量的意义在于，它给一块内存存储区提供名字，方便程序对这块内存进行读写。变量包含两个值：左值和右值。左值是内存存储区的名字，右值是存放存储区中的值。</p><p>变量表达式都是左值,有左值/右值属性。我们不能将一个右值引用绑定到一个右值引用类型的变量上。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr1 = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = rr1; <span class="comment">//错误：表达式rr1是左值，需要使用std::move()</span></span><br></pre></td></tr></tbody></table></figure><h2 id="标准库move函数"><a href="#标准库move函数" class="headerlink" title="标准库move函数"></a>标准库move函数</h2><ul><li>输入：左值</li><li>输出：右值</li></ul><p>我们可以通过调用一个名为<code>move</code>的新标准库函数来获得绑定到左值上的右值引用</p><p>值得注意的是： 使用<code>move</code>意味着，把一个左值转换为右值，原先的值不应该继续再使用（承诺即将废弃）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1);   <span class="comment">//ok</span></span><br></pre></td></tr></tbody></table></figure><h4 id="使用std-move-实现一个高效的swap函数"><a href="#使用std-move-实现一个高效的swap函数" class="headerlink" title="使用std::move 实现一个高效的swap函数"></a>使用std::move 实现一个高效的swap函数</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">T <span class="title">tmp</span><span class="params">(std::move(a))</span></span>;  <span class="comment">//a转换为右值，调用移动构造函数</span></span><br><span class="line">    a = std::<span class="built_in">move</span>(b);     <span class="comment">//b转换为右值，调用移动赋值函数</span></span><br><span class="line">    b = std::<span class="built_in">move</span>(tmp);   <span class="comment">//tmp转换为右值，调用移动赋值函数</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//输入: a=3, b=7</span></span><br><span class="line"><span class="comment">//输出: a=7, b=3</span></span><br></pre></td></tr></tbody></table></figure><p>需要注意的是，必须将右值给左值，才能完成一次内存的移动，如果上面这个函数的第一句这样写：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T &amp;&amp;tmp = std::<span class="built_in">move</span>(a);  <span class="comment">//tmp实际上还是一个指向a的引用</span></span><br><span class="line"><span class="comment">//输入: a=3, b=7</span></span><br><span class="line"><span class="comment">//输出: a=7, b=7</span></span><br></pre></td></tr></tbody></table></figure><p>那么就会出现交换后<code>a</code>和<code>b</code>的值都是原来<code>b</code>的值，因为此时<code>tmp</code>实际上还是一个指向<code>a</code>的引用，在将<code>tmp</code>重新赋值给<code>b</code>的时候其实就是将交换后<code>a</code>的值赋值给<code>b</code>（交换后<code>a</code>的值本来就是原先<code>b</code>的值）。</p><h2 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h2><p><strong>移动构造函数</strong>使用右值来构造一个新的对象。</p><p>与拷贝构造函数不同，它不分配任何新内存，而是接管给定的<code>StrVec</code>中的内存。在接管内存之后，它将给定对象中的指针都置为<code>nullptr</code>。</p><p>这样就完成了从给定对象的移动操作，此对象将继续存在。最终，移后源对象会被销毁，意味着将在其上运行析构函数。 </p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StrVec::<span class="built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="keyword">noexcept</span>  <span class="comment">//移动操作不应抛出任何异常</span></span><br><span class="line">              : <span class="built_in">elements</span>(s.elements), <span class="built_in">first_free</span>(s.first_free), <span class="built_in">cap</span>(s.cap)  <span class="comment">//接管资源</span></span><br><span class="line">{</span><br><span class="line">  s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;   <span class="comment">//这样，对其运行析构函数是安全的</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>移动赋值运算符</strong></p><ul><li>输入：右值，即<code>=</code>号右边</li><li>输出：左值，即将右值赋值给等号左边的左值</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">StrVec&amp; StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">{</span><br><span class="line">  <span class="comment">//如果右侧和左侧运算对象指向同一对象，我们不需要做任何事情</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs){</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = rhs.elements;</span><br><span class="line">    first_free = rhs.first_free;</span><br><span class="line">    cap = rhs.cap;</span><br><span class="line">    rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在移动操作之后，源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设</li><li>只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值函数。</li><li>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认被定义为删除的。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>为了能看到临时对象的拷贝，先关闭编译器关于函数返回值时临时对象的拷贝。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译命令后加上-fno-elide-constructors选项</span></span><br><span class="line">g++ main.cpp -o main.exe -fno-elide-constructors -std=c++11</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtrMem</span>{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n_cstr;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n_dstr;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n_cptr;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n_mvtr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HasPtrMem</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span> (<span class="number">0</span>)){</span><br><span class="line">        cout&lt;&lt;<span class="string">"构造函数:"</span>&lt;&lt;++n_cstr&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">HasPtrMem</span>(<span class="type">const</span> HasPtrMem &amp;h):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span> (*h.num)){</span><br><span class="line">        cout&lt;&lt;<span class="string">"拷贝构造函数:"</span>&lt;&lt;++n_cptr&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    ~<span class="built_in">HasPtrMem</span>(){</span><br><span class="line">        cout&lt;&lt;<span class="string">"析构函数:"</span>&lt;&lt;++n_dstr&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">HasPtrMem</span>(HasPtrMem &amp;&amp;h)<span class="keyword">noexcept</span> :<span class="built_in">num</span>(h.num){</span><br><span class="line">        h.num=<span class="literal">nullptr</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">"移动构造函数:"</span>&lt;&lt;++n_mvtr&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> HasPtrMem::n_cstr=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> HasPtrMem::n_dstr=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> HasPtrMem::n_cptr=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> HasPtrMem::n_mvtr=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">HasPtrMem <span class="title">GetTemp</span><span class="params">()</span></span>{<span class="keyword">return</span> <span class="built_in">HasPtrMem</span>();}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    HasPtrMem a=<span class="built_in">GetTemp</span>();  <span class="comment">//函数里会调用HasPtrMem的构造函数</span></span><br><span class="line">    <span class="function">HasPtrMem <span class="title">b</span><span class="params">(a)</span></span>;         <span class="comment">//a 是左值，因此只能拷贝构造</span></span><br><span class="line">    <span class="function">HasPtrMem <span class="title">c</span><span class="params">(move(a))</span></span>;   <span class="comment">//左值转为右值：std::move()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构造函数:1      <span class="comment">#GetTemp(){return HasPtrMem();}</span></span><br><span class="line">移动构造函数:1  <span class="comment">#GetTemp()函数的临时变量生成</span></span><br><span class="line">析构函数:1      <span class="comment">#析构，与第一个构造函数配对</span></span><br><span class="line">移动构造函数:2  <span class="comment">#main()里的对象a的生成</span></span><br><span class="line">析构函数:2      <span class="comment">#GetTemp()函数的临时对象的析构</span></span><br><span class="line">拷贝构造函数:1  <span class="comment">#对象b的生成, a 是左值，因此只能拷贝构造</span></span><br><span class="line">移动构造函数:3  <span class="comment">#对象c的生成, 移动构造</span></span><br><span class="line">析构函数:3      <span class="comment">#对象c析构</span></span><br><span class="line">析构函数:4      <span class="comment">#对象b析构</span></span><br><span class="line">析构函数:5      <span class="comment">#对象a析构</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存区域</title>
      <link href="/2020/09/07/java-nei-cun-qu-yu/"/>
      <url>/2020/09/07/java-nei-cun-qu-yu/</url>
      
        <content type="html"><![CDATA[<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一块较小的内存空间，它可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>每条线程都需要有一个独立的程序计数器，为每个<strong>线程私有</strong>。</p><ul><li>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。</li><li>如果线程正在执行的是Native方法，这个计数器的值为空。</li></ul><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>其生命周期与线程相同，同时也是<strong>线程私有</strong>的。</p><p>虚拟机栈描述的是<strong>Java方法执行的内存模型</strong>：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p><blockquote><p>栈帧是方法运行时的基础数据结构<br>通常说的“栈”是指虚拟机栈，或者说是虚拟机栈中的局部变量表部分。</p></blockquote><p>局部变量表存放了编译期可知的各种基本类型、对象引用和returnAddress类型。</p><ul><li>对象引用：可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置。</li><li>returnAddress类型：指向了一条字节码指令的地址。</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与虚拟机栈的作用类似，其区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆是被所有<strong>线程共享</strong>的一块内存区域，在虚拟机启动时创建。此内存区域唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p><p>Java堆是垃圾收集器管理的主要区域，可以处于物理上不连续的内存空间中，只要逻辑上连续即可。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>各个<strong>线程共享</strong>的内存区域，用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分。</p><p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是Class文件常量池，用于存放 编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>运行常量池相对于Class文件常量池的另外一个重要特征是具备动态性，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁使用，而且也可能导致OutOfMemoryError异常出现。</p><p>堆外内存，不受Java堆大小限制。</p><p>基于通道(Channel)与缓冲区(Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android知识点整理</title>
      <link href="/2020/08/14/android-zhi-shi-dian-zheng-li/"/>
      <url>/2020/08/14/android-zhi-shi-dian-zheng-li/</url>
      
        <content type="html"><![CDATA[<h2 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h2><h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>Activity是一种可以包含用户界面的组件，主要用于和用户进行交互。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><ul><li>启动状态</li><li>startService(intent);</li><li>绑定状态</li><li>bindService(intent, connection, BIND_AUTO_CREATE);</li></ul><h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><ul><li>查询<br>getContentResolver().query</li></ul><h3 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h3><ul><li><p>接收广播</p></li><li><p>动态注册<br>registerReceiver(BroadcastReceiver子类, IntentFilte);</p></li><li><p>静态注册<br>&lt; intent-filter &gt;</p></li><li><p>发送广播</p></li><li><p>发送标准广播<br>sendBroadcast(intent);</p></li><li><p>发送有序广播<br>sendOrderBroadcast(intent, null);</p></li><li><p>本地广播<br>LocalBroadcastManager.getInstance(this);<br>localBroadcastManager.registerReceiver(BroadcastReceiver子类, IntentFilte);<br>localBroadcastManager.sendBroadcast(intent);</p></li></ul><h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>Binder是Android中的一种跨进程通信方式，还可以理解为一种虚拟的物理设备。</p><p>Android是基于Linux内核的系统，而Linux系统中的进程间通信方式有管道、消息队列、信号量、共享内存、套接字、信号，那么谷歌为什么还要引入Binder通信方式呢。</p><p>从性能的角度来看，Binder数据拷贝只需要一次，而管道、消息队列、套接字都需要拷贝两次内存，不过共享内存一次也不需要。因此Binder性能仅次于共享内存。</p><p>但是共享内存实现方式复杂，没有客户和服务端的区别，需要充分考虑访问临界资源的并发同步问题。而Binder基于C/S架构，Server端与Client端相对独立，因此稳定性优于共享内存。</p><p>那么Binder如何实现只拷贝一次内存呢</p><p>以客户端获取服务为例，在客户端发起申请之前，Binder驱动就将内核空间中的一块内存与服务端的内存空间映射起来，客户端需要将数据从用户空间拷贝到内核空间，而服务端通过映射好的内存，就能直接访问这块数据。</p><p>将进程间通信转化为通过某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程之中，而它的引用却遍布于系统的各个进程之中。可以从一个进程传给其他进程，让大家都能访问同一Server，就像一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。Binder实现了对象在进程间透明传输。</p><p>Zygote进程的IPC采用的是Socket机制，Kill Process采用的是信号机制。Binder更多地用在system_server进程与上层App层的IPC交互。</p><p>在Zygote孵化出system_server进程后，在system_server进程中初始化整个Android Framework的各种各样的Service，这些Service从大方向上分为Java Framework层和Native C++层的Service，几乎都是基于Binder机制。</p><p>Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志，前面提到C/S架构，Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限，目前权限控制很多时候是通过弹出权限询问对话框，让用户选择是否运行。</p><p>传统IPC只能由用户在数据包里填入UID/PID；另外，可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。从安全角度，Binder的安全性更高。</p><h2 id="Java系统服务"><a href="#Java系统服务" class="headerlink" title="Java系统服务"></a>Java系统服务</h2><p>所有Java系统服务由SystemServer启动，分为核心平台服务与硬件服务。</p><p>ActivityManagerService和PacakageManagerService属于核心平台服务，不会直接与Android应用程序交互。</p><p>ActivityManagerService管理所有Activity的生命周期与堆栈</p><p>PacakageManagerService加载和提供Android包文件的信息</p><p>AlarmManagerService属于硬件服务，在特定时间后运行指定的应用程序。</p><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android四大组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迷宫和强化学习</title>
      <link href="/2020/06/15/mi-gong-ji-san-chong-suan-fa/"/>
      <url>/2020/06/15/mi-gong-ji-san-chong-suan-fa/</url>
      
        <content type="html"><![CDATA[<p>程序设计周的课题，内容和要求如下：</p><p><strong>（一）课题内容</strong></p><p>实现走迷宫。主要功能为界面显示、上下左右键的响应以及当前步数统计。通过该课题全面熟悉数组、字符串等的使用，掌握程序设计的基本方法及友好界面的设计。</p><p><strong>（二）课题要求</strong></p><ol><li>游戏界面显示：迷宫地图、上下左右移动的特效。</li><li>动作选择：上下左右键对应于上下左右的移动功能，遇到障碍的处理。</li><li>得分统计功能：步数等。</li><li>设计一个自动走迷宫的程序，使得得到最短路径。</li><li>实现至少三类算法：深度优先、广度优先、Q-learning、蚁群算法</li></ol><p><strong><a href="https://github.com/Maze-AI-NJUPT/Maze-AI-NJUPT/tree/%E5%88%86%E6%94%AF1">Github项目地址</a></strong></p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>项目采用 C++ 语言开发，以 Qt 作为游戏界面，而我负责迷宫地图以及寻路算法的实现。</p><h3 id="迷宫的生成"><a href="#迷宫的生成" class="headerlink" title="迷宫的生成"></a>迷宫的生成</h3><p>主要涉及两个类：格子类以及迷宫类。</p><ul><li>格子类用来保存迷宫地图中的类型，另外，还可以存储额外的信息，比如强化学习中的 Q 表和价值表等。</li><li>迷宫类则主要用来生成并保存迷宫的地图，并提供有关迷宫地图操作的一系列函数。诸如判断某一坐标是否可走、返回当前坐标下一个可走的方向、从当前坐标和方向得到下一步的坐标、获取坐标周围的墙体的坐标，以及更新某一坐标的价值等。</li></ul><p>常用的迷宫生成算法有：随机prim、递归回溯、递归分割法。</p><h4 id="随机prim"><a href="#随机prim" class="headerlink" title="随机prim"></a>随机prim</h4><p>随机prim 通过打通墙壁来生成迷宫。定义一个数组 <code>blocks</code>，其中的元素为一个 <code>pair</code>，保存一个墙体的坐标和方向，也就是从哪个方向到达这个墙体的。</p><p>算法流程如下：</p><ol><li>初始化地图中所有格子的类型为墙体。</li><li>设置起点，并将起点的类型设置为道路。</li><li>获取起点周围的墙体，加入到数组 <code>blocks</code> 中。</li><li>当数组 <code>blocks</code> 不为空进入循环：</li></ol><ul><li>从数组中随机取出一个墙体<code>(x,y)</code></li><li>从此墙体之前过来的方向，再前进一格，得到此坐标<code>(x1,y1)</code></li><li>判断前进到的坐标<code>(x1,y1)</code>是否为墙</li><li>如果是，则将<code>(x,y)</code>和<code>(x1,y1)</code>的格子类型都置为道路，并获取<code>(x1,y1)</code>周围的墙体，加入到数组 <code>blocks</code> 中。</li><li>从数组中删除墙体<code>(x,y)</code></li></ul><ol start="5"><li>设置终点坐标，默认为 <code>(row-2,col-2)</code></li></ol><h3 id="迷宫寻路算法"><a href="#迷宫寻路算法" class="headerlink" title="迷宫寻路算法"></a>迷宫寻路算法</h3><p>比较常见的诸如<code>DFS</code>、<code>BFS</code>就不再介绍了，这里讲讲要求里的用强化学习来寻找路径。</p><p>在强化学习中，有几个关键的概念，分别是环境、智能体、动作、状态。这是类比人类学习的过程，其中智能体通过观察环境得知对应的状态，然后进行相应的动作，接着环境会根据智能体的动作给出相应的奖励，如果智能体做对了，就给出一个正的奖励，否则给出一个负的奖励，智能体通过观察得知奖励的变化，计算下一步动作的价值，从而选择价值最高的动作。所以环境会有一个奖励表，分别记录着当前状态和下一步动作的奖励，这个奖励表是固定的。而智能体则维护着一张Q表，记录当前状态和下一步动作的价值。而智能体的训练过程则是不断地从当前状态计算下一步的价值，更新价值到Q表，然后跳转到下一个状态。刚开始的时候，智能体可能会尝试错误的状态，而当训练次数不断增多，就会稳定到一个固定的状态路径，即得到一个解。而在具体实现中，我并没有明显地定义这两张表，而是将价值和奖励都记录在了迷宫地图的格子中。</p><h4 id="QLearning"><a href="#QLearning" class="headerlink" title="QLearning"></a>QLearning</h4><p>QLearning 的核心是 Q表，其中迷宫地图中的每一个格子对应于一个状态。训练过程就是智能体不断试错的过程，智能体不断地更新 Q表中每个状态和下一步动作，选择价值最大化的动作。</p><p>通常的训练过程：智能体从初始状态出发，选择价值最大化的动作并更新状态（为了智能体有一定的探索性，以一定的概率不选择价值最大化的动作而是随机选择一个动作），然后做出已选择的动作到达下一状态，周而复始，直到到达结束状态，这样一次训练就结束了，然后又重新开始训练，直到达到预定的训练次数或者已经求出解。</p><p>但是，在我们这个项目的迷宫地图中，没有陷阱和宝箱之类的，只有道路和墙，而且智能体在训练的过程通过判断选择不会走墙体的动作，因此在智能体看来，大部分都是价值为 0 的道路，而只有一个终点是价值为 1。这样设置奖励表存在一个问题：就是智能体在没有探索到终点之前，其通过公式更新的价值总是为 0，这显然是没有意义的，只会徒增训练次数。于是可以这样设置奖励表，将道路的奖励设置为 -1，而终点的奖励设置为 0，这样可以保证每次更新到的价值都是有意义的。</p><p>QLearning的算法流程伪代码：<br><img src="http://ww1.sinaimg.cn/large/005JD0Ejgy1ggd24uf8hcj30ir07qmzh.jpg" alt="QLearning"></p><h4 id="Q-Lambda"><a href="#Q-Lambda" class="headerlink" title="Q(Lambda)"></a>Q(Lambda)</h4><p>Q(Lambda) 是在QLearning的基础上的修改版。Q(lambda) 使用了一种叫资格迹的方法，它主要来自于解释奖励的由来。</p><p>改进之后的算法流程与原先的区别：</p><p>每次开始之前所有资格迹置为0，然后每转移到一个状态，当前位置的资格迹就加1，然后价值的公式的后半部分就乘上资格迹，然后选择动作，如果是随机探索，那么就将资格迹置为0，而如果是最大化价值动作，则将资格迹乘上折扣因子与lambda的乘积进行衰减。那么这种训练方法就使用尝试修改的第一种训练方法，遍历迷宫从一个状态出发转移到下一状态，周而复始直到路径被找到。</p><p>但是我实际测试发现这种方法还是不如直接遍历迷宫更新Q表中的每一个格子的价值来的快。</p><p>在测试中我们发现随机探索的概率越高，使用QLearning和QLambda的训练次数的差异就会越大，而两者相比更低的随机探索概率而言其训练次数也会增多。</p><p>Q(Lambda)的算法流程伪代码：<br><img src="https://tvax2.sinaimg.cn/large/005JD0Ejgy1gge6nkdiycj30vg0mzn0e.jpg" alt="QLambda"></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接雨水</title>
      <link href="/2020/05/27/jie-yu-shui/"/>
      <url>/2020/05/27/jie-yu-shui/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（leetcode-42-接雨水）"><a href="#题目（leetcode-42-接雨水）" class="headerlink" title="题目（leetcode 42. 接雨水）"></a>题目（<a href="https://leetcode-cn.com/problems/trapping-rain-water/">leetcode 42. 接雨水</a>）</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="//tva1.sinaimg.cn/large/005JD0Ejgy1gfachjciuwj30bg04hgll.jpg"></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。&nbsp;感谢 Marcos 贡献此图。</p><p><strong>示例:</strong></p><blockquote><p>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>其实就是暴力法的优化。在暴力法的遍历中，每遇到一个元素，都要重新分别往左和往右找最大的元素，然后两者取其小，与当前元素的高度相减，结果加到 ans 中。</p><p>在这里，会有重复计算的情况，也就是具有重叠子问题的性质。考虑下面这个数组：1,6,3,4,5。对于 4 和 5 来说，它们的左边最大元素，显然是 6 ，但是 4 和 5 都要往前遍历到 1 才知道左边最大是 6 。而我们可以使用一个数组，从前往后遍历，不断更新已经遍历到的元素的最大值，姑且称为前缀最大值吧。这个处理完需要遍历一遍数组，即可得到每一个元素的左边最大值是什么。</p><p>同理，右边最大值只需要逆序遍历即可。因此，预处理完共需要遍历两边数组。最后从头开始遍历数组计算结果，操作与暴力法类似，取出当前元素的左边最大值和右边最大值中的较小者，然后与当前元素的高度相减，结果加到 ans 中。</p><p>时间复杂度O(n)。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>{</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">max_left</span><span class="params">(len)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">max_right</span><span class="params">(len)</span></span>;</span><br><span class="line">        max_left[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        max_right[len<span class="number">-1</span>] = height[len<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">            max_left[i] = <span class="built_in">max</span>(max_left[i<span class="number">-1</span>], height[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            max_right[i] = <span class="built_in">max</span>(max_right[i+<span class="number">1</span>], height[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            ans += <span class="built_in">min</span>(max_left[i], max_right[i]) - height[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="单调递减栈"><a href="#单调递减栈" class="headerlink" title="单调递减栈"></a>单调递减栈</h2><p>将下标值维护成一个单调递减栈来逐层计算雨水量，如图所示。当遇到比栈顶元素大的元素的时候，其实就是已经形成了一个坑可以装雨水了，那么就需要往前考察共三个元素：当前元素 <code>i</code> 、栈顶元素 <code>top</code> 和栈顶下面一个元素 <code>st.top()</code>。这里默认弹出了一个栈顶元素，所以栈顶下面一个元素是 <code>st.top()</code>。</p><p><img src="//tva3.sinaimg.cn/large/005JD0Ejgy1gfctogcm49j30bg04hwet.jpg" alt="上图展示了第二层第一个红色箭头雨水的求解过程：共经历了两次内循环，第一次st.top指向绿色数字1的位置，此时计算出的界定高度为0，因此ans+=0；第二次内循环st.top指向绿色数字2，计算出的界定高度=min(2,3)-1=1，ans+=1*3"></p><p>最重要的是计算界定高度 <code>bound_height</code>，即确定雨水有几层。</p><p>它的值应是当前元素高度 <code>height[i]</code> 和栈顶下面一个元素高度<code>height[st.top()]</code>之间的最小值，减去栈顶元素高度<code>height[top]</code>。</p><ul><li>界定高度：<code>bound_height = min(height[i], height[st.top()]) - height[top];</code></li></ul><p>那么雨水量 = 几层雨水<code>bound_height</code> * 当前元素与栈顶元素下面一个元素的距离 <code>distance</code>。</p><ul><li>雨水量：<code>ans += distance * bound_height;</code></li></ul><p>其中<code>distance</code>直接用下标相减：<code>i - st.top() - 1;</code></p><p>时间复杂度O(n)，只需要遍历数组一次。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>{</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="built_in">top</span>()])</span><br><span class="line">            {</span><br><span class="line">                <span class="type">int</span> top = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">empty</span>())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="type">int</span> distance = i - st.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> bound_height = <span class="built_in">min</span>(height[i], height[st.<span class="built_in">top</span>()]) - height[top];</span><br><span class="line">                ans += distance * bound_height;</span><br><span class="line">            }</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>这个解法真是优秀。大概思路是只要知道一边柱子比另一边柱子高，那么无论它们之间相隔了多少柱子，低的柱子的雨水量总是可以确定的，接着继续从低往高遍历，与此同时更新左边最高和右边最高的值。如果最高的一边变化了则换个方向。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>{</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right]) <span class="comment">//(left_max &lt; right_max) 更符合逻辑</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (left_max &lt; height[left])</span><br><span class="line">                    left_max = height[left];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ans += left_max - height[left];</span><br><span class="line">                left++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (right_max &lt; height[right])</span><br><span class="line">                    right_max = height[right];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ans += right_max - height[right];</span><br><span class="line">                right--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="暴力双指针"><a href="#暴力双指针" class="headerlink" title="暴力双指针"></a>暴力双指针</h2><p>自己想到的简陋解法。假如把数组里的那些高度看成一根根柱子，要是能装水，至少得有两根柱子把水围起来，那么长度小于 2 的数组可以直接特判返回 0 。</p><p>接下来使用左右两个指针<code>lf</code>和<code>rt</code>，分别代表左边和右边的柱子。左指针从 0 开始，右指针从 1 开始。</p><p>每当确定左边的柱子之后，就开始寻找右边的柱子。</p><ul><li>如果遇到与左边的柱子同样高或更高的柱子，就能立即确定这个就是右边的柱子，然后求这两个柱子间能装多少水（这在确定右边柱子的过程就能求到，默认左边柱子比右边低），同时在这个过程中记录左边柱子后面哪根柱子最高。</li><li>如果遍历完数组发现没有比左边柱子高的柱子，就取记录中的最高柱子作为右边柱子，然后求两个柱子间能装多少水。</li></ul><p>在这之后需要注意更新左右指针的值。</p><p>最好情况下只需要遍历一边数组就能得到答案，时间复杂度O(n)。最坏的情况下，数组中的数是逆序的，这样对于每一个左边柱子都要遍历完数组，复杂度O(n^2)。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;height)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> lf = <span class="number">0</span>, rt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lf &lt; len - <span class="number">1</span>) <span class="comment">// 确定左边柱子后</span></span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> max_value = height[rt];</span><br><span class="line">            <span class="type">int</span> max_i = rt;</span><br><span class="line">            <span class="keyword">while</span> (rt &lt; len &amp;&amp; height[lf] &gt; height[rt]) <span class="comment">//往后遍历寻找右边柱子</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(height[rt] &gt;= max_value) <span class="comment">//更新最大值</span></span><br><span class="line">                {</span><br><span class="line">                    max_value = height[rt];</span><br><span class="line">                    max_i = rt;</span><br><span class="line">                }</span><br><span class="line">                tmp += height[lf] - height[rt]; <span class="comment">// 存储存在右边柱子高于左边情况的结果  </span></span><br><span class="line">                rt++;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rt == len) <span class="comment">// 如果右边不存在一个柱子高于左边的柱子</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=lf+<span class="number">1</span>;i&lt;max_i;i++) <span class="comment">// 那么取右边最高的柱子，来求高度差（短板效应）</span></span><br><span class="line">                {</span><br><span class="line">                    ans += max_value - height[i];</span><br><span class="line">                }     </span><br><span class="line">                lf = max_i;   <span class="comment">// 完事之后更新左右指针</span></span><br><span class="line">                rt = lf + <span class="number">1</span>;          </span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{   </span><br><span class="line">                ans += tmp;  <span class="comment">// 右边有高于或与左边相平的柱子，直接更新答案</span></span><br><span class="line">                lf = rt++;   <span class="comment">//更新左右指针</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="暴力-超时"><a href="#暴力-超时" class="headerlink" title="暴力(超时)"></a>暴力(超时)</h2><p>照搬官方题解的，时间复杂度O(n^2)。虽然会超时，但是这个思路我当时没想到，而且可以启发动态规划的解法。对于数组中的每个元素，我们找到下雨后水能达到的最高位置，等于两边最大高度的较小值减去当前高度的值。</p><ul><li>初始化 ans=0</li><li>从左向右扫描数组：<ul><li>初始化 max_left=0 和 max_right=0</li><li>从当前元素向左扫描并更新：<ul><li>max_left=max(max_left,height[j])</li></ul></li><li>从当前元素向右扫描并更新：<ul><li>max_right=max(max_right,height[j])</li></ul></li><li>将min(max_left,max_right)−height[i] 累加到 ans</li></ul></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;height)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">                left_max = <span class="built_in">max</span>(left_max,height[j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;len;j++)</span><br><span class="line">                right_max = <span class="built_in">max</span>(right_max,height[j]);</span><br><span class="line">            ans += <span class="built_in">min</span>(left_max,right_max) - height[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译器如何区别不同的重载函数</title>
      <link href="/2020/05/24/bian-yi-qi-ru-he-qu-bie-bu-tong-de-chong-zai-han-shu/"/>
      <url>/2020/05/24/bian-yi-qi-ru-he-qu-bie-bu-tong-de-chong-zai-han-shu/</url>
      
        <content type="html"><![CDATA[<p><code>C++</code>和<code>java</code>都能使用重载函数，它们在源代码中的有着相同的名字，但是有不同的参数列表。</p><p>那么链接器是如何区别这些不同的重载函数之间的差异呢？</p><h2 id="重整"><a href="#重整" class="headerlink" title="重整"></a>重整</h2><p><code>C++</code>和<code>java</code>使用兼容的重整策略。这种编码过程叫做重整（mangling），与此相反的过程是恢复（demangling）。</p><p><strong>编译器</strong>将每个唯一的函数和参数列表组合编码成一个对链接器来说唯一的名字。</p><p>一个被重整的类名字是由名字中字符的整数数量，后面跟原始名字组成。</p><blockquote><p>比如，类<code>Foo</code>被编码成<code>3Foo</code>。<br>函数被编码为原始函数名，后面加上<code>__</code>，加上被重整的类名，再加上每个参数的单字母编码。<br>比如，<code>Foo::bar(int,long)</code>，被编码成<code>bar__3Fooil</code>。</p></blockquote><p>重整全局变量和模板名字的策略是类似的。</p><p>可以使用<code>extern "C"</code>告诉编译器，下面的代码按照 C 方式进行编译，即不需要对函数进行名字重整。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库语句习题</title>
      <link href="/2020/04/30/shu-ju-ku-xi-ti/"/>
      <url>/2020/04/30/shu-ju-ku-xi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章习题"><a href="#第三章习题" class="headerlink" title="第三章习题"></a>第三章习题</h2><h3 id="零件供应问题"><a href="#零件供应问题" class="headerlink" title="零件供应问题"></a>零件供应问题</h3><h4 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h4><p>创建供应商表S</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>s S(</span><br><span class="line">  SNO <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">primary</span> key,</span><br><span class="line">  SNAME <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  STATUS <span class="type">char</span>(<span class="number">2</span>),</span><br><span class="line">  CITY <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>创建零件表P</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> P(</span><br><span class="line">  PNO <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">primary</span> key,</span><br><span class="line">  PNAME <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  COLOR <span class="type">char</span>(<span class="number">2</span>),</span><br><span class="line">  WEIGHT <span class="type">int</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>创建工程项目表J</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> J(</span><br><span class="line">  JNO <span class="type">char</span>(<span class="number">2</span>) <span class="keyword">primary</span> key,</span><br><span class="line">  JNAME <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  CITY <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>创建供应情况表SPJ</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> SPJ(</span><br><span class="line">  SNO <span class="type">char</span>(<span class="number">2</span>),</span><br><span class="line">  PNO <span class="type">char</span>(<span class="number">2</span>),</span><br><span class="line">  JNO <span class="type">char</span>(<span class="number">2</span>),</span><br><span class="line">  QTY <span class="type">int</span>,</span><br><span class="line">  <span class="keyword">primary</span> key(SNO,PNO,JNO),</span><br><span class="line">  <span class="keyword">foreign</span> key (SNO) <span class="keyword">references</span> S(SNO) <span class="keyword">on</span> <span class="keyword">update</span> cascade,</span><br><span class="line">  <span class="keyword">foreign</span> key (PNO) <span class="keyword">references</span> P(PNO) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">no</span> action,</span><br><span class="line">  <span class="keyword">foreign</span> key (JNO) <span class="keyword">references</span> J(JNO)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ol><li><p>求供应工程J1零件的供应商号码SNO；</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SNO <span class="keyword">from</span> SPJ <span class="keyword">where</span> JNO<span class="operator">=</span>"J1";</span><br></pre></td></tr></tbody></table></figure></li><li><p>求供应工程J1零件P1的供应商号码SNO；</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SNO <span class="keyword">from</span> SPJ <span class="keyword">where</span> JNO<span class="operator">=</span>"J1" <span class="keyword">and</span> PNO<span class="operator">=</span>"P1";</span><br></pre></td></tr></tbody></table></figure></li><li><p>求供应工程J1零件为红色的供应商号码SNO；</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SNO <span class="keyword">from</span> SPJ,P <span class="keyword">where</span> SPJ.PNO<span class="operator">=</span>P.PNO <span class="keyword">and</span> COLOR<span class="operator">=</span>"红" <span class="keyword">and</span> JNO<span class="operator">=</span>"J1";</span><br></pre></td></tr></tbody></table></figure><p>或者</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SNO <span class="keyword">from</span> SPJ <span class="keyword">where</span> JNO<span class="operator">=</span>"J1" <span class="keyword">and</span> PNO <span class="keyword">in</span>(</span><br><span class="line">  <span class="keyword">select</span> PNO <span class="keyword">from</span> P <span class="keyword">where</span> COLOR<span class="operator">=</span>"红"</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure></li><li><p>求没有使用天津供应商生产的红色零件的工程号JNO；</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> JNO <span class="keyword">from</span> SPJ <span class="keyword">where</span> JNO <span class="keyword">not</span> <span class="keyword">in</span>(</span><br><span class="line">  <span class="keyword">select</span> JNO <span class="keyword">from</span> S,P,SPJ <span class="keyword">where</span> S.SNO<span class="operator">=</span>SPJ.SNO <span class="keyword">and</span> P.PNO<span class="operator">=</span>SPJ.PNO <span class="keyword">and</span> CITY<span class="operator">=</span>"天津" <span class="keyword">and</span> COLOR<span class="operator">=</span>"红"</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure></li><li><p>求至少用了供应商S1所供应的全部零件的工程号JNO。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*未测试*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> JNO <span class="keyword">from</span> SPJ <span class="keyword">as</span> a <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">  (<span class="keyword">select</span> <span class="keyword">distinct</span> PNO <span class="keyword">from</span> SPJ <span class="keyword">where</span> PNO <span class="keyword">in</span> </span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">distinct</span> PNO <span class="keyword">from</span> SPJ <span class="keyword">where</span> SNO<span class="operator">=</span>"S1") </span><br><span class="line">    <span class="keyword">and</span> JNO<span class="operator">=</span> a.JNO </span><br><span class="line">  <span class="keyword">union</span> <span class="keyword">all</span> </span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">distinct</span> PNO <span class="keyword">from</span> SPJ <span class="keyword">where</span> SNO<span class="operator">=</span>"S1")</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> PNO</span><br><span class="line">  <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&lt;</span><span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure></li><li><p>找出使用上海产的零件的工程名称</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> JNAME <span class="keyword">from</span> J,S,SPJ <span class="keyword">where</span> S.SNO<span class="operator">=</span>SPJ.SNO <span class="keyword">and</span> J.JNO<span class="operator">=</span>SPJ.JNO <span class="keyword">and</span> S.CITY<span class="operator">=</span>"上海";</span><br></pre></td></tr></tbody></table></figure></li><li><p>找出没有使用天津产的零件的工程号码；</p><blockquote><p>先连接S表和SPJ表查询出所有天津产的零件的工程号码，再在其中查询不在结果集中的JNO。</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> JNO <span class="keyword">from</span> J <span class="keyword">where</span> JNO <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> JNO <span class="keyword">from</span> S,SPJ <span class="keyword">where</span> S.SNO<span class="operator">=</span>SPJ.SNO <span class="keyword">and</span> S.CITY<span class="operator">=</span>"天津");</span><br></pre></td></tr></tbody></table></figure></li><li><p>把全部红色零件的颜色改成蓝色</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> P <span class="keyword">set</span> COLOR<span class="operator">=</span>"蓝" <span class="keyword">where</span> COLOR<span class="operator">=</span>"红";</span><br></pre></td></tr></tbody></table></figure></li><li><p>将供应商S5供给工程J4的零件P6改成由供应商S3供应，请做必要的修改；</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> SPJ <span class="keyword">set</span> SNO<span class="operator">=</span>"S3" <span class="keyword">where</span> SNO<span class="operator">=</span>"S5" <span class="keyword">and</span> JNO<span class="operator">=</span>"J4" <span class="keyword">and</span> PNO<span class="operator">=</span>"P6";</span><br></pre></td></tr></tbody></table></figure></li><li><p>从供应商关系中删除S2的记录，并从供应情况关系中删除相应的记录；</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> SPJ <span class="keyword">where</span> SNO<span class="operator">=</span>"S2";</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> S <span class="keyword">where</span> SNO<span class="operator">=</span>"S2";</span><br></pre></td></tr></tbody></table></figure></li><li><p>将（S2, J6, P4, 200）插入SPJ表中。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> SPJ (SNO, JNO, PNO, QTY) <span class="keyword">values</span>(S2, J6, P4, <span class="number">200</span>);</span><br></pre></td></tr></tbody></table></figure></li><li><p>请为“三建”工程项目建立一个供应情况的视图，包括供应商代码（SNO）、零件代码（PNO）、供应数量（QTY）。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> SANJIAN_SPJ (SNO, PNO, QTY) </span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> SNO,PNO,QTY <span class="keyword">from</span> SPJ,J <span class="keyword">where</span> J.JNO<span class="operator">=</span>SPJ.JNO <span class="keyword">and</span> JNAME<span class="operator">=</span>"三建";</span><br></pre></td></tr></tbody></table></figure></li><li><p>针对该视图完成下列查询：（1）找出“三建”工程项目使用的各种零件代码及其数量；</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> PNO, <span class="built_in">sum</span>(QTY) <span class="keyword">as</span> QTY <span class="keyword">from</span> SANJIAN_SPJ <span class="keyword">group</span> <span class="keyword">by</span> PNO;</span><br></pre></td></tr></tbody></table></figure></li><li><p>(2)找出供应商S1的供应情况。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> SANJIAN_SPJ <span class="keyword">where</span> SNO<span class="operator">=</span>"S1";</span><br></pre></td></tr></tbody></table></figure></li><li><p>按供应商代码统计每位供应商供应某种零件的供应总量，要求：</p></li></ol><ul><li>1）仅显示供应总量&gt;=500的信息</li><li>2）显示SNO、PNO和供应总量</li><li>3）显示时，查询结果按供应总量降序排列，供应总量相同按SNO升序、 PNO降序排列</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SNO,PNO,<span class="built_in">sum</span>(QTY) <span class="keyword">from</span> SPJ <span class="keyword">group</span> <span class="keyword">by</span> SNO,PNO <span class="keyword">having</span> <span class="built_in">sum</span>(QTY)<span class="operator">&gt;=</span><span class="number">500</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">3</span> <span class="keyword">desc</span>, SNO, PNO <span class="keyword">desc</span>; </span><br></pre></td></tr></tbody></table></figure><h2 id="第四章习题"><a href="#第四章习题" class="headerlink" title="第四章习题"></a>第四章习题</h2><h3 id="学生表权限问题"><a href="#学生表权限问题" class="headerlink" title="学生表权限问题"></a>学生表权限问题</h3><ol><li><p>授予用户U1对两个表（学生表和班级表）的所有权限，并可给其他用户授权。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="keyword">table</span> 学生,班级 <span class="keyword">to</span> U1 <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br></pre></td></tr></tbody></table></figure></li><li><p>授予用户U2对学生表具有查询权限，对家庭住址具有更新权限。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>, <span class="keyword">update</span>(家庭住址) <span class="keyword">on</span> <span class="keyword">table</span> 学生 <span class="keyword">to</span> U2;</span><br></pre></td></tr></tbody></table></figure></li><li><p>将对班级表的查询权限授予所有用户。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="keyword">table</span> 班级 <span class="keyword">to</span> public;</span><br></pre></td></tr></tbody></table></figure></li><li><p>将对学生表的查询、更新权限授予角色R1。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>, <span class="keyword">update</span> <span class="keyword">on</span> <span class="keyword">table</span> 学生 <span class="keyword">to</span> R1;</span><br></pre></td></tr></tbody></table></figure></li><li><p>将角色R1授予用户U1，U1可继续授权给其他用户。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> R1 <span class="keyword">to</span> U1 <span class="keyword">with</span> admin option;</span><br></pre></td></tr></tbody></table></figure></li></ol><h3 id="职工权限问题"><a href="#职工权限问题" class="headerlink" title="职工权限问题"></a>职工权限问题</h3><p>假设有下面两个关系模式：</p><ul><li>职工（职工号，姓名，年龄，职务，工资，部门号），其中职工号为主码；</li><li>部门（部门号，部门名，经理名，电话），部门号为主码。</li></ul><ol><li><p>用户王明对两个表（部门表和职工表）有SELECT权限。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="keyword">table</span> 部门,职工 <span class="keyword">to</span> 王明;</span><br></pre></td></tr></tbody></table></figure></li><li><p>用户李勇对两个表有INSERT和DELETE权限</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">insert</span>,<span class="keyword">delete</span> <span class="keyword">on</span> <span class="keyword">table</span> 部门,职工 <span class="keyword">to</span> 李勇;</span><br></pre></td></tr></tbody></table></figure></li><li><p>用户刘星对职工表有SELECT权限，对工资字段有更新权限。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>,<span class="keyword">update</span>(工资) <span class="keyword">on</span> <span class="keyword">table</span> 职工 <span class="keyword">to</span> 刘星;</span><br></pre></td></tr></tbody></table></figure></li><li><p>用户张新具有修改这两个表的结构的权限。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">on</span> <span class="keyword">table</span> 职工,部门 <span class="keyword">to</span> 张新;</span><br></pre></td></tr></tbody></table></figure></li><li><p>用户周平具有对这两个表的所有权限（读、插、改、删数据），并具有给其他用户授权的权限；</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="keyword">table</span> 职工,部门 <span class="keyword">to</span> 周平 <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br></pre></td></tr></tbody></table></figure></li><li><p>用户杨兰具有查询每个部门职工的最高工资、最低工资、平均工资的权限，他不能查看每个人的工资；</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> 部门工资统计(部门号,部门名,最高工资,最低工资,平均工资) </span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> 部门.部门号,部门名, <span class="built_in">max</span>(工资), <span class="built_in">min</span>(工资), <span class="built_in">avg</span>(工资) <span class="keyword">from</span> 部门,职工 <span class="keyword">where</span> 部门.部门号<span class="operator">=</span>职工.部门号 <span class="keyword">group</span> <span class="keyword">by</span> 部门.部门号,部门名;</span><br><span class="line">     <span class="comment">/**/</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> <span class="keyword">table</span> 部门工资统计 <span class="keyword">to</span> 杨兰;</span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="第五章习题"><a href="#第五章习题" class="headerlink" title="第五章习题"></a>第五章习题</h2><h3 id="职工问题（同上）"><a href="#职工问题（同上）" class="headerlink" title="职工问题（同上）"></a>职工问题（同上）</h3><p>用SQL语言定义这两个关系模式，要求：</p><ul><li>1）定义每个关系模式的主码；</li><li>2）定义参照完整性约束；</li><li>3）定义职工年龄不得超过60岁。</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 部门(</span><br><span class="line">  部门号 <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">primary</span> key,</span><br><span class="line">  部门名 <span class="type">varchar</span>(<span class="number">40</span>),</span><br><span class="line">  经理名 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  电话 <span class="type">varchar</span>(<span class="number">11</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 职工 (</span><br><span class="line">  职工号 <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">primary</span> key,</span><br><span class="line">  姓名 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  年龄 <span class="type">int</span> <span class="keyword">check</span>(年龄<span class="operator">&lt;=</span><span class="number">60</span>),</span><br><span class="line">  职务 <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">  工资 <span class="type">float</span>,</span><br><span class="line">  部门号 <span class="type">char</span>(<span class="number">4</span>),</span><br><span class="line">  <span class="keyword">foreign</span> key (部门号) <span class="keyword">references</span> 部门(部门号)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>某单位想举行一个小型的联谊会，关系Male记录注册的男宾信息，关系Female记录注册的女宾信息。建立一个断言，将来宾的人数限制在50人以内。</p><blockquote><p>分别查询Male表和Female表然后将其联合，求出数目</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> assertion 人数限制 </span><br><span class="line">    <span class="keyword">check</span> (<span class="number">50</span><span class="operator">&gt;=</span><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">                <span class="keyword">from</span></span><br><span class="line">                (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Male <span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Female)</span><br><span class="line">                <span class="keyword">as</span> Guest</span><br><span class="line">    );</span><br></pre></td></tr></tbody></table></figure><h3 id="选课问题"><a href="#选课问题" class="headerlink" title="选课问题"></a>选课问题</h3><ul><li>STUDENT (SNO，SNAME)</li><li>COURSE (CNO,SEMESTER)</li><li>SC(SNO,CNO,GRADE)</li></ul><ol><li><p>检索选修了全部课程的学生姓名</p><blockquote><p>STUDENT和SC连接，然后按学号和姓名进行分组，取出分组中的表项数目与COURSE表中的表项数一致的姓名</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SNAME <span class="keyword">from</span> STUDENT,SC <span class="keyword">where</span> STUDENT.SNO<span class="operator">=</span>SC.SNO</span><br><span class="line">      <span class="keyword">group</span> <span class="keyword">by</span> STUDENT.SNO, SNAME <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">=</span>(</span><br><span class="line">          <span class="keyword">select</span> <span class="built_in">count</span>(CNO) <span class="keyword">from</span> COURSE </span><br><span class="line">      );</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询在课程 CS-110 中成绩为第 4 名的学生的姓名</p><blockquote><p>先对SC表查询出SNO=CS-110的前4名的数据，然后与STUDENT连接，取出第4名那一条数据的姓名</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> top <span class="number">1</span> SNAME <span class="keyword">from</span> </span><br><span class="line">      (<span class="keyword">select</span> top <span class="number">4</span> <span class="operator">*</span> <span class="keyword">from</span> SC <span class="keyword">where</span> SNO<span class="operator">=</span>"CS-110" <span class="keyword">order</span> <span class="keyword">by</span> GRADE <span class="keyword">desc</span>) <span class="keyword">as</span> RS</span><br><span class="line">      ,STUDENT</span><br><span class="line">      <span class="keyword">where</span> RS.SNO<span class="operator">=</span>STUDENT.SNO</span><br><span class="line">      <span class="keyword">order</span> <span class="keyword">by</span> GRADE; </span><br></pre></td></tr></tbody></table></figure></li><li><p>查询成绩处于相应课程的平均成绩和最高成绩之间的学号和课程号</p><blockquote><p>先对SC表为每一门课程求出平均成绩和最高成绩，然后与SC表连接，最后投影出符合条件的号和课程号</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SNO,SC.CNO <span class="keyword">from</span> </span><br><span class="line">      SC, </span><br><span class="line">      (<span class="keyword">select</span> CNO,<span class="built_in">avg</span>(GRADE) <span class="keyword">as</span> 平均成绩, <span class="built_in">max</span>(GRADE) <span class="keyword">as</span> 最高成绩 <span class="keyword">from</span> SC)<span class="keyword">as</span> RS </span><br><span class="line">      <span class="keyword">where</span> </span><br><span class="line">      SC.CNO<span class="operator">=</span>RS.CNO</span><br><span class="line">      <span class="keyword">and</span></span><br><span class="line">      SC.GRADE<span class="operator">&gt;</span>平均成绩</span><br><span class="line">      <span class="keyword">and</span></span><br><span class="line">      SC.GRADE<span class="operator">&lt;</span>最高成绩;  </span><br></pre></td></tr></tbody></table></figure></li></ol><blockquote><p>关于 top n * 的用法</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> top n <span class="operator">*</span>     </span><br><span class="line"><span class="comment">/*显示前n条记录的所有字段信息*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> top n sname, sex  </span><br><span class="line"><span class="comment">/*显示前n条记录的姓名和性别字段*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> top n <span class="keyword">percent</span> <span class="operator">*</span> </span><br><span class="line"><span class="comment">/*显示前n%条记录的所有字段信息*/</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> top n <span class="keyword">percent</span> sname, sex </span><br><span class="line"><span class="comment">/*显示前n%条记录的姓名和性别字段*/</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第k个排列</title>
      <link href="/2020/04/27/di-k-ge-pai-lie/"/>
      <url>/2020/04/27/di-k-ge-pai-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（leetcode-60-第k个排列）"><a href="#题目（leetcode-60-第k个排列）" class="headerlink" title="题目（leetcode 60. 第k个排列）"></a>题目（<a href="https://leetcode-cn.com/problems/permutation-sequence/">leetcode 60. 第k个排列</a>）</h2><p>给出集合&nbsp;<code>[1,2,3,…,n]</code>，其所有元素共有&nbsp;<code>n!</code> 种排列。</p><p>按大小顺序列出所有排列情况，并一一标记，当&nbsp;<code>n = 3</code> 时, 所有排列如下：</p><ol><li>“123”</li><li>“132”</li><li>“213”</li><li>“231”</li><li>“312”</li><li>“321”</li></ol><p>给定&nbsp;n 和&nbsp;k，返回第&nbsp;k&nbsp;个排列。</p><p>说明：</p><ul><li>给定 n&nbsp;的范围是 <code>[1, 9]</code>。</li><li>给定 k&nbsp;的范围是<code>[1, &nbsp;n!]</code>。</li></ul><p><strong>示例 1:</strong></p><blockquote><p>输入: n = 3, k = 3<br>输出: “213”<br><strong>示例 2:</strong></p></blockquote><blockquote><p>输入: n = 4, k = 9<br>输出: “2314”</p></blockquote><h2 id="除法定位"><a href="#除法定位" class="headerlink" title="除法定位"></a>除法定位</h2><p>对于<code>n=6,k=373</code>的情况，可以知道，开头为<code>1</code>的全排列共有<code>5!</code>个，开头为<code>2</code>的全排列也有<code>5!</code>个……以此类推，知 n 个数字作为开头，每一个都有<code>(n-1)!</code>种可能的排列。</p><p>初始化排列<code>num[]={1,2,3,4,5,6}</code>，由于数组下标从 0 开始所以<code>k</code>先减一，得372。</p><ul><li><p>对于第 k 个排列，确定第一位的数字是什么只需要求得下标<code>k / (n-1)!</code>。也就是<code>num[372/(5!)]=num[3]=4</code>，第一位数字是4，同时把在<code>num</code>中的 4 删去。</p></li><li><p>在这之后，问题的规模就缩小，变成<code>n=5, k=372%(5!)=12, num={1,2,3,5,6}</code>，重复上一步。</p></li></ul><p>具体计算过程：</p><ul><li><code>k=372%(5!)=12,  num[372/(5!)]=4, num={1,2,3,5,6}</code></li><li><code>k=12%(4!)=12,  num[12/(4!)]=1, num={2,3,5,6}</code>  </li><li><code>k=12%(3!)=0,  num[12/(3!)]=5, num={2,3,6}</code>  </li><li><code>k=0%(2!)=0,  num[0/(2!)]=2, num={3,6}</code>  </li><li><code>k=0%(1!)=0,  num[0/(1!)]=3, num={6}</code> </li><li><code>k=0%(0!)=0,  num[0/(0!)]=6, num={}</code></li></ul><p>故得<code>n=6,k=373</code>的排列是<code>415236</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> {</span><br><span class="line">        k -= <span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; num = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> []ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">permu</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        {</span><br><span class="line">            num.add(i+<span class="number">1</span>);</span><br><span class="line">            permu *= i+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        {</span><br><span class="line">            permu /= n-i;  </span><br><span class="line">            ans[i] = num.get(k/permu);</span><br><span class="line">            num.remove(k/permu);</span><br><span class="line">            k %= permu;        </span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> Arrays.toString(ans).replaceAll(<span class="string">"\\[|\\]|,|\\s"</span>, <span class="string">""</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大整数相加</title>
      <link href="/2020/04/25/da-zheng-shu-xiang-jia/"/>
      <url>/2020/04/25/da-zheng-shu-xiang-jia/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>将两个字符串形式的大整数相加，输出结果。</p><p><strong>示例</strong><br>输入</p><blockquote><p>2435354365<br>13243</p></blockquote><p>输出</p><blockquote><p>2435367608</p></blockquote><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>按照竖式加法运算进行模拟，用一个长度为 <code>max(a.length,b.length)+1</code> 的字符数组<code>ans</code>保存结果。</p><p>然后从两个字符串的末尾逐位进行运算，首先处理两个字符串重合的部分（即<code>i</code>和<code>j</code>都大于等于0），取当前位的<code>相加结果 mod 10</code> ，然后<code>相加结果 / 10</code>作为进位。</p><p>然后就是将<code>a</code>或<code>b</code>中剩下的数字加入<code>ans</code>中。</p><p>完了之后就剩最高位是否进位，是的话就继续存个1。</p><p>最后是调整数组的大小，最高位有无进位会影响<code>ans</code>第一个元素是否存在，可能需要对数组进行移动以消除空白字符。</p><p>另一种做法是：先将两个字符串的长度对齐，具体为先将结果数组（长度为<code>max(a.length,b.length)</code>）用<code>'0'</code>填充，然后放入长度较小的数字字符串，之后便是与另一个数字字符串进行相加操作，最后根据最高位是否进位来判断是否在数组首部插入进位1。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigIntAdd</span> {</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">char</span>[] addBigInt(<span class="type">char</span>[] a, <span class="type">char</span>[] b)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(a==<span class="literal">null</span>)<span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="literal">null</span>)<span class="keyword">return</span> a;</span><br><span class="line"><span class="type">int</span> <span class="variable">beyond</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length-<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> b.length-<span class="number">1</span>;</span><br><span class="line"><span class="type">char</span>[] ans = <span class="keyword">new</span> <span class="title class_">char</span>[i&gt;j ? i+<span class="number">2</span>: j+<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> ans.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>)                   <span class="comment">// a和b共同部分</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (a[i--] - <span class="string">'0'</span>) + (b[j--] - <span class="string">'0'</span>) + beyond;</span><br><span class="line">ans[k--] = (<span class="type">char</span>)(num%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">beyond = num/<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>) {                         <span class="comment">// 若 a 最长</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (a[i--] - <span class="string">'0'</span>) + beyond;</span><br><span class="line">ans[k--] = (<span class="type">char</span>)(num%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">beyond = num/<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(j&gt;=<span class="number">0</span>) {                         <span class="comment">// 若 b 最长</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (b[j--] - <span class="string">'0'</span>) + beyond;</span><br><span class="line">ans[k--] = (<span class="type">char</span>)(num%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">beyond = num/<span class="number">10</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(beyond&gt;<span class="number">0</span>)                          <span class="comment">// 最高位进位</span></span><br><span class="line">ans[k--] = (<span class="type">char</span>)(beyond+<span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>)                              <span class="comment">// 若最高位没有进位</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> tt[]=<span class="keyword">new</span> <span class="title class_">char</span>[ans.length-<span class="number">1</span>];</span><br><span class="line">    System.arraycopy(ans, <span class="number">1</span>, tt, <span class="number">0</span>, ans.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> tt;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * a="2435354365";</span></span><br><span class="line"><span class="comment"> * b="13243";</span></span><br><span class="line"><span class="comment"> * result=000013243</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>  <span class="type">char</span>[] addBigInt2(<span class="type">char</span> a[],<span class="type">char</span> b[])</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(a==<span class="literal">null</span>) <span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="literal">null</span>) <span class="keyword">return</span> a;</span><br><span class="line"><span class="type">char</span>[] temp=<span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> len=a.length&gt;b.length? a.length:b.length;</span><br><span class="line"><span class="type">char</span> result[]=<span class="keyword">new</span> <span class="title class_">char</span>[len];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">result[i]=<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(a.length&gt;b.length)</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> k=len-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=b.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">result[k--]=b[i];</span><br><span class="line">temp=a;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> k=len-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=a.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">result[k--]=a[i];</span><br><span class="line">temp=b;</span><br><span class="line">}</span><br><span class="line"><span class="type">int</span> c=<span class="number">0</span>;<span class="comment">//  c 是进位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=temp.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span>  t=(temp[i]-<span class="string">'0'</span>)+(result[i]-<span class="string">'0'</span>)+c;</span><br><span class="line"><span class="keyword">if</span>(t&lt;<span class="number">10</span>)  {  result[i]=(<span class="type">char</span>)(t+<span class="string">'0'</span>); c=<span class="number">0</span>;}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">c=<span class="number">1</span>;</span><br><span class="line">result[i]=(<span class="type">char</span>)(t-<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">    <span class="type">char</span> tt[]=<span class="keyword">new</span> <span class="title class_">char</span>[len+<span class="number">1</span>];</span><br><span class="line">    System.arraycopy(result, <span class="number">0</span>, tt, <span class="number">1</span>, len);</span><br><span class="line">    tt[<span class="number">0</span>]=<span class="string">'1'</span>;</span><br><span class="line">    <span class="keyword">return</span> tt;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] ans = addBigInt(a.toCharArray(),b.toCharArray());</span><br><span class="line">System.out.println(ans);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长连续序列</title>
      <link href="/2020/04/10/zui-chang-lian-xu-xu-lie/"/>
      <url>/2020/04/10/zui-chang-lian-xu-xu-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（leetcode-128-最长连续序列）"><a href="#题目（leetcode-128-最长连续序列）" class="headerlink" title="题目（leetcode 128. 最长连续序列）"></a>题目（<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">leetcode 128. 最长连续序列</a>）</h2><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p><p>要求算法的时间复杂度为&nbsp;O(n)。</p><p><strong>示例:</strong></p><blockquote><p>输入:&nbsp;[100, 4, 200, 1, 3, 2]<br>输出: 4<br>解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</p></blockquote><h2 id="哈希表-O-n"><a href="#哈希表-O-n" class="headerlink" title="哈希表 O(n)"></a>哈希表 O(n)</h2><ul><li>使用哈希表插入，来去掉重复的元素</li><li>然后对数组每个的元素遍历</li><li><strong>如果元素的前一个数不在哈希表中（即判断元素是否在一段连续序列中，若是则舍弃）</strong></li><li>接着不断查找存不存在元素+1，更新序列长度。</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>, cur = <span class="number">0</span>, cur_cnt = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums){   <span class="comment">//插入</span></span><br><span class="line">            s.<span class="built_in">insert</span>(num);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums){</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">find</span>(num<span class="number">-1</span>)!=s.<span class="built_in">end</span>()){ <span class="comment">//找一段连续序列的开头</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            cur = num+<span class="number">1</span>;</span><br><span class="line">            cur_cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(s.<span class="built_in">find</span>(cur)!=s.<span class="built_in">end</span>()){ <span class="comment">//不断检查元素+1是否存在</span></span><br><span class="line">                cur_cnt++;</span><br><span class="line">                cur++;</span><br><span class="line">            }</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,cur_cnt); <span class="comment">//更新最大值</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>对于每一段连续序列可以看成一个连通分量。</p><ul><li>扫描到一个数字，只要将它和它的下一个数字（假如存在的话）merge到一起即可。</li><li>更新连通分量的元素个数与最大长度</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// cnt用于记录当前集合的元素个数</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; uf,cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ufind</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> i==uf[i] ? i : uf[i]=<span class="built_in">ufind</span>(uf[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        x = <span class="built_in">ufind</span>(x);</span><br><span class="line">        y = <span class="built_in">ufind</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(x==y)<span class="keyword">return</span> cnt[x];</span><br><span class="line"></span><br><span class="line">        uf[y] = x;</span><br><span class="line">        <span class="comment">//更新合并之后的连通分量的元素个数</span></span><br><span class="line">        cnt[x] += cnt[y];</span><br><span class="line">        <span class="keyword">return</span> cnt[x]; </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums){ <span class="comment">//初始化uf</span></span><br><span class="line">            uf[num] = num;</span><br><span class="line">            cnt[num] = <span class="number">1</span>;</span><br><span class="line">        }        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums){</span><br><span class="line">            <span class="keyword">if</span>(uf.<span class="built_in">find</span>(num+<span class="number">1</span>)!=uf.<span class="built_in">end</span>()){ <span class="comment">//如果下一个数字存在</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">merge</span>(num,num+<span class="number">1</span>)); <span class="comment">//则合并到一起并更新最大值</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="动态规划-O-n"><a href="#动态规划-O-n" class="headerlink" title="动态规划 O(n)"></a>动态规划 O(n)</h2><p><strong>1.用哈希表存储每个端点值对应连续区间的长度</strong><br><strong>2.若数已在哈希表中：跳过不做处理</strong><br><strong>3.若是新数加入：</strong> </p><ul><li>取出其左右相邻数已有的连续区间长度 left 和 right</li><li>计算当前数的区间长度为：len = left + right + 1</li><li>根据 len 更新最大长度 ans 的值</li><li>更新区间两端点的长度值</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; dp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums){</span><br><span class="line">            <span class="keyword">if</span>(dp[num]==<span class="number">0</span>){  <span class="comment">// 需要注意[]操作,</span></span><br><span class="line">                <span class="type">int</span> left = dp[num<span class="number">-1</span>]; <span class="comment">//左相邻数已有的连续区间长度</span></span><br><span class="line">                <span class="type">int</span> right = dp[num+<span class="number">1</span>];<span class="comment">//右相邻数已有的连续区间长度</span></span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> len = left+right+<span class="number">1</span>; <span class="comment">//当前数的区间长度</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, len);  <span class="comment">//更新最大值</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//更新区间两端点的长度值</span></span><br><span class="line">                dp[num] =  dp[num-left] =  dp[num+right] = len;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过"[]"操作，若能确保查找元素在map中存在，还可以用它进行查找操作。</span></span><br><span class="line"><span class="comment">因为在执行“[]”操作的过程中，插入失败会返回与查找元素拥有相同key值的一个iterator。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="排序-O-nlogn"><a href="#排序-O-nlogn" class="headerlink" title="排序 O(nlogn)"></a>排序 O(nlogn)</h2><p>直接排序后，然后遍历统计，注意数字有重复的不算。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()); <span class="comment">//排序</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="keyword">while</span>(nums[i<span class="number">-1</span>] == nums[i]){  <span class="comment">//数字有重复的不算。</span></span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=nums.<span class="built_in">size</span>())<span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=nums.<span class="built_in">size</span>())<span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>]+<span class="number">1</span> == nums[i]){ <span class="comment">//统计</span></span><br><span class="line">                cnt++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{                   <span class="comment">//不连续，更新最大值并重置计数器</span></span><br><span class="line">                ans=<span class="built_in">max</span>(ans,cnt);</span><br><span class="line">                cnt=<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,cnt);  <span class="comment">//更新最大值</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程与信号量</title>
      <link href="/2020/04/07/xian-cheng-yu-xin-hao-liang/"/>
      <url>/2020/04/07/xian-cheng-yu-xin-hao-liang/</url>
      
        <content type="html"><![CDATA[<h2 id="线程内存模型"><a href="#线程内存模型" class="headerlink" title="线程内存模型"></a>线程内存模型</h2><ul><li><p>一组并发线程运行在一个进程上下文中</p></li><li><p>每个线程都有自己独立的线程上下文。包括线程ID、栈、栈指针、程序计数器、条件码、和通用目的寄存器。</p></li><li><p>每个线程和其他线程一起共享进程上下文的剩余部分。包括整个用户虚拟空间，它是由只读文本（代码）、读/写数据、堆以及所有的共享库代码和数据区域组成。</p></li><li><p>寄存器是从不共享的，而虚拟内存总是共享的。</p></li><li><p>不同的线程栈是不对其他线程设防的。所以，如果一个线程以某种方式得到一个指向其他线程栈的指针，那么它就可以读写这个栈的任何部分。</p></li></ul><h3 id="变量映射到内存"><a href="#变量映射到内存" class="headerlink" title="变量映射到内存"></a>变量映射到内存</h3><ul><li><p>全局变量<br>定义在函数之外的变量。在运行时，虚拟内存的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用。</p></li><li><p>本地自动变量<br>定义在函数内部但是没有static属性的变量。在运行时，每个线程的栈都包含它自己的所有本地自动变量的实例。</p></li><li><p>本地静态变量<br>定义在函数内部并有static属性的变量。与全局变量一样，在运行时，虚拟内存的读/写区域只包含每个全局变量的一个实例。</p></li></ul><h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><p>变量的一个实例被一个以上的线程引用。</p><blockquote><p>本地自动变量也可以被其他线程引用，通过将指针赋给全局变量的方式。</p></blockquote><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>具有非负整数值的全局变量，只能由两种特殊操作来处理（P操作和V操作）。</p><ul><li><code>P(s)</code></li></ul><ol><li>如果<code>s</code>是非0的，那么<code>P</code>将<code>s</code>减1，并且立即返回。</li><li>如果<code>s</code>为零，那么就挂起这个线程，直到<code>s</code>变为非零，再进行P操作。</li></ol><ul><li><code>V(s)</code></li></ul><p>V操作将<code>s</code>加1，如果有任何线程阻塞在P操作等待<code>s</code>变为非零，那么V操作会重启这些线程中的一个。</p><blockquote><p>P操作中测试和减1操作是不可分的。<br>P 和 V 的定义确保了正在运行的程序绝不可能进入这样一种状态：一个正确初始化了的信号量有一个负值。</p></blockquote><h2 id="使用信号量来实现互斥"><a href="#使用信号量来实现互斥" class="headerlink" title="使用信号量来实现互斥"></a>使用信号量来实现互斥</h2><p>基本思想是将一个或一组相关的共享变量与一个信号量<code>s</code>（初始为1）联系起来，然后用<code>P(s)</code>和<code>V(s)</code>  操作将相应的临界区包围起来。</p><blockquote><p>又称为二元信号量，因为其取值总是为0或1</p></blockquote><ul><li><strong>以提供互斥为目的的二元信号量常常也称为互斥锁（mutex）。</strong><br>在一个互斥锁上执行 P 操作称为对互斥锁加锁。类似地，执行 V 操作称为对互斥锁解锁。对一个互斥锁加了锁但是还没有解锁的线程称为占用这个互斥锁。</li></ul><h2 id="互斥示例"><a href="#互斥示例" class="headerlink" title="互斥示例"></a>互斥示例</h2><p>当两个或者多个线程同时对共享变量操作，那么很可能出现错误，因为两个线程的指令很可能穿插执行。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span>;  <span class="comment">/* Thread routine prototype */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global shared variable */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">/* Counter */</span></span><br><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">Sem_init</span>(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> niters;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check input argument */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) { </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"usage: %s &lt;niters&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    niters = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create threads and wait for them to finish */</span></span><br><span class="line">    <span class="built_in">Pthread_create</span>(&amp;tid1, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">    <span class="built_in">Pthread_create</span>(&amp;tid2, <span class="literal">NULL</span>, thread, &amp;niters);</span><br><span class="line">    <span class="built_in">Pthread_join</span>(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">Pthread_join</span>(tid2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check result */</span></span><br><span class="line">    <span class="keyword">if</span> (cnt != (<span class="number">2</span> * niters))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"BOOM! cnt=%d\n"</span>, cnt);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"OK cnt=%d\n"</span>, cnt);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Thread routine */</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">thread</span><span class="params">(<span class="type">void</span> *vargp)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> i, niters = *((<span class="type">int</span> *)vargp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; niters; i++) <span class="comment">//line:conc:badcnt:beginloop</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">P</span>(&amp;mutex);</span><br><span class="line">        cnt++;                   <span class="comment">//line:conc:badcnt:endloop</span></span><br><span class="line">        <span class="built_in">V</span>(&amp;mutex);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解决方法是使用二元信号量PV操作以实现临界区互斥访问，即将临界区的访问“串行化”。</p><h2 id="利用信号量来调度共享资源"><a href="#利用信号量来调度共享资源" class="headerlink" title="利用信号量来调度共享资源"></a>利用信号量来调度共享资源</h2><p>除了提供互斥之外，信号量的另一个重要作用是调度对共享资源的访问，即实现同步（互斥其实是作为同步的特例）。在这种情景中，一个线程用信号量操作通知另一个线程，程序状态中的某个条件已经为真了。</p><h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><p>生产者线程和消费者线程共享一个有 n 个槽的有限缓冲区。</p><ul><li>生产者线程反复地生成新的项目（item），并把它们插入到缓冲区中。</li><li>消费者线程不断地从缓冲区取出这些项目，然后消费（使用）它们。</li></ul><img src="//tva3.sinaimg.cn/large/005JD0Ejgy1gdljdnkbp5j30nw05jacy.jpg" alt="生产者消费者问题" width="45%"><p>因为插入和取出项目都涉及更新共享变量，所以我们必须保证对缓冲区的访问是互斥的。但是只保证互斥访问是不够的，我们还需要调度对缓冲区的访问。</p><p>如果缓冲区是满的 （没有空的槽位），那么生产者必须等待直到有一个槽位变为可用。与之相似，如果缓冲区 是空的（没有可取用的项目），那么消费者必须等待直到有一个项目变为可用。</p><h3 id="sbuf-h"><a href="#sbuf-h" class="headerlink" title="sbuf.h"></a>sbuf.h</h3><p>SBUF 操作类型为 sbuf_t 的有限缓冲区。</p><ul><li>项目存放在一个动态分配的 n 项整数数组（buf）中。front 和 rear 索引值记录该数组中的第一项和最后一项。</li><li>三个信号量同步对缓冲区的访问。mutex 信号量提供互斥的缓冲区访问。slots 和 items 信号量分别记录空槽位和可用项目的数量。</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __SBUF_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SBUF_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</span><br><span class="line">    <span class="type">int</span> *buf;          <span class="comment">/* Buffer array */</span>         </span><br><span class="line">    <span class="type">int</span> n;             <span class="comment">/* Maximum number of slots */</span></span><br><span class="line">    <span class="type">int</span> front;         <span class="comment">/* buf[(front+1)%n] is first item */</span></span><br><span class="line">    <span class="type">int</span> rear;          <span class="comment">/* buf[rear%n] is last item */</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;       <span class="comment">/* Protects accesses to buf */</span></span><br><span class="line">    <span class="type">sem_t</span> slots;       <span class="comment">/* Counts available slots */</span></span><br><span class="line">    <span class="type">sem_t</span> items;       <span class="comment">/* Counts available items */</span></span><br><span class="line">} <span class="type">sbuf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __SBUF_H__ */</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="sbuf-c"><a href="#sbuf-c" class="headerlink" title="sbuf.c"></a>sbuf.c</h3><ul><li><p>sbuf_init 函数为缓冲区分配堆内存，设置front 和 rear 表示一个空的缓冲区，并为三个信号量赋初始值。这个函数在调用其他三个函数中的任何一个之前调用一次。</p></li><li><p>sbuf_deinit 函数是当应用程序使用完缓冲区时，释放缓冲区存储的。</p></li><li><p>sbuf_insert 函数等待一个可用的槽位，对互斥锁加锁，添加项目，对互斥锁解锁，然后宣布有一个新项目可用。 </p></li><li><p>sbuf_remove 函数是与 sbuf_insert 函数对称的。在等待一个可用的缓冲区项目之后，对互斥锁加锁，从缓冲区的前面取出该项目，对互斥锁解锁，然后发信号通知一个新的槽位可供使用。</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"sbuf.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create an empty, bounded, shared FIFO buffer with n slots */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    sp-&gt;buf = <span class="built_in">Calloc</span>(n, <span class="built_in">sizeof</span>(<span class="type">int</span>)); </span><br><span class="line">    sp-&gt;n = n;                       <span class="comment">/* Buffer holds max of n items */</span></span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;        <span class="comment">/* Empty buffer iff front == rear */</span></span><br><span class="line">    <span class="built_in">Sem_init</span>(&amp;sp-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>);      <span class="comment">/* Binary semaphore for locking */</span></span><br><span class="line">    <span class="built_in">Sem_init</span>(&amp;sp-&gt;slots, <span class="number">0</span>, n);      <span class="comment">/* Initially, buf has n empty slots */</span></span><br><span class="line">    <span class="built_in">Sem_init</span>(&amp;sp-&gt;items, <span class="number">0</span>, <span class="number">0</span>);      <span class="comment">/* Initially, buf has zero data items */</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Clean up buffer sp */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">Free</span>(sp-&gt;buf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert item onto the rear of shared buffer sp */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">P</span>(&amp;sp-&gt;slots);                          <span class="comment">/* Wait for available slot */</span></span><br><span class="line">    <span class="built_in">P</span>(&amp;sp-&gt;mutex);                          <span class="comment">/* Lock the buffer */</span></span><br><span class="line">    sp-&gt;buf[sp-&gt;rear] = item;   <span class="comment">/* Insert the item */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"生产一个产品 %d \n"</span>,sp-&gt;rear);</span><br><span class="line">    sp-&gt;rear=(sp-&gt;rear+<span class="number">1</span>)%(sp-&gt;n);</span><br><span class="line">    <span class="built_in">V</span>(&amp;sp-&gt;mutex);                          <span class="comment">/* Unlock the buffer */</span></span><br><span class="line">    <span class="built_in">V</span>(&amp;sp-&gt;items);                          <span class="comment">/* Announce available item */</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remove and return the first item from buffer sp */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="built_in">P</span>(&amp;sp-&gt;items);                          <span class="comment">/* Wait for available item */</span></span><br><span class="line">    <span class="built_in">P</span>(&amp;sp-&gt;mutex);                          <span class="comment">/* Lock the buffer */</span></span><br><span class="line">    item = sp-&gt;buf[sp-&gt;front];  <span class="comment">/* Remove the item */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"消费一个产品 %d \n"</span>, sp-&gt;front);</span><br><span class="line">    sp-&gt;front=(sp-&gt;front+<span class="number">1</span>)%(sp-&gt;n);</span><br><span class="line">    <span class="built_in">V</span>(&amp;sp-&gt;mutex);                          <span class="comment">/* Unlock the buffer */</span></span><br><span class="line">    <span class="built_in">V</span>(&amp;sp-&gt;slots);                          <span class="comment">/* Announce available slot */</span></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"sbuf.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sbuf_t</span> buf;   <span class="comment">// 缓冲区的结构体实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">producer_thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">sbuf_insert</span>(&amp;buf,cnt=(cnt+<span class="number">1</span>)%<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)+*((<span class="type">int</span>*)vargp));</span><br><span class="line"><span class="built_in">sleep</span>(<span class="built_in">rand</span>()%<span class="number">10</span>+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">consumer_thread</span><span class="params">(<span class="type">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">sbuf_remove</span>(&amp;buf);</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">sleep</span>(<span class="built_in">rand</span>()%<span class="number">10</span>+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">// 设置随机种子</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sbuf_init</span>(&amp;buf,<span class="number">100</span>);</span><br><span class="line"><span class="type">pthread_t</span> producer[<span class="number">2</span>],consumer;</span><br><span class="line"><span class="type">int</span> seed[<span class="number">2</span>]={<span class="number">2</span>,<span class="number">3</span>};  <span class="comment">// 使每个生产者随机产生的休眠时间不同</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Create threads and wait for them to finish */</span></span><br><span class="line"><span class="built_in">Pthread_create</span>(&amp;producer[<span class="number">0</span>],<span class="literal">NULL</span>,producer_thread,seed);     <span class="comment">//生产者1</span></span><br><span class="line"><span class="built_in">Pthread_create</span>(&amp;producer[<span class="number">1</span>],<span class="literal">NULL</span>,producer_thread,seed+<span class="number">1</span>);   <span class="comment">//生产者2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Pthread_create</span>(&amp;consumer,<span class="literal">NULL</span>,consumer_thread,<span class="literal">NULL</span>);    <span class="comment">// 一个消费者</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 等所有线程结束</span></span><br><span class="line"><span class="built_in">Pthread_join</span>(producer[<span class="number">0</span>],<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">Pthread_join</span>(producer[<span class="number">1</span>],<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Pthread_join</span>(consumer,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sbuf_deinit</span>(&amp;buf);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><img src="//tva2.sinaimg.cn/large/005JD0Ejgy1gdlmjkk0m9j30bs086wes.jpg" alt="生产者消费者" width="40%"><h2 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h2><ul><li>一组并发的线程要访问一个共享对象。</li><li>修改对象的线程叫做写者。只读对象的线程叫做读者。</li><li>写者必须拥有对对象的独占的访问，而读者可以和无限多个其他的读者共享对象。</li></ul><p>读者－写者问题有几个变种，分别基于读者和写者的优先级。</p><ol><li>第一类读者－写者问题，读者优先，要求不要让读者等待，除非已经把使用对象的权限赋予了一个写者。换句话说，读者不会因为有一个写者在等待而等待。</li><li>第二类读者－写者问题，写者优先，要求一旦一个写者准备好可以写，它就会尽可能快地完成它的写操作。同第一类问题不同，在一个写者后到达的读者必须等待，即使这个写者也是在等待。</li></ol><p>对这两种读者一写者问题的正确解答可能导致饥饿（starvation），饥饿就是一个线程无限期地阻塞，无法进展。例如，如果有读者不断地到达，写者就可能无限期地等待。</p><h3 id="第一类读者写者"><a href="#第一类读者写者" class="headerlink" title="第一类读者写者"></a>第一类读者写者</h3><ul><li><p>信号量 mutex 保护对共享变量 count 的访问，count 统计当前在临界区中的读者数量。<br>每当一个写者进入临界区时，它对互斥锁 w 加锁，每当它离开临界区时，对 w 解锁。 这就保证了任意时刻临界区中最多只有一个写者。</p></li><li><p>另一方面，只有第一个进入临界区的读者对 w 加锁，而只有最后一个离开临界区的读者对 w 解锁。<br>当一个读者进入和离开临界区时，如果还有其他读者在临界区中，那么这个读者会忽略互斥锁 w。这就意味着只要还有一个读者占用互斥锁 w，无限多数量的读者可以没有障碍地进入临界区。</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csapp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> text[<span class="number">10</span>]={<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>};</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">sem_t</span> mutex, W;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">reader</span><span class="params">(<span class="type">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">P</span>(&amp;mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">P</span>(&amp;W);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">V</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"读操作： %s\n"</span>, text);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">P</span>(&amp;mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">V</span>(&amp;W);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">V</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">sleep</span>(<span class="built_in">rand</span>()%<span class="number">10</span>+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">writer</span><span class="params">(<span class="type">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">P</span>(&amp;W);</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">rand</span>();</span><br><span class="line">        text[i % n] = i % <span class="number">26</span> + <span class="string">'A'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"写操作: text[%d]=%c \n"</span>,i%n,i % <span class="number">26</span> + <span class="string">'A'</span>);</span><br><span class="line">        <span class="built_in">V</span>(&amp;W);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)+<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="built_in">rand</span>()%<span class="number">10</span>+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;W,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="type">pthread_t</span> read,write;</span><br><span class="line">    <span class="built_in">Pthread_create</span>(&amp;read,<span class="literal">NULL</span>,reader,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">Pthread_create</span>(&amp;write,<span class="literal">NULL</span>,writer,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">Pthread_join</span>(read,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">Pthread_join</span>(write,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><img src="//tvax4.sinaimg.cn/large/005JD0Ejgy1gdlnrnhoc5j30cy097q3m.jpg" alt="第一类读者写者" width="40%">]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
            <tag> 信号量 </tag>
            
            <tag> 生产者消费者 </tag>
            
            <tag> 读者写者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索旋转排序数组</title>
      <link href="/2020/04/06/sou-suo-xuan-zhuan-pai-xu-shu-zu/"/>
      <url>/2020/04/06/sou-suo-xuan-zhuan-pai-xu-shu-zu/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（leetcode-33-搜索旋转排序数组）"><a href="#题目（leetcode-33-搜索旋转排序数组）" class="headerlink" title="题目（leetcode 33. 搜索旋转排序数组）"></a>题目（<a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">leetcode 33. 搜索旋转排序数组</a>）</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组&nbsp;<code>[0,1,2,4,5,6,7]</code>&nbsp;可能变为&nbsp;<code>[4,5,6,7,0,1,2]</code>&nbsp;)。</p><p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回&nbsp;<code>-1</code>&nbsp;。</p><p>你可以假设数组中不存在重复的元素。</p><p>你的算法时间复杂度必须是&nbsp;O(log&nbsp;n) 级别。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4</p></blockquote><p><strong>示例&nbsp;2:</strong></p><blockquote><p>输入: nums = [4,5,6,7,0,1,2], target = 3<br>输出: -1</p></blockquote><h2 id="二分查找修改版"><a href="#二分查找修改版" class="headerlink" title="二分查找修改版"></a>二分查找修改版</h2><p>看到必须<code>log n</code>的时间复杂度很容易就想到二分查找，但是二分查找必须在有序的数组中才能使用，所以最直接能想到的就是找到旋转的那个点<code>mid</code>，因为要查找的<code>target</code>，要么在左边的有序区间里，要么在右边的有序区间里。而检查<code>target</code>在哪个区间只要和数组的首和尾进行比较即可。之后便是在有序区间里使用二分查找。</p><p>但是，旋转点如何在<code>log n</code>的时间复杂度内找到？现在数组的情况有点像快排里的划分操作后的情况，即将数组分成了两个区间且两个区间的元素有整体的大小关系，而现在要找的主元。但是划分操作是<code>O(n)</code>的，所以并不能得到什么启示，甚至觉得在常规方法下没有更好的时间复杂度。</p><p>再想想?</p><p>回到最开始，既然不能在数据上动手脚，那就看看二分查找能不能直接在这个不是有序却有点秩序的数组上运行。最关键在于刚开始说的，<strong>数组的首和尾</strong>。</p><p>在二分查找中，我们会取<code>(left+right)/2</code>作为中点<code>mid</code>，如果拿中点值和数组的首尾进行比较，就会发现，无论二分查找递归到哪一层，只要拿中点值和数组首尾比较，就能确定中点左边的区间是有序的，还是中点右边的区间是有序的。</p><p>而在二分查找时，比较<code>target</code>之后，我们只会往一个方向递归，即左边或右边。那么如果<code>target</code>恰好落在上面发现的有序区间里，就直接往那一边递归，否则往另一边递归。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">my_search</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">const</span> <span class="type">int</span> &amp;target)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(right &lt; left)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果找到</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target){</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == right)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左半边有序</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>]){</span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[mid] &amp;&amp; target&gt;=nums[<span class="number">0</span>]){ <span class="comment">//如果在有序区间里</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">my_search</span>(left,mid<span class="number">-1</span>,nums,target);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">my_search</span>(mid+<span class="number">1</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>,nums,target);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果右半边有序</span></span><br><span class="line">        <span class="keyword">else</span>{ </span><br><span class="line">            <span class="keyword">if</span>(target&gt;nums[mid] &amp;&amp; target &lt;= nums.<span class="built_in">back</span>()){ <span class="comment">//如果在有序区间里</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">my_search</span>(mid+<span class="number">1</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>,nums,target);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">my_search</span>(left,mid<span class="number">-1</span>,nums,target);                </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">my_search</span>(<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>,nums,target);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL+ajax简易登录验证</title>
      <link href="/2020/04/05/mysql-ajax-jian-yi-deng-lu-yan-zheng/"/>
      <url>/2020/04/05/mysql-ajax-jian-yi-deng-lu-yan-zheng/</url>
      
        <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>实现从网页提交用户名和密码，后端与MySQL中的账户信息匹配，返回结果。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><div align="center" width="35%">  <img src="//tva1.sinaimg.cn/large/005JD0Ejgy1gdio8w0nc0j30ib0r1jsk.jpg" alt="工程目录" width="35%" data-width="659" data-height="973"></div><h2 id="MySQL操作"><a href="#MySQL操作" class="headerlink" title="MySQL操作"></a>MySQL操作</h2><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database MyWeb;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span> (name <span class="type">varchar</span>(<span class="number">10</span>), passwd <span class="type">varchar</span>(<span class="number">20</span>));</span><br><span class="line"><span class="comment">/*插入用户名和密码*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>("litn","123456"); </span><br></pre></td></tr></tbody></table></figure><div align="center" width="35%">  <img src="//tva3.sinaimg.cn/large/005JD0Ejgy1gdiovpsewnj30h0095t8m.jpg" alt="表结构" width="35%" data-width="659" data-height="973"></div><h2 id="pom-xml引入Dependency"><a href="#pom-xml引入Dependency" class="headerlink" title="pom.xml引入Dependency"></a>pom.xml引入Dependency</h2><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意，mybatics必须指明版本</p></blockquote><h2 id="application-properties添加配置"><a href="#application-properties添加配置" class="headerlink" title="application.properties添加配置"></a>application.properties添加配置</h2><p>添加数据库和mybaits的配置</p><ul><li>数据库名：MyWeb</li><li>用户表：user</li><li>表结构：| name | passwd | </li><li>#pojo别名扫描包的下一行需要修改成自己的包</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server.port=<span class="number">8080</span></span><br><span class="line">server.servlet.context-path=/</span><br><span class="line"><span class="comment">#spring.mvc.static-path-pattern=/</span></span><br><span class="line">spring.resources.static-locations=classpath:/resources/,classpath:/static/,classpath:/js,classpath:/css,classpath:/image</span><br><span class="line">spring.mvc.view.prefix=/WEB-INF/jsp/</span><br><span class="line">spring.mvc.view.suffix=.jsp</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:<span class="number">3306</span>/MyWeb?useUnicode=true&amp;characterEncoding=utf-<span class="number">8</span>&amp;serverTimezone=UTC</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=<span class="number">123</span></span><br><span class="line">spring.datasource.driver-<span class="keyword">class</span>-name=com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line"><span class="comment">#spring.datasource.max-idle=10</span></span><br><span class="line"><span class="comment">#spring.datasource.max-wait=10000</span></span><br><span class="line"><span class="comment">#spring.datasource.min-idle=5</span></span><br><span class="line"><span class="comment">#spring.datasource.initial-size=5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#server.session.timeout=10</span></span><br><span class="line">server.tomcat.uri-encoding=UTF-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#spring集成Mybatis环境</span></span><br><span class="line"><span class="comment">#pojo别名扫描包</span></span><br><span class="line">mybatis.<span class="built_in">type</span>-aliases-package=com.litnwu.demo</span><br><span class="line"><span class="comment">#加载Mybatis映射文件</span></span><br><span class="line"><span class="comment">#mybatis.mapper-locations=classpath:mapper/*Mapper.xml</span></span><br></pre></td></tr></tbody></table></figure><h2 id="login-html"><a href="#login-html" class="headerlink" title="login.html"></a>login.html</h2><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $(<span class="keyword">function</span> (<span class="params"></span>) {</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">'#btnLogin'</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) {</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//1.获取用户名、密码</span></span></span><br><span class="line"><span class="language-javascript">                username=$(<span class="string">'#username'</span>).<span class="title function_">val</span>()</span></span><br><span class="line"><span class="language-javascript">                password=$(<span class="string">'#password'</span>).<span class="title function_">val</span>()</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//2.发起post ajax请求，/login_ajax_check,携带用户名和密码</span></span></span><br><span class="line"><span class="language-javascript">                $.<span class="title function_">ajax</span>({</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>:<span class="string">"/login_ajax_check"</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">data</span>:{<span class="attr">username</span>:username,<span class="attr">password</span>:password},</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">async</span>:<span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">cache</span>:<span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">type</span>:<span class="string">"POST"</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">result</span>){</span></span><br><span class="line"><span class="language-javascript">                        <span class="title function_">alert</span>(result.<span class="property">name</span>+result.<span class="property">passwd</span>);</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">if</span>(result){</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">alert</span>(<span class="string">"用户名或密码正确！"</span>);</span></span><br><span class="line"><span class="language-javascript">                            $(location).<span class="title function_">attr</span>(<span class="string">'href'</span>, <span class="string">'/home'</span>);</span></span><br><span class="line"><span class="language-javascript">                            <span class="comment">//$.cookie('name',result.name, { expires: 7 });</span></span></span><br><span class="line"><span class="language-javascript">                            <span class="comment">//$.cookie('passwd',result.passwd, { expires: 7 });</span></span></span><br><span class="line"><span class="language-javascript">                        }<span class="keyword">else</span>{</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">alert</span>(<span class="string">"用户名或密码错误"</span>);</span></span><br><span class="line"><span class="language-javascript">                            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                        }</span></span><br><span class="line"><span class="language-javascript">                    }</span></span><br><span class="line"><span class="language-javascript">                });</span></span><br><span class="line"><span class="language-javascript">            })</span></span><br><span class="line"><span class="language-javascript">        })</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* ......样式表，限于篇幅不展示 */</span></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">placeholder</span>=<span class="string">"Enter the Username"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"Enter the Password"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btnLogin"</span> <span class="attr">value</span>=<span class="string">"Login"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> @<span class="attr">click</span>=<span class="string">"login"</span> <span class="attr">value</span>=<span class="string">"重置"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btnSignin"</span> <span class="attr">value</span>=<span class="string">"注册"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"errmsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="LoginController实现"><a href="#LoginController实现" class="headerlink" title="LoginController实现"></a>LoginController实现</h2><p>类实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    userService userService;   <span class="comment">//必须带@Autowired注解</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = "/login_ajax_check")</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">passwd</span> <span class="operator">=</span> request.getParameter(<span class="string">"password"</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(passwd);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findByName(name,passwd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(user != <span class="literal">null</span>){</span><br><span class="line">            System.out.println(user.name);</span><br><span class="line">            session.setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="userService实现"><a href="#userService实现" class="headerlink" title="userService实现"></a>userService实现</h2><p>类实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">userService</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> userDao userDao;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findByName</span><span class="params">(String name, String passwd)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>  userDao.Login(name,passwd);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="User实现"><a href="#User实现" class="headerlink" title="User实现"></a>User实现</h2><p>类实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String passwd;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="userDao实现"><a href="#userDao实现" class="headerlink" title="userDao实现"></a>userDao实现</h2><p>接口：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">userDao</span> {</span><br><span class="line">    <span class="meta">@Select("select * from user where name=#{name} and passwd=#{passwd}")</span></span><br><span class="line">    User <span class="title function_">Login</span><span class="params">(<span class="meta">@Param("name")</span> String name, <span class="meta">@Param("passwd")</span> String passwd)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐观锁和悲观锁</title>
      <link href="/2020/04/03/le-guan-suo-he-bei-guan-suo/"/>
      <url>/2020/04/03/le-guan-suo-he-bei-guan-suo/</url>
      
        <content type="html"><![CDATA[<p>乐观锁和悲观锁是两个抽象概念，是用于并发控制的两种手段。</p><p>具体地说是数据库实现事务隔离的两种方式：</p><ul><li>悲观：在读取数据前，对其加锁，阻止其他事务对数据的修改。</li><li>乐观：不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本。因此，这种技术叫做<strong>数据多版本并发控制</strong>（MultiVersion Concurrency Control，简称MVCC或MCC），也经常称为<strong>多版本数据库</strong>。</li></ul><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="事务（Transaction）、事务的ACID属性"><a href="#事务（Transaction）、事务的ACID属性" class="headerlink" title="事务（Transaction）、事务的ACID属性"></a>事务（Transaction）、事务的ACID属性</h3><p>事务是由一组SQL语句组成的逻辑单元。</p><p>事务具有4个属性：</p><ol><li><strong>原子性（Atomicity）</strong>：<br>事务是一个原子操作单元，其对数据的修改，要么全部执行，要么全部不执行。</li><li><strong>一致性（Consistent）</strong>：<br>在事务开始和完成时，数据都必须保持一致的状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li><li><strong>隔离性（Isolation）</strong>：<br>数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li><li><strong>持久性（Durable）</strong>：<br>事务完成之后，它对于数据库的修改是永久性的，即使出现系统故障也能保持。</li></ol><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>在 DBMS 中，并发控制的任务是：</p><p>确保在多个事务同时存取数据库中的同一数据时，不破坏事务的隔离性和统一性，以及数据库统一性。</p><h3 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h3><p>相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而支持更多的用户。</p><p>但是如果没有做好并发控制，就可能导致<strong>更新丢失</strong>、<strong>脏读</strong>、<strong>不可重复读</strong>、<strong>幻读</strong>的问题。</p><ul><li><p>更新丢失：<br>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在。就会发生丢失更新的问题——最后的更新覆盖了由其他事务所做的更新。</p></li><li><p>脏读：<br>一个事务正在对一条记录做修改，在这个事务完成并提交前， 这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制， 第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。</p></li><li><p>不可重复读：<br>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变或某些记录已经被删除了！这种现象就叫做“不可重复读”。</p></li><li><p>幻读：<br>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”．</p></li></ul><h3 id="4个隔离级别"><a href="#4个隔离级别" class="headerlink" title="4个隔离级别"></a>4个隔离级别</h3><p>事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。 </p><p>为了解决“隔离”与“并发”的矛盾， ISO/ANSI SQL92 定义了 4 个事务隔离级别：</p><p><img src="//tvax1.sinaimg.cn/large/005JD0Ejgy1gdgjqd4ty5j31820eg7l6.jpg" alt="4个隔离级别"></p><p>SQL Server 除支持上述 ISO/ANSI SQL92 定义的 4 个隔离级别外，还支持一个叫做“快照”的隔离级别，但严格来说它是一个用 MVCC 实现的 Serializable 隔离级别。</p><h2 id="悲观锁（Pessimistic-Lock）"><a href="#悲观锁（Pessimistic-Lock）" class="headerlink" title="悲观锁（Pessimistic Lock）"></a>悲观锁（Pessimistic Lock）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。</p><p>这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。</p><blockquote><p>百度百科：<br>悲观锁，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度。因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）</p></blockquote><p>之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。</p><p>悲观锁主要是共享锁或排他锁。</p><p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p><ul><li><strong>共享锁（S）</strong>：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li><strong>排他锁（X）</strong>：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共<br>享读锁和排他写锁。</li></ul><p><img src="//tva1.sinaimg.cn/large/005JD0Ejgy1gdgkd25ynjj30u007q444.jpg" alt="先取锁再访问"></p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>悲观锁的实现，往往依靠数据库提供的锁机制。在数据库中，悲观锁的流程如下：</p><ol><li>在对记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。</li><li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。</li><li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li><li>期间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li></ol><h3 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h3><p>比如MySql Innodb引擎，要使用悲观锁，我们必须关闭MySQL数据库的自动提交属性。因为MySQL默认使用autocommit模式，也就是说，当我们执行一个更新操作后，MySQL会立刻将结果进行提交。（sql语句：set autocommit=0）</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">0.</span> 开始事务</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">1.</span> 查询出商品库存信息</span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>  <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">2.</span> 修改商品库存为<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity<span class="operator">=</span><span class="number">2</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">3.</span> 提交事务</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></tbody></table></figure><p>在对id = 1的记录修改前，先通过for update的方式进行加锁，然后再进行修改。</p><p>如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id=1的锁，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p><p>MySQL InnoDB默认行级锁。<strong>行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。</strong></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。</p><h2 id="乐观锁（Optimistic-Locking-）"><a href="#乐观锁（Optimistic-Locking-）" class="headerlink" title="乐观锁（Optimistic Locking ）"></a>乐观锁（Optimistic Locking ）</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。</p><blockquote><p>百度百科：<br>乐观锁机制采取了更加宽松的加锁机制。乐观锁是相对悲观锁而言，也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，但乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。</p></blockquote><p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p><p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。</p><p><img src="//tva2.sinaimg.cn/large/005JD0Ejgy1gdgl7gqq3rj30hs06pq5m.jpg" alt="根据数据版本检测冲突"></p><h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><p>主要就是两个步骤：冲突检测和数据更新。</p><p><strong>其实现方式有一种比较典型的就是CAS(Compare and Swap)。</strong></p><p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询出商品库存信息，quantity<span class="operator">=</span><span class="number">3</span></span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>修改商品库存为<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity<span class="operator">=</span><span class="number">2</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> quantity<span class="operator">=</span><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><p>以上，我们在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。</p><p>当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。</p><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>比如说一个线程one从数据库中取出库存数3，这时候另一个线程two也从数据库中取出库存数3，并且two进行了一些操作变成了2，然后two又将库存数变成3，这时候线程one进行CAS操作发现数据库中仍然是3，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</p><p><img src="//tvax1.sinaimg.cn/large/005JD0Ejgy1gdglkzyqs9j30hs06ktb1.jpg" alt="ABA"></p><p>解决：通过一个单独的可以顺序递增的version字段。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>查询出商品信息，version<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> version <span class="keyword">from</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>修改商品库存为<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity<span class="operator">=</span><span class="number">2</span>,version<span class="operator">=</span><span class="number">3</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> version<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure><p>乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。</p><p><img src="//tva4.sinaimg.cn/large/005JD0Ejgy1gdglthtiozj30hs07tadp.jpg" alt="版本字段"></p><p>除了version以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。</p><h4 id="高并发问题"><a href="#高并发问题" class="headerlink" title="高并发问题"></a>高并发问题</h4><p>高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。</p><p>减小乐观锁力度，最大程度的提升吞吐率，提高并发能力：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>修改商品库存</span><br><span class="line"><span class="keyword">update</span> item</span><br><span class="line"><span class="keyword">set</span> quantity<span class="operator">=</span>quantity<span class="number">-1</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> quantity <span class="operator">-</span> <span class="number">1</span> <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><p>以上SQL语句中，如果用户下单数为1，则通过quantity - 1 &gt; 0的方式进行乐观锁控制。</p><h2 id="乐观锁和悲观锁的区别"><a href="#乐观锁和悲观锁的区别" class="headerlink" title="乐观锁和悲观锁的区别"></a>乐观锁和悲观锁的区别</h2><ul><li><p>乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。</p></li><li><p>悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分配器allocators</title>
      <link href="/2020/04/02/fen-pei-qi-allocators/"/>
      <url>/2020/04/02/fen-pei-qi-allocators/</url>
      
        <content type="html"><![CDATA[<h2 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h2><p>最简易的实现方式是使用<code>malloc</code>进行包装。与此同时开销也很大</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">额外开销如下图：</span><br><span class="line">&lt;div align=center width=45%&gt;</span><br><span class="line">&lt;img width=45% src="//tvax2.sinaimg.cn/large/005JD0Ejgy1gdepsyraenj30m40muwst.jpg" alt="额外开销"&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">// &lt;new.h&gt; of CB5</span><br><span class="line">inline void* _RTLENTRY operator new(size_t size, const std::nothrow_t&amp;)</span><br><span class="line">{</span><br><span class="line">    size = size ? size : 1;</span><br><span class="line">    return malloc(size); </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 那么 operator delete 里就是 free(p);</span><br></pre></td></tr></tbody></table></figure><h2 id="VC6的allocator"><a href="#VC6的allocator" class="headerlink" title="VC6的allocator"></a>VC6的allocator</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FARQ</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _FARQ</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _PDFT ptrdiff_t</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _SIZT size_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _POINTER_X(T,A)  T_FARQ*</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _REFERENCE_X(T,A) T_FARQ&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">allocator</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _SIZT size_type;</span><br><span class="line">    <span class="keyword">typedef</span> _PDFT difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty _FARQ *pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line">                                    <span class="comment">//无名形参，获取类型的小技巧</span></span><br><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type _N, <span class="type">const</span> <span class="type">void</span>*)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> (_Allocate( (difference_type)_N, (pointer)<span class="number">0</span>);)</span><br><span class="line">    }</span><br><span class="line">    <span class="type">void</span> <span class="built_in">deallocate</span>(<span class="type">void</span> _FARQ *_P, size_type){</span><br><span class="line">        <span class="keyword">operator</span> <span class="built_in">delete</span>(_P);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>&gt;<span class="keyword">inline</span></span><br><span class="line">_Ty _FARQ *_Allocate(_PDFT _N, _Ty _FARQ *)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>( _N &lt; <span class="number">0</span>)_N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ((_Ty _FARQ *)<span class="keyword">operator</span> <span class="built_in">new</span>((_SIZT)_N * <span class="built_in">sizeof</span>(_Ty)));</span><br><span class="line">}   </span><br></pre></td></tr></tbody></table></figure><p>测试</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配 512 ints</span></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">512</span>,(<span class="type">int</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p,<span class="number">512</span>);</span><br><span class="line">                                <span class="comment">// 需要指定大小</span></span><br></pre></td></tr></tbody></table></figure><h2 id="GNU2-9的alloc"><a href="#GNU2-9的alloc" class="headerlink" title="GNU2.9的alloc"></a>GNU2.9的alloc</h2><p>在GNU4.9中不再是默认allocator，而是变成了<code>__pool_alloc</code>。</p><p>尽量减少malloc的次数，从而减少额外开销。</p><p>共有16条链表，每一种链表负责特定大小的区块。以8的倍数增长，最后一条链表维护的内存块为128 byte。</p><p>所有的容器需要内存的时候，都来跟这个分配器要内存。容器的元素大小会被调整到8的倍数。先检查特定的一条链表是否挂有内存块，如果没有则用malloc向操作系统要一大块，然后切割，切出来的内存块用单向链表穿起来。所以这个切出来的每一块内存块都不带cookie。</p><p><img src="//tva2.sinaimg.cn/large/005JD0Ejgy1gdeph495vwj31hu0qwnpd.jpg" alt="__pool_alloc"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector的实现</title>
      <link href="/2020/04/01/vector-de-shi-xian/"/>
      <url>/2020/04/01/vector-de-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>vector是顺序容器的一种，从使用方法来看可以知道vector是一个模板类。</p><p>vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率。</p><p>vector，就像它的名字——向量，可以单向生长。因此使用的是动态内存分配来维护数据，执行push_back来向尾部添加数据，当vector的容量不足以存放新的元素时，就会<strong>在内存中寻找一块大小为2倍的size的空间</strong>，然后把原来的数据拷贝过去，最后再添加一个新元素，释放原空间。</p><ul><li><p>vector维护的是一个连续线性空间，所以vector支持随机存取  。</p></li><li><p>使用vector需要注意的是，每次二倍增长都会大量地调用拷贝构造函数和析构函数，这就是成本。</p></li><li><p>对vector的任何操作一旦引起了空间的重新配置，指向原vector的所有迭代器就会都失效</p></li><li><p>vector元素不能是引用，因为vector元素需要有实际地址</p></li><li><p><code>size()</code>: 当前有多少元素; <code>capacity()</code>: 可容纳多少元素；</p></li></ul><p>vector 对象本身在栈上，里面的成员指针指向堆。</p><p>vector 和基本数据类型一样使用，定义指针一样。</p><p>vector 内的元素存放在堆中，由STL库中的程序负责分配和释放，使用方便，但是效率低下。</p><h2 id="版本GNU2-9"><a href="#版本GNU2-9" class="headerlink" title="版本GNU2.9"></a>版本GNU2.9</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>=alloc&gt;</span><br><span class="line"><span class="keyword">class</span> vector{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// vector的嵌套型别定义</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">    <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start;  <span class="comment">// 使用空间的头</span></span><br><span class="line">    iterator finish;    <span class="comment">//使用空间的尾</span></span><br><span class="line">    iterator end_of_storage; <span class="comment">//可用空间的尾</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert_aux</span><span class="params">(iterator position, canst T&amp; x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(start)</span><br><span class="line">            data_allocator::<span class="built_in">deallocate</span>(start, end_of_storage - start);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="type">const</span> T&amp; value)</span></span>{</span><br><span class="line">        start = <span class="built_in">allocate_and_fill</span>(n, value);</span><br><span class="line">        finish = start + n;</span><br><span class="line">        end_of_storage = finish;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 配置空间并填满内容</span></span><br><span class="line">    <span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        iterator result = data_allocator::<span class="built_in">allocate</span>(n);</span><br><span class="line">        <span class="built_in">uninitialized_fill_n</span>(result, n, x); <span class="comment">//全局函数</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>{<span class="keyword">return</span> start;}</span><br><span class="line">    </span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>{<span class="keyword">return</span> finish;}</span><br><span class="line">    </span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>()-<span class="built_in">begin</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">size_type <span class="title">capacity</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage-<span class="built_in">begin</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span></span>{<span class="keyword">return</span> <span class="built_in">begin</span>()==<span class="built_in">end</span>();}</span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type n)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> *(<span class="built_in">begin</span>()+n);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span></span>{<span class="keyword">return</span> *<span class="built_in">begin</span>();}</span><br><span class="line"></span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span><span class="params">(<span class="keyword">return</span> *(end()<span class="number">-1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T &amp;x)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(finish != end_of_storage){  <span class="comment">//尚有备用空间</span></span><br><span class="line">            <span class="built_in">construct</span>(finish,x);       <span class="comment">//全局函数</span></span><br><span class="line">            ++finish;                   <span class="comment">//调整水位高度</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// 已无备用空间 </span></span><br><span class="line">            <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(),x);       </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>{</span><br><span class="line">        --finish;</span><br><span class="line">        <span class="built_in">destroy</span>(finish); <span class="comment">//全局函数</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>():<span class="built_in">start</span>(<span class="number">0</span>),<span class="built_in">finish</span>(<span class="number">0</span>),<span class="built_in">end_of_storage</span>(<span class="number">0</span>){}</span><br><span class="line">    <span class="built_in">vector</span>(size_type n, <span class="type">const</span> T&amp; value) { <span class="built_in">fill_initialize</span> (n, value); }</span><br><span class="line">    ~<span class="built_in">vector</span>(){</span><br><span class="line">        <span class="built_in">deatroy</span>(start,finish); <span class="comment">//全局函数</span></span><br><span class="line">        <span class="built_in">deallocate</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(position+<span class="number">1</span> != <span class="built_in">end</span>()){</span><br><span class="line">            <span class="built_in">copy</span>(position+<span class="number">1</span>, finish, position);</span><br><span class="line">        }</span><br><span class="line">        --finish;</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type new_size, <span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(new_size &lt; <span class="built_in">size</span>()){</span><br><span class="line">            <span class="built_in">erase</span>(<span class="built_in">begin</span>() + new_size, <span class="built_in">end</span>());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="built_in">insert</span>(<span class="built_in">end</span>(), new_size-<span class="built_in">size</span>(), x);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type new_size)</span></span>{<span class="built_in">resize</span>(new_size,<span class="built_in">T</span>())};</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>{<span class="built_in">erase</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T,Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="type">const</span> T &amp;x)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 又一次检查，因为会有push_back以外的函数调用</span></span><br><span class="line">    <span class="keyword">if</span>(finish != end_of_storage){ <span class="comment">//尚有备用空间</span></span><br><span class="line">        <span class="comment">// 在备用空间起始处构建一个元素，并以vector最后一个元素为其初值</span></span><br><span class="line">        <span class="built_in">construct</span>(finish,*(finish<span class="number">-1</span>));</span><br><span class="line">        ++finish;  <span class="comment">//调整水位</span></span><br><span class="line">        T x_copy = x;</span><br><span class="line">        <span class="built_in">copy_backward</span>(position, finish<span class="number">-2</span>, finish<span class="number">-1</span>);</span><br><span class="line">        *position = x_copy;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//已无备用空间</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">        <span class="type">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span>*old_size : <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 以上分配原则：如果大小为0，则分配1（个元素大小）</span></span><br><span class="line">        <span class="comment">// 如果大小不为0，则分配原来大小的两倍</span></span><br><span class="line">        <span class="comment">// 前半段用来放置原数据，后半段用来放置新数据</span></span><br><span class="line"></span><br><span class="line">        iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">        iterator new_finish = new_start;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>{</span><br><span class="line">            <span class="comment">// 将原vector内容拷贝到新的vector</span></span><br><span class="line">            new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">construct</span>(new_finish, x);  <span class="comment">//为新元素设初值x</span></span><br><span class="line">            ++new_finish;  <span class="comment">//调整水位</span></span><br><span class="line">            <span class="comment">// 拷贝安插点后的内容到 （因为它也可能被insert(p,x)调用）</span></span><br><span class="line">            new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">catch</span>(...){</span><br><span class="line">            <span class="comment">// "commit or rollback" semantics</span></span><br><span class="line">            <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">            data_allocator::<span class="built_in">deallocate</span>(new_start,len);</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 析构并释放原vector</span></span><br><span class="line">        <span class="built_in">destroy</span>(<span class="built_in">begin</span>(),<span class="built_in">end</span>());  <span class="comment">//全局函数</span></span><br><span class="line">        <span class="built_in">deallocate</span>();</span><br><span class="line">        <span class="comment">//调整迭代器，指向新vector</span></span><br><span class="line">        start = new_start;</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        end_of_storage = new_start + len;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="vector的迭代器"><a href="#vector的迭代器" class="headerlink" title="vector的迭代器"></a>vector的迭代器</h2><p>vector 维护的是一个连续线性空间，所以不论其元素型别为何，普通指针都可以作为 vector 的迭代器而满足所有必要条件。vector 支持随机存取，而普通指针正有着这样的能力。所以， vector 提供的是 Random Access Iterators 。</p><h2 id="萃取机"><a href="#萃取机" class="headerlink" title="萃取机"></a>萃取机</h2><p>满足算法对于迭代器五个问题的问询。作为一个中介层来解决迭代器是不是单纯的指针还是一个类（class）。</p><p>具体的实现，是使用偏特化，来判断class或no-class。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>{</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于常规指针，使用偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;{</span><br><span class="line">    <span class="comment">// 随机存取迭代器的标签</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T* I::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; I::reference reference;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于常规指向常量的指针，使用偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;{</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> T* I::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; I::reference reference;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验一:词法分析</title>
      <link href="/2020/03/28/shi-yan-yi-ci-fa-fen-xi/"/>
      <url>/2020/03/28/shi-yan-yi-ci-fa-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>设计并实现一个词法分析器，实现对指定位置的类C语言源程序文本文件的读取，并能够对该源程序中的所有单词进行分类，指出其所属类型，实现简单的词法分析操作。</p><ol><li>允许用户自己输入源程序并保存为文件</li><li>系统能够输出经过预处理后的源程序（去掉注释、换行、空格等）</li><li>能够将该源程序中所有的单词根据其所属类型（整数、保留字、运算符、标识符等。定义的类C语言中的标识符只能以字母或下划线开头）进行归类显示，例如：识别保留字：if、int、for、while、do、return、break、continue等，其他的都识别为标识符；常数为无符号整形数；运算符包括：+、-、*、/、=、&gt;、&lt;、&gt;=、&lt;=、!=等；分隔符包括：,、;、{、}、(、)等。</li><li>实现文件的读取操作，而不是将文本以字符串形式预存于程序中。文本内容为待分析的类C语言程序。</li></ol><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>书上写的状态转换图，就是用循环不断读取字符来实现。</p><ol><li>读文件到字符串，与此同时将多行注释和单行注释去掉</li><li>词法分析：分隔符、整数、运算符、标识符和保留字</li><li>将分类结果输出</li></ol><ul><li><p>模拟就好了，刚开始照着要求一个一个往下写，后来发现去掉空格后再进行分类是不可行的，比如<code>int intint;</code>和<code>br   eak;</code>，在去掉空格后就无法正确分类，所以只能保留空格分类后再去掉。</p></li><li><p>还有整数的前导0没有考虑到：010 = 10</p></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string text;      <span class="comment">// 保存去掉注释的代码段</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, string&gt;&gt; result{}; <span class="comment">//词法分类结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保留字</span></span><br><span class="line">set&lt;string&gt; pre_save{<span class="string">"do"</span>,<span class="string">"for"</span>,<span class="string">"continue"</span>,<span class="string">"break"</span>,<span class="string">"while"</span>,<span class="string">"return"</span>,<span class="string">"if"</span>,<span class="string">"else"</span>,<span class="string">"void"</span>,<span class="string">"int"</span>,};</span><br><span class="line"><span class="comment">// 一位运算符</span></span><br><span class="line">set&lt;<span class="type">char</span>&gt; s_operator{<span class="string">'+'</span>, <span class="string">'-'</span>, <span class="string">'*'</span>, <span class="string">'/'</span>, <span class="string">'='</span>, <span class="string">'&lt;'</span>, <span class="string">'&gt;'</span>,<span class="string">'?'</span>,<span class="string">':'</span>,<span class="string">'&amp;'</span>,<span class="string">'|'</span>,<span class="string">'!'</span>,<span class="string">'.'</span>};</span><br><span class="line"><span class="comment">// 两位运算符</span></span><br><span class="line">set&lt;string&gt; d_operator{<span class="string">"&lt;="</span>,<span class="string">"&gt;="</span>,<span class="string">"++"</span>,<span class="string">"--"</span>,<span class="string">"+="</span>,<span class="string">"-="</span>,<span class="string">"&lt;&lt;"</span>,<span class="string">"&gt;&gt;"</span>,<span class="string">"::"</span>,<span class="string">"&amp;&amp;"</span>,<span class="string">"||"</span>,<span class="string">"!="</span>,<span class="string">"=="</span>,<span class="string">"*="</span>,<span class="string">"/="</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试用，可删</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vector&lt;string&gt; name{<span class="string">""</span>,<span class="string">"保留字"</span>,<span class="string">"标识符"</span>,<span class="string">"整数"</span>,<span class="string">"运算符"</span>,<span class="string">"分隔符"</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断标识符（除了开头外的部分）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_identifier</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> x = text[i];</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="string">'_'</span> || (x&gt;=<span class="string">'a'</span>&amp;&amp;x&lt;=<span class="string">'z'</span>) || (x&gt;=<span class="string">'A'</span>&amp;&amp;x&lt;=<span class="string">'Z'</span>) || (x-<span class="string">'0'</span>&gt;=<span class="number">0</span> &amp;&amp; x-<span class="string">'0'</span>&lt;=<span class="number">9</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">analysis</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> x = text[i];</span><br><span class="line">    <span class="comment">// 识别分隔符 ：类别5</span></span><br><span class="line">    <span class="keyword">if</span>(x==<span class="string">'('</span>||x==<span class="string">')'</span>||x==<span class="string">'{'</span>||x==<span class="string">'}'</span>||x==<span class="string">';'</span>||x==<span class="string">','</span>)</span><br><span class="line">    {</span><br><span class="line">        string s;</span><br><span class="line">        s.<span class="built_in">push_back</span>(x);</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>,<span class="string">"'"</span>+s+<span class="string">"'"</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 识别整数 ：类别3</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x-<span class="string">'0'</span>&gt;<span class="number">0</span> &amp;&amp; x-<span class="string">'0'</span>&lt;=<span class="number">9</span>){</span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;text.<span class="built_in">length</span>()&amp;&amp; text[i]-<span class="string">'0'</span>&gt;=<span class="number">0</span> &amp;&amp; text[i]-<span class="string">'0'</span>&lt;=<span class="number">9</span>){</span><br><span class="line">            s.<span class="built_in">push_back</span>(text[i]);</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        i--;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'0'</span> &amp;&amp; s.<span class="built_in">length</span>()&gt;<span class="number">1</span>)s=s.<span class="built_in">substr</span>(<span class="number">1</span>,s.<span class="built_in">length</span>()<span class="number">-1</span>); <span class="comment">//消除前导0</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>,<span class="string">"'"</span>+s+<span class="string">"'"</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 识别运算符 ：类别4</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s_operator.<span class="built_in">find</span>(x) != s_operator.<span class="built_in">end</span>()){</span><br><span class="line">        string s;</span><br><span class="line">        s.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="comment">// 识别 "&gt;=" 和 "&lt;="等两位的运算符</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;text.<span class="built_in">length</span>() &amp;&amp; d_operator.<span class="built_in">find</span>(s+text[i+<span class="number">1</span>]) != d_operator.<span class="built_in">end</span>()){</span><br><span class="line">            s+=text[i+<span class="number">1</span>];</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>,<span class="string">"'"</span>+s+<span class="string">"'"</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 识别标识符和保留字</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="string">'_'</span> || (x&gt;=<span class="string">'a'</span>&amp;&amp;x&lt;=<span class="string">'z'</span>) || (x&gt;=<span class="string">'A'</span>&amp;&amp;x&lt;=<span class="string">'Z'</span>)){</span><br><span class="line">        string s;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">is_identifier</span>(i)){                  <span class="comment">//获得完整的标识符或保留字</span></span><br><span class="line">            s.<span class="built_in">push_back</span>(text[i]);</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        i--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre_save.<span class="built_in">find</span>(s) != pre_save.<span class="built_in">end</span>()){     <span class="comment">// 识别保留字 ：类别1</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="string">"'"</span>+s+<span class="string">"'"</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{                                     <span class="comment">// 识别标识符 ： 类别2</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>,<span class="string">"'"</span>+s+<span class="string">"'"</span>));</span><br><span class="line">        }</span><br><span class="line">    } </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(ifstream &amp;file)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 从文件中读取代码，并将注释删掉  （预处理）</span></span><br><span class="line">    <span class="type">char</span> x,pre=<span class="string">' '</span>;                   <span class="comment">// 当前读取的字符，上一个字符</span></span><br><span class="line">    <span class="type">bool</span> comment=<span class="literal">false</span>;               <span class="comment">// 当前读取的内容是否为注释</span></span><br><span class="line">    <span class="keyword">while</span> (file&gt;&gt;x){  </span><br><span class="line">        <span class="comment">//cout&lt;&lt;pre&lt;&lt;" "&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(x==<span class="string">' '</span>||x==<span class="string">'\n'</span>){          <span class="comment">// 去掉空格和换行</span></span><br><span class="line">            <span class="keyword">if</span>(text.<span class="built_in">back</span>()!=<span class="string">' '</span>)text.<span class="built_in">push_back</span>(<span class="string">' '</span>);  <span class="comment">// 保留空格以便词法分析</span></span><br><span class="line">            pre=<span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pre==<span class="string">'/'</span> &amp;&amp; x==<span class="string">'*'</span>){  <span class="comment">// 识别到注释的开头</span></span><br><span class="line">            text.<span class="built_in">pop_back</span>();          <span class="comment">// 将已经读入的'/'从代码中删除</span></span><br><span class="line">            comment = <span class="literal">true</span>;</span><br><span class="line">            x=pre=<span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pre==<span class="string">'*'</span> &amp;&amp; x==<span class="string">'/'</span>){  <span class="comment">// 识别到注释的结尾</span></span><br><span class="line">            comment = <span class="literal">false</span>;</span><br><span class="line">            x=pre=<span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!comment &amp;&amp;pre==<span class="string">'/'</span> &amp;&amp; x==<span class="string">'/'</span>){ <span class="comment">//识别单行注释</span></span><br><span class="line">            text.<span class="built_in">pop_back</span>();</span><br><span class="line">            x=pre=<span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">while</span>(file&gt;&gt;x &amp;&amp; x!=<span class="string">'\n'</span>);</span><br><span class="line">            file&gt;&gt;x;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果不是注释，则将内容加入到代码段中</span></span><br><span class="line">        <span class="keyword">if</span>(!comment)</span><br><span class="line">            text.<span class="built_in">push_back</span>(x);</span><br><span class="line">        pre = x;                      <span class="comment">// 更新上一个字符</span></span><br><span class="line">    }   </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ifstream file;</span><br><span class="line">    string path = <span class="string">"C:\\Users\\admin\\Documents\\Code-Cpp\\Daily_Train\\2020.3.27_CiFa_exp_C--\\main.c"</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">"从"</span>&lt;&lt;path&lt;&lt;<span class="string">"中读取源代码..."</span>&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    file.<span class="built_in">open</span>(path);</span><br><span class="line">    file&gt;&gt;noskipws;                   <span class="comment">// 读取空格</span></span><br><span class="line">    <span class="keyword">if</span>(!file.<span class="built_in">is_open</span>()){</span><br><span class="line">        cout&lt;&lt;<span class="string">"打开文件失败！"</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中读取代码，并将注释删掉  （预处理）</span></span><br><span class="line">    <span class="built_in">process</span>(file);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出预处理后的源代码</span></span><br><span class="line">    cout&lt;&lt;<span class="string">"预处理后的源代码：\n"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:text){</span><br><span class="line">        <span class="keyword">if</span>(it!=<span class="string">' '</span>)cout&lt;&lt;it;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 词法分析</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;text.<span class="built_in">length</span>();i++){</span><br><span class="line">        <span class="built_in">analysis</span>(i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出词法分类结果</span></span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;<span class="string">"词法分类结果："</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:result){</span><br><span class="line">        <span class="comment">//cout&lt;&lt; name[it.first];  // 测试输出分类名称，可删</span></span><br><span class="line">        cout&lt;&lt;<span class="string">"("</span>&lt;&lt;it.first&lt;&lt;<span class="string">", "</span>&lt;&lt;it.second&lt;&lt;<span class="string">")\n"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>测试用例：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">/* }ewfnwesmlkwesmesf</span></span><br><span class="line"><span class="comment">    wefwefwe</span></span><br><span class="line"><span class="comment">    //    wefwefewf</span></span><br><span class="line"><span class="comment">    int */</span></span><br><span class="line">    <span class="type">int</span> a, <span class="comment">/*  wefwef   */</span> b;</span><br><span class="line">    a = <span class="number">010</span>; <span class="comment">// a+b=c</span></span><br><span class="line">    b = a + <span class="number">20</span>;</span><br><span class="line">    a += <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> _510;</span><br><span class="line">    <span class="type">int</span> intint;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!a &amp;&amp; a != <span class="number">8</span>)</span><br><span class="line">    {</span><br><span class="line">        b = <span class="number">510</span>;</span><br><span class="line">        a = b | <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span> &gt;= <span class="number">9</span> || a == <span class="number">6</span>)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// return hahahahaha; break</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} <span class="comment">////////</span></span><br></pre></td></tr></tbody></table></figure><p>结果太多只截了一部分图。<br><img src="//tvax1.sinaimg.cn/large/005JD0Ejgy1gd9j9gweimj31ly0y7n0d.jpg" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Alibaba在线笔试3.25</title>
      <link href="/2020/03/25/alibaba-zai-xian-bi-shi-3-25/"/>
      <url>/2020/03/25/alibaba-zai-xian-bi-shi-3-25/</url>
      
        <content type="html"><![CDATA[<h2 id="题目一-矩阵列差最小值"><a href="#题目一-矩阵列差最小值" class="headerlink" title="题目一   矩阵列差最小值"></a>题目一   矩阵列差最小值</h2><p>小强有一个 3 x n 的矩阵 a，他将 a 中每列的三个数字中取出一个按顺序组成一个长度为 n 的数组 b，即$b_i$可以是$a_{1,i} 、 a_{2,i} 、 a_{3,i}$其中任意一个。问$\sum_{i=0}^{n-1}|b_i-b_{i+1}|$的最小值是多少？</p><p><strong>输入描述</strong></p><blockquote><p>第一行，一个正整数n。<br>第二行到第四行输入一个 3 x n 的矩阵 a，每行输入 n个正整数。<br>$2&lt;=n&lt;=10^5, 1&lt;=a_{i,j}&lt;=10^9$</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>一行一个正整数表示答案</p></blockquote><p><strong>示例一</strong><br><strong>输入</strong></p><blockquote><p>5<br>5 9 5 4 4<br>4 7 4 10 3<br>2 10 9 2 3</p></blockquote><p><strong>输出</strong></p><blockquote><p>5</p></blockquote><p><strong>说明</strong></p><blockquote><p>数组 b 可以为[5,7,5,4,4]，答案是5.</p></blockquote><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>用回溯只过了30%的样例，这也是最直接的可以想到的方法。事后听说这题是用动态规划的，当时想的是贪心是肯定不能贪，把示例里的一三列调换一下就知道了，但是动态规划的话确实没思路，找不到最优子结构是什么，$n$等于1的时候答案是0，$n$等于2的时候是取两列中数字相差最小的，$n$等于3的时候就……这时候$n$等于3的解可能并不包括$n$等于2的时候，因为$n$等于2的时候又相当于是贪心了一次。</p><p>我曾经想最简的子问题会不会不是一列，看了题解，是用二维数组来保存 $dp$ 的状态，最小的子问题确实只有一列。</p><p><strong>为什么要用二维数组来保存状态呢？</strong><br>如果只看示例的前三列，可以发现除了$[5,7,5]$是最小的4，还有$[5,9,9]$也是最小的4，更进一步，如果前三列这个子问题扩展到前四列，可以发现这俩个子问题之间的关联就是前三列子问题的最后一列，取5或者取9或4会关系到后面的一列的取值。因此，共三行，取3种状态。</p><p>还有就是问题的规模，也需要一维来记录，所以得到 $dp$ 数组的格式：$dp[i][j]$，其中 i 表示第 $i$ 行；$j$ 则表示问题的规模 $1…n-1$。</p><blockquote><p>即$dp[i][j]$表示选择第 $i$ 行第 $j$ 列作为当前问题（规模为$j$）的解是能得到的最小值；</p></blockquote><p>于是有<strong>状态转移方程</strong>：</p><blockquote><p>$dp[i][j] = min(dp[k][j-1]+abs(nums[i][j]-nums[k][j-1])); k\in{0,1,2}$</p></blockquote><ul><li>$j=1..n-1$    </li><li>$i,k=0..2$</li></ul><p>其中，每列中的每一个取值视为一种状态。对于当前问题的每一种状态，都可能由规模减一的子问题的三种状态得来，每种状态加上原数组两状态的差值，取三个和中最小的即为当前问题当前状态的最优解。</p><ul><li>当前问题的每一种状态：$nums[i][j]$</li><li>规模减一的子问题：$dp[k][j-1]$，有三种状态$k=0,1,2$</li><li>当前问题当前状态：$dp[i][j] $</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll nums[<span class="number">3</span>][<span class="number">100001</span>], dp[<span class="number">3</span>][<span class="number">100001</span>];</span><br><span class="line">ll ans = LLONG_MAX;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nums[i][j]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 第一列初始化为0，最小的子问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        {</span><br><span class="line">            dp[i][j] = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[k][j - <span class="number">1</span>] + <span class="built_in">abs</span>(nums[i][j] - nums[k][j - <span class="number">1</span>]));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, dp[i][n - <span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="题目二-隐藏的等差数列矩阵"><a href="#题目二-隐藏的等差数列矩阵" class="headerlink" title="题目二 隐藏的等差数列矩阵"></a>题目二 隐藏的等差数列矩阵</h2><p>给出一个二维矩阵，这个矩阵的每一行和每一列都是一个独立的等差数列，但是其中的一些数字被隐藏住了，现在需要你进行推理将那些被隐藏但是可以被唯一确定的数字填上，然后来回答对某个位置上数字的询问。</p><p><strong>输入描述</strong></p><blockquote><p>第一行，n,m,q分别表示矩阵的行数，列数和查询的条数。<br>接下来的n行，每行m个数表示这个矩阵，0表示缺失数据。<br>接下来q行，每行两个数字i,j表示对矩阵中第i行第j列的数字进行查询。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>如果可以确定该位置的数字，则输出数字，如果不能确定则输出Unknown。</p></blockquote><p><strong>示例一</strong><br><strong>输入</strong></p><blockquote><p>2 3 6<br>1 0 3<br>0 0 0<br>1 1<br>1 2<br>1 3<br>2 1<br>2 2<br>2 3</p></blockquote><p><strong>输出</strong></p><blockquote><p>1<br>2<br>3<br>Unknown<br>Unknown<br>Unknown</p></blockquote><h2 id="None"><a href="#None" class="headerlink" title="None"></a>None</h2><p>下面这个暴力解法，只要每行有两个数就能复原这一行，每列有两个数就能复原这一列。估摸着也许能过30%的样例。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nums[<span class="number">502</span>][<span class="number">502</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n,m,q;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        <span class="comment">// 按行复原</span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">-1</span>,lval=<span class="number">0</span>,right=<span class="number">-1</span>,rval=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++){</span><br><span class="line">            cin &gt;&gt; nums[i][j];</span><br><span class="line">            <span class="keyword">if</span>(nums[i][j]){</span><br><span class="line">                <span class="keyword">if</span>(left == <span class="number">-1</span>){</span><br><span class="line">                    left = j;</span><br><span class="line">                    lval = nums[i][j];</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(right == <span class="number">-1</span>){</span><br><span class="line">                    right = j;</span><br><span class="line">                    rval = nums[i][j];</span><br><span class="line">                }</span><br><span class="line">            } </span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="number">-1</span> &amp;&amp; right!=<span class="number">-1</span>){</span><br><span class="line">            <span class="type">int</span> d = (rval-lval)/(right-left);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=left<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--){   <span class="comment">// 0..left</span></span><br><span class="line">                nums[i][j] = nums[i][j+<span class="number">1</span>]-d;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=left+<span class="number">1</span>;j&lt;right;j++){  <span class="comment">// left..right</span></span><br><span class="line">                nums[i][j] = nums[i][j<span class="number">-1</span>]+d;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=right+<span class="number">1</span>;j&lt;m;j++){  <span class="comment">// right..m</span></span><br><span class="line">                nums[i][j] = nums[i][j<span class="number">-1</span>]+d;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  按列复原 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++){</span><br><span class="line">        <span class="type">int</span> left=<span class="number">-1</span>,lval=<span class="number">0</span>,right=<span class="number">-1</span>,rval=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[i][j]){</span><br><span class="line">                <span class="keyword">if</span>(left == <span class="number">-1</span>){</span><br><span class="line">                    left = i;</span><br><span class="line">                    lval = nums[i][j];</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(right == <span class="number">-1</span>){</span><br><span class="line">                    right = i;</span><br><span class="line">                    rval = nums[i][j];</span><br><span class="line">                }</span><br><span class="line">            } </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="number">-1</span> &amp;&amp; right!=<span class="number">-1</span>){</span><br><span class="line">            <span class="type">int</span> d = (rval-lval)/(right-left);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=left<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){   <span class="comment">// 0..left</span></span><br><span class="line">                nums[i][j] = nums[i+<span class="number">1</span>][j]-d;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=left+<span class="number">1</span>;i&lt;right;i++){  <span class="comment">// left..right</span></span><br><span class="line">                nums[i][j] = nums[i<span class="number">-1</span>][j]+d;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=right+<span class="number">1</span>;i&lt;n;i++){  <span class="comment">// right..n</span></span><br><span class="line">                nums[i][j] = nums[i<span class="number">-1</span>][j]+d;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--){</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        x--; y--;</span><br><span class="line">        <span class="keyword">if</span>(nums[x][y])cout&lt;&lt;nums[x][y]&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            cout&lt;&lt;<span class="string">"Unknown"</span>&lt;&lt;endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针和引用</title>
      <link href="/2020/03/22/zhi-zhen-he-yin-yong/"/>
      <url>/2020/03/22/zhi-zhen-he-yin-yong/</url>
      
        <content type="html"><![CDATA[<p><strong>指针和引用是“指向”另外一种类型的复合类型，可以实现对其他对象的间接访问。</strong></p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><blockquote><ul><li>指针本身就是一个<strong>对象</strong>，允许对指针进行赋值和拷贝。在指针的生命周期里可以指向几个不同的对象。</li><li>指针不需要在定义时赋初值。</li></ul></blockquote><p>（对象是指一块能存储数据并具有某种类型的内存空间）</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>如果在一条语句中定义多个指针，则每个指针前面必须带有 *。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip1, *ip2;</span><br><span class="line"><span class="type">double</span> dp, *dp2;</span><br><span class="line"><span class="type">int</span> **ppi = &amp;ip1; <span class="comment">//指向指针的指针</span></span><br></pre></td></tr></tbody></table></figure><h3 id="获取对象的地址"><a href="#获取对象的地址" class="headerlink" title="获取对象的地址"></a>获取对象的地址</h3><p>指针存放着某个对象的地址，可以使用**取地址符 &amp;**来获取该地址，。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">// p 存放变量 ival 的地址，或者说 p 是指向变量 ival 的指针。</span></span><br></pre></td></tr></tbody></table></figure><h3 id="利用指针访问对象"><a href="#利用指针访问对象" class="headerlink" title="利用指针访问对象"></a>利用指针访问对象</h3><p>如果一个指针指向了一个对象，则允许使用**解引用符 ***来获得该对象：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; *p;  <span class="comment">// 输出 p 指向的对象的值</span></span><br></pre></td></tr></tbody></table></figure><p>对指针解引用会得到所指的对象，因此，如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*p = <span class="number">0</span>;     <span class="comment">// p 指向的对象的值 置为 0</span></span><br><span class="line">cout &lt;&lt; *p;</span><br></pre></td></tr></tbody></table></figure><h3 id="可以有空指针"><a href="#可以有空指针" class="headerlink" title="可以有空指针"></a>可以有空指针</h3><p>空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查指针是否为空。</p><p>生成空指针的方法：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">int</span> *p2 = <span class="number">0</span>;     <span class="comment">// 但是不能将一个整型0赋予指针</span></span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="指针值"><a href="#指针值" class="headerlink" title="指针值"></a>指针值</h3><p>指针的值（即地址）应属于以下四种状态之一：</p><ol><li>指向一个对象</li><li>指向紧邻对象所占空间的下一个位置。</li><li>空指针，意味着指针没有指向任何对象。</li><li>无效指针，也就是上述情况的其他值。（试图拷贝或以其他方式访问无效指针的值都将引起错误）</li></ol><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>给指针赋值就是给指针一个新的地址，从而指向一个新的对象：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *pi2 = &amp;i;</span><br><span class="line"><span class="type">int</span> *pi3;</span><br><span class="line"></span><br><span class="line">pi3 = pi2;</span><br><span class="line"></span><br><span class="line">*pi2 = <span class="number">510</span>;   <span class="comment">// i 变量的值改变   </span></span><br><span class="line">pi2 = <span class="number">0</span>;      <span class="comment">// pi2指针的值改变</span></span><br></pre></td></tr></tbody></table></figure><h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h3><p>void* 指针是一种特殊的指针类型，可用于存放任意对象的地址。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> obj = <span class="number">3.14</span>, &amp;pd = &amp;obj;</span><br><span class="line"><span class="type">void</span> *pv = &amp;obj;  <span class="comment">// obj 可以是任意类型的对象</span></span><br><span class="line">pv = pd;          <span class="comment">// pd 可以是任意类型的指针</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><figcaption><span>指针能做的事儿比较有限，包括：</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">* 拿它和别的指针比较。</span><br><span class="line">* 作为函数的输入或输出。</span><br><span class="line">* 赋给另外一个 ```void*``` 指针。</span><br><span class="line">* 不能直接操作 ```void*``` 指针所指的对象。</span><br><span class="line"></span><br><span class="line">以 ```void*``` 的视角来看，内存空间也仅仅是内存空间，没办法访问内存空间中所存的对象。</span><br><span class="line"></span><br><span class="line">## 引用</span><br><span class="line">引用就是为对象起另外一个名字，也就是别名。</span><br><span class="line"></span><br><span class="line">实际上，也可以把引用看做是通过一个指针常量来实现的，它只能绑定到初始化它的对象上。即，指向的地址不变，地址里的内容可以改变。（比如 ```int *const p;```) </span><br><span class="line"></span><br><span class="line">&gt; * 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。</span><br><span class="line">&gt; * 引用必须初始化，即必须赋初值。</span><br><span class="line"></span><br><span class="line">### 定义</span><br><span class="line">定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。</span><br><span class="line"></span><br><span class="line">允许在一条语句中定义多个引用，每一个引用标识都必须以符号 &amp; 开头：</span><br><span class="line">```cpp</span><br><span class="line">int i = 1024, i2 = 2048;</span><br><span class="line">int &amp;r = i, r2 = i2;</span><br><span class="line">int i3 = 1024, &amp;ri = i3;</span><br><span class="line">int &amp;r3 = i3, &amp;r4 = i2;</span><br></pre></td></tr></tbody></table></figure><ul><li>引用不是对象，不能定义引用的引用。</li><li>其他所有引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</li></ul><h3 id="引用即别名"><a href="#引用即别名" class="headerlink" title="引用即别名"></a>引用即别名</h3><p>定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。</p><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ol><li>指针有自己的一块空间，而引用只是一个别名；</li><li>使用 <code>sizeof</code>看一个指针的大小是4，而引用则是被引用对象的大小；</li><li>指针可以被初始化为<code>NULL</code>，而引用必须被初始化且必须是一个已有对象的引用；</li><li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</li><li>可以有<code>const</code>指针，但是没有<code>const</code>引用；</li><li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；</li><li>指针可以有多级指针<code>（**p）</code>，而引用只有一级；</li><li>指针和引用使用<code>++</code>运算符的意义不一样；</li><li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li></ol><h4 id="C-不可以返回局部变量的引用或指针"><a href="#C-不可以返回局部变量的引用或指针" class="headerlink" title="C++不可以返回局部变量的引用或指针"></a>C++不可以返回局部变量的引用或指针</h4><p>不能返回局部变量的引用或地址给引用或指针。事实上还是看该地址的位置是否在该函数的栈区，若是在栈区，函数调用结束，该地址就被释放了。尽管会出现栈地址上的值没被销毁的问题，可能是该栈区还没被其他的函数堆栈掉。</p><ol><li><strong>错误</strong>：尝试返回 a 的地址给引用变量，a是存在栈里的，函数结束调用栈被销毁。</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}      </span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>错误</strong>：尝试返回 a 的地址给指针，a是存在栈里的，函数结束调用栈被销毁。</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">}    </span><br></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>正确</strong>：函数在返回的时候，返回处产生一个临时对象，用于存放局部变量a的值的一份拷贝（变量a的右值的拷贝）</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}    </span><br></pre></td></tr></tbody></table></figure><ol start="4"><li><strong>正确</strong>：因为返回的不是该函数的栈地址，而是静态存储区的地址。函数返回处产生一个对返回对象的“左值”s的拷贝，也就是在“左值”拷贝中存储了指向字符串常量1sfsdg的地址</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> *s = <span class="string">"1sfsdg"</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">//返回的是1sfsdg的地址，1sfsdg存储在字符常量区，也就在静态存储区。</span></span><br><span class="line">    <span class="comment">//而指针变量s的地址&amp;s是在栈上，会随着函数的调用完被销毁。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li><strong>错误</strong>：静态数组，在预处理阶段就在该函数的栈上分配了空间，尝试返回一个栈地址</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>]  = {.......}；<span class="comment">//静态数组</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="6"><li><strong>正确</strong>：动态数组数组的空间在堆上，而指针变量a的地址&amp;a在栈上，占4个字节，存储着堆上动态数组的首地址。</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  *<span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">    <span class="comment">//变量a的左值是一个局部变量指针，存储于函数栈上，</span></span><br><span class="line">    <span class="comment">//右值 是“堆”的地址（“堆”的值是数组里面存的 值），</span></span><br><span class="line">    <span class="comment">//函数返回处产生一个对返回变量的“左值”a的拷贝，</span></span><br><span class="line">    <span class="comment">//也就是在“左值”的拷贝中存储了指向“堆”的地址。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/2020/03/21/zhi-neng-zhi-zhen/"/>
      <url>/2020/03/21/zhi-neng-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>内存知识回顾</strong></p><ul><li>静态内存用来保存局部static对象、 类 static数据成员以及定义在任何函数之外的变量（全局变量）。</li><li>栈内存用来保存定义在函数内的非 static 对象。</li><li>除了静态内存和栈内存外，每个程序还有一个内存池，这部分内存被称为<strong>自由空间</strong>或者<strong>堆</strong>。程序用堆来存储<strong>动态分配</strong>的对象，即那些在程序运行时分配的对象，当动态对象不再使用时，我们的代码必须显式的销毁它们。</li></ul><p>在C++中，动态内存的管理是用一对运算符完成的：new和delete。<strong>new</strong>:在动态内存中为对象分配一块空间并返回一个指向该对象的指针；<strong>delete</strong>：指向一个动态独享的指针，销毁对象，并释放与之关联的内存。</p><p>动态内存管理经常会出现两种问题：一种是忘记释放内存，会造成内存泄漏；一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。</p><p>为了更加容易（更加安全）的使用动态内存，新的标准库提供了<strong>两种智能指针</strong>(smart pointer)类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。标准库提供的<strong>两种智能指针的区别在于管理底层指针的方法不同</strong>，<strong>shared_ptr</strong>允许多个指针指向同一个对象，<strong>unique_ptr</strong>则“独占”所指向的对象。标准库还定义了一种名为<strong>weak_ptr</strong>的伴随类，它是一种弱引用，指向shared_ptr所管理的对象，这三种智能指针都定义在memory头文件中。</p><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>智能指针也是一个模板，因此创建一个指针时必须提供额外的信息，即指针可以指向的类型。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1;   <span class="comment">// shared_ptr，可以指向string</span></span><br><span class="line">shared_ptr&lt;list&lt;<span class="type">int</span>&gt;&gt; p2; <span class="comment">// shared_ptr，可以指向int的list</span></span><br></pre></td></tr></tbody></table></figure><p>默认初始化的智能指针中保存着一个空指针。</p><h3 id="智能指针的使用方式与普通指针类似"><a href="#智能指针的使用方式与普通指针类似" class="headerlink" title="智能指针的使用方式与普通指针类似"></a>智能指针的使用方式与普通指针类似</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果p1不为空，检查它是否指向一个空string</span></span><br><span class="line"><span class="keyword">if</span>(p1 &amp;&amp; p1-&gt;<span class="built_in">empty</span>()){</span><br><span class="line">  *p1 = <span class="string">"hi"</span>;   <span class="comment">// 如果p1指向一个空string，解引用p1，将一个新值赋予string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="智能指针支持的操作与独有操作"><a href="#智能指针支持的操作与独有操作" class="headerlink" title="智能指针支持的操作与独有操作"></a>智能指针支持的操作与独有操作</h3><p><img src="//tva2.sinaimg.cn/large/005JD0Ejgy1gd208br7vuj313c0vjx06.jpg" alt="支持的操作"></p><h3 id="make-shared函数"><a href="#make-shared函数" class="headerlink" title="make_shared函数"></a>make_shared函数</h3><p>最安全的分配和使用动态内存的方法就是调用一个名为<code>make_shared</code>的标准库函数，此函数在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code>。头文件和share_ptr相同，在memory中。</p><p>当要用 <code>make_shared</code> 时，<strong>必须指定想要创建的对象的类型</strong>。定义方式与模板类相同，<br>在函数名之后跟一个尖括号 ， 在其中给出类型：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向一个值为 42 的 int 的 shared_ptr</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// p4 指向一个值为” 9999999999 ” 的 string</span></span><br><span class="line">shared_ptr&lt;string&gt; p4 = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>,<span class="string">'9'</span>);</span><br><span class="line"><span class="comment">// p5 指向一个值初始化的int, 值为 0</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p5 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line"><span class="comment">// p6 指向一个动态分配的空 vector&lt;string&gt;</span></span><br><span class="line"><span class="keyword">auto</span> p6 = make_shared&lt;<span class="built_in">vector</span>&lt;string&gt; () ;</span><br></pre></td></tr></tbody></table></figure><p>类似顺序容器的 emplace 成员， <code>make_shared</code> 用其参数来构造给定类型的对象。如果我们不传递任何参数，对象就会进行值初始化。</p><p>例如，调用 <code>make_shared&lt;string&gt;</code>时传递的参数必须与 string 的某个构造函数相匹配，调用 <code>make_shared&lt;int&gt;</code>时传递的参数必须能用来初始化一个 int，依此类推。</p><blockquote><p>emplace 函数在容器中直接构造元素, 而不是拷贝。传递给 emplace 函数的参数必须与元素类型的构造函数相匹配。</p></blockquote><h3 id="shared-ptr的拷贝和赋值"><a href="#shared-ptr的拷贝和赋值" class="headerlink" title="shared_ptr的拷贝和赋值"></a>shared_ptr的拷贝和赋值</h3><p>当进行拷贝和赋值时，每个shared_ptr都会记录1有多少个其他shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// p 指向的对象只有 p 一个引用者</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>;             <span class="comment">// p 和 q 指向相同对象，此对象有两个引用者</span></span><br></pre></td></tr></tbody></table></figure><p>我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为<strong>引用计数</strong>，无论何时我们拷贝一个shared_ptr，计数器都会递增。</p><p>例如，当用一个 shared ptr 初始化另一个 shared ptr，或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递增。</p><p>当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域）时，计数器就会递减。</p><p>一旦一个shared_ptr的计数器变为0,它就会自动释放自己所管理的对象。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">//r指向的int只有一个引用者</span></span><br><span class="line">r = q;  <span class="comment">//给r赋值，令它指向另一个地址</span></span><br><span class="line">        <span class="comment">//递增q指向的对象的引用计数</span></span><br><span class="line">        <span class="comment">//递减r原来指向的对象的引用计数</span></span><br><span class="line">        <span class="comment">//r原来指向的对象已没有引用者，会自动释放</span></span><br></pre></td></tr></tbody></table></figure><p>此例中我们分配了一个 int，将其指针保存在 r 中。接下来，我们将一个新值赋予 r。在此情况下，r 是唯一指向此 int 的 shared_ptr，在把 q 赋给 r 的过程中，此 int 被自动释放。</p><h3 id="shared-ptr自动销毁所管理的对象"><a href="#shared-ptr自动销毁所管理的对象" class="headerlink" title="shared_ptr自动销毁所管理的对象"></a>shared_ptr自动销毁所管理的对象</h3><p>当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象，它是通过另一个特殊的成员函数——<strong>析构函数</strong>完成销毁工作的。</p><p>类似于构造函数，每个类都有一个析构函数。析构函数控制对象销毁时做什么操作。析构函数一般用来释放对象所分配的资源。</p><p>shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它所占用的内存。</p><h3 id="shared-ptr-还会自动释放相关联的内存"><a href="#shared-ptr-还会自动释放相关联的内存" class="headerlink" title="shared_ptr 还会自动释放相关联的内存"></a>shared_ptr 还会自动释放相关联的内存</h3><p>当动态对象不再被使用时，shared_ptr类还会自动释放动态对象，这一特性使得动态内存的使用变得非常容易。</p><p>如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。</p><h3 id="使用了动态生存期的资源的类："><a href="#使用了动态生存期的资源的类：" class="headerlink" title="使用了动态生存期的资源的类："></a>使用了动态生存期的资源的类：</h3><p>程序使用动态内存的原因：<br>（1）程序不知道自己需要使用多少对象<br>（2）程序不知道所需对象的准确类型<br>（3）程序需要在多个对象间共享数据</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>某个时刻只能有一个unique_ptr指向一个给定对象.</p><p>由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作。</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>类似 shared_ptr，初始化 unique_ptr 必须采用直接初始化形式：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="type">double</span>&gt; p1;    <span class="comment">// 可以指向一个 double 的 unique_ptr</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">// p2 指向一个值为 42 的 int</span></span><br></pre></td></tr></tbody></table></figure><h3 id="支持的操作"><a href="#支持的操作" class="headerlink" title="支持的操作"></a>支持的操作</h3><p><img src="//tva4.sinaimg.cn/large/005JD0Ejgy1gd2l5yytuwj315e0hywr8.jpg" alt="支持的操作"></p><h3 id="不支持拷贝和赋值，但能转移"><a href="#不支持拷贝和赋值，但能转移" class="headerlink" title="不支持拷贝和赋值，但能转移"></a>不支持拷贝和赋值，但能转移</h3><p>虽然我们不能拷贝或者赋值unique_ptr，但是可以通过调用release或reset将指针所有权从一个（非const）unique_ptr转移给另一个unique:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将所有权从p1（指向string Stegosaurus）转移给p2</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;   <span class="comment">//release将p1置为空，但不会释放内存</span></span><br><span class="line">unique_ptr&lt;string&gt;<span class="built_in">p3</span>(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Trex"</span>));</span><br><span class="line"><span class="comment">//将所有权从p3转移到p2</span></span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>());  <span class="comment">//reset释放了p2原来指向的内存</span></span><br></pre></td></tr></tbody></table></figure><ul><li>reset 成员接受一个可选的指针参数，令 unique_ptr 重新指向给定的指针。如果unique_ptr 不为空，它原来指向的对象被释放.</li><li>调用 release 会切断 unique_ptr 和它原来管理的对象间的联系。 release 返回 的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。</li></ul><h3 id="传递-unique-ptr-参数和返回-unique-ptr"><a href="#传递-unique-ptr-参数和返回-unique-ptr" class="headerlink" title="传递 unique_ptr 参数和返回 unique_ptr"></a>传递 unique_ptr 参数和返回 unique_ptr</h3><p>不能拷贝unique_ptr有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr.最常见的例子是从函数返回一个unique_ptr:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//正确：从int*创建一个unique_ptr&lt;int&gt;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(p));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还可以返回一个局部对象的拷贝：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(p))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于两段代码，编译器都知道耍返回的对象将要被销毁。在此情况下，编译器执行一种特殊的“拷贝”。</p><h3 id="向-unique-ptr-传递删除器"><a href="#向-unique-ptr-传递删除器" class="headerlink" title="向 unique_ptr 传递删除器"></a>向 unique_ptr 传递删除器</h3><p>类似 shared_ptr, unique_ptr 默认情况下用 delete 释放它指向的对象。与<br>shared_ptr 一样，我们可以重载一个 unique_ptr 中默认的删除器。但是， unique_ptr 管理删除器的方式与 shared_ptr 不同。</p><p>重载一个 unique_ptr 中的删除器会影响到 unique_ptr 类型以及如何构造（或reset）该类型的对象。</p><p>与重载关联容器的比较操作类似，我们必须在尖括号中 unique ptr 指向类型之后提供删除搭类型。在创建或 reset 一个 这种 unique ptr 类型的对象时，必须提供一个指定类型的可调用对象（删除器）：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 指向一个类型为 objT 的对象， 并使用一个类型为 delT 的对象释放 objT 对象 </span></span><br><span class="line"><span class="comment">// 它会调用一个名为 fcn 的 delT 类型对象 </span></span><br><span class="line"><span class="function">unique_ptr&lt;objT , delT&gt; <span class="title">p</span> <span class="params">(<span class="keyword">new</span> objT , fcn)</span> </span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>向后兼容：<br>auto_ptr 标准库的较早版本包含了 一个名为 auto_ptr 的类，它具有 unique_ptr 的部分特性，但不是全部。特别是，我们不能在容器中保存 auto_ptr，也不能从函数中返回auto_ptr。<br>虽然 auto_ptr 仍是标准库的一部分，但编写程序时应该使用 unique_ptr。</p></blockquote><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr 是一种不控制所指向对象生存期的智能指针，它指向一个由 shared_ptr 管理的对象，将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数。</p><p>一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放，即使有 weak_ptr 指向对象，对象还是会被释放。因此，weak_ptr 的名字抓住了这种智能指针“弱”共享对象的特点。</p><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>当我们创建一个 weak_ptr 时，要用一个 shared_ptr 来初始化它：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>); </span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>;  <span class="comment">// wp 弱共享 p; p 的引用计数未改变</span></span><br></pre></td></tr></tbody></table></figure><h3 id="支持的操作-1"><a href="#支持的操作-1" class="headerlink" title="支持的操作"></a>支持的操作</h3><p><img src="//tva2.sinaimg.cn/large/005JD0Ejgy1gd2m82j2juj315c0ikqfo.jpg" alt="支持的操作"></p><p>由于对象可能不存在，我们不能使用 weak_ptr 直接访问对象，而必须调用 lock。此函数检查 weak_ptr 指向的对象是否仍存在。如果存在，lock 返回一个指向共享对象的 shared_ptr。</p><p>与任何其他 shared_ptr 类似，只要此 shared_ptr 存在，它所指向的底层对象也就会一直存在。例如：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(shared_ptr&lt;<span class="type">int</span>&gt; np = wp.<span class="built_in">lock</span>()){ <span class="comment">// 如果 np 不为空则条件成立</span></span><br><span class="line">  <span class="comment">// 在 if 中，np 与 p 共享对象。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="解决循环引用问题"><a href="#解决循环引用问题" class="headerlink" title="解决循环引用问题"></a>解决循环引用问题</h3><p>如果有两个或者以上的对象，它们彼此引用，就会造成循环引用。</p><ul><li>原理：weak_ptr 的构造和析构不会引起引用计数的增加或减少.</li></ul><p>存在循环引用的示例1：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>{</span><br><span class="line">    T _value;</span><br><span class="line">    std::shared_ptr&lt;ListNode&gt; _prev;</span><br><span class="line">    std::shared_ptr&lt;ListNode&gt; _next;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">const</span> T &amp; value)</span><br><span class="line">        :_value(value)</span><br><span class="line">        {}</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">ListNode</span>(){</span><br><span class="line">        std::cout&lt;&lt;<span class="string">"~ListNode()"</span>&lt;&lt;std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestWeekPtr</span><span class="params">()</span></span>{</span><br><span class="line">    std::shared_ptr&lt;ListNode&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sp1</span>(<span class="keyword">new</span> <span class="built_in">ListNode</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>));</span><br><span class="line">    std::shared_ptr&lt;ListNode&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sp2</span>(<span class="keyword">new</span> <span class="built_in">ListNode</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>));</span><br><span class="line">    sp1-&gt;_next = sp2;</span><br><span class="line">    sp2-&gt;_prev = sp1;</span><br><span class="line">    <span class="comment">//构成死锁,出了函数作用域,也没有调用析构函数</span></span><br><span class="line">    std::cout&lt;&lt;sp1.<span class="built_in">use_count</span>()&lt;&lt;std::endl;  <span class="comment">//sp1的引用计数</span></span><br><span class="line">    std::cout&lt;&lt;sp2.<span class="built_in">use_count</span>()&lt;&lt;std::endl;  <span class="comment">//sp2的引用计数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解决：将类中的 _prev 和 _next 的类型（或其中一个）换成 weak_ptr。 </p><p>解决循环引用的示例2：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; bptr;</span><br><span class="line">    ~<span class="built_in">A</span>(){cout&lt;&lt;<span class="string">"A is destroy!"</span>&lt;&lt;endl;}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>{</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    weak_ptr&lt;A&gt; aptr;</span><br><span class="line">    ~<span class="built_in">B</span>(){cout&lt;&lt;<span class="string">"B is destroy!"</span>&lt;&lt;endl;}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestWeakPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B)</span></span>;</span><br><span class="line">    pa-&gt;bptr = pb;</span><br><span class="line">    pb-&gt;aptr = pa;</span><br><span class="line">    cout&lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout&lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alibaba在线笔试3.20</title>
      <link href="/2020/03/20/alibaba-zai-xian-bi-shi-3-20/"/>
      <url>/2020/03/20/alibaba-zai-xian-bi-shi-3-20/</url>
      
        <content type="html"><![CDATA[<h2 id="题目一-扑克牌"><a href="#题目一-扑克牌" class="headerlink" title="题目一 扑克牌"></a>题目一 扑克牌</h2><p>今天小强从一副扑克牌里拿出一叠，其中包括A,2,3,…,10，各四张，其中A代表1。他从这一叠中抽出一些牌给小明，并告诉小明每次可以按照下列方式打出一些牌：</p><ul><li>单牌：一张牌，例如3.</li><li>对子：数字相同的两张牌，例如77</li><li>顺子：数字连续的五张牌，例如A2345.</li><li>三连对：例如112233</li></ul><p>现在小强想知道最少打出多少次牌可以打光手里的牌。</p><p><strong>输入描述</strong></p><blockquote><p>一行十个空格分隔的整数$A_1$,$A_2$,$A_3$,…,$A_{10}$，分别代表为A,2,3,…,10的个数。<br>$0&lt;=A_1,A_2,…，A_{10}&lt;=4$<br>保证手里至少有一张牌</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>仅一行表示答案。</p></blockquote><p><strong>示例1</strong><br><strong>输入</strong></p><blockquote><p>1 1 1 2 2 2 2 2 1 1</p></blockquote><p><strong>输出</strong></p><blockquote><p>3</p></blockquote><p><strong>说明</strong></p><blockquote><p>打出了三个顺子，分别为：A2345,45678,678910。</p></blockquote><h2 id="回溯-剪枝"><a href="#回溯-剪枝" class="headerlink" title="回溯+剪枝"></a>回溯+剪枝</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> ans = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> cur)</span> <span class="comment">//检查是否有5张连续的牌</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cur; i &lt; cur + <span class="number">5</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == cnt[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> sum, <span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span> (cnt[cur] == <span class="number">0</span>)</span><br><span class="line">        cur++; <span class="comment">// 0张牌的不计</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if(sum&gt;ans)return ;  //剪枝  改成先判断再进入递归</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cur &gt;= <span class="number">10</span>) <span class="comment">// 递归出口，所有牌都打完</span></span><br><span class="line">    {</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, sum); <span class="comment">// 取最小</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cur+<span class="number">2</span> &lt;<span class="number">10</span> &amp;&amp; cnt[cur]&gt;=<span class="number">2</span> &amp;&amp; cnt[cur+<span class="number">1</span>]&gt;=<span class="number">2</span> &amp;&amp; cnt[cur+<span class="number">2</span>]&gt;=<span class="number">2</span>){<span class="comment">//打三连对</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=cur;i&lt;cur+<span class="number">3</span> ;i++){</span><br><span class="line">            cnt[i]-=<span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(sum+<span class="number">1</span>&lt;ans)</span><br><span class="line">            <span class="built_in">dfs</span>(sum+<span class="number">1</span>,cur);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=cur;i&lt;cur+<span class="number">3</span> ;i++){</span><br><span class="line">            cnt[i]+=<span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cur + <span class="number">4</span> &lt; <span class="number">10</span> &amp;&amp; <span class="built_in">check</span>(cur)) <span class="comment">// 连续打5张</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = cur; i &lt;= cur + <span class="number">4</span>; i++)</span><br><span class="line">        {</span><br><span class="line">            cnt[i]--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(sum+<span class="number">1</span>&lt;ans)</span><br><span class="line">            <span class="built_in">dfs</span>(sum + <span class="number">1</span>, cur);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = cur; i &lt;= cur + <span class="number">4</span>; i++)</span><br><span class="line">        {</span><br><span class="line">            cnt[i]++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cnt[cur] &gt;= <span class="number">2</span>) <span class="comment">//打两张一样的</span></span><br><span class="line">    {</span><br><span class="line">        cnt[cur] -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum+<span class="number">1</span>&lt;ans)</span><br><span class="line">            <span class="built_in">dfs</span>(sum + <span class="number">1</span>, cur);</span><br><span class="line">        cnt[cur] += <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cnt[cur] &gt; <span class="number">0</span>) <span class="comment">//打一张</span></span><br><span class="line">    {</span><br><span class="line">        cnt[cur]--;</span><br><span class="line">        <span class="keyword">if</span>(sum+<span class="number">1</span>&lt;ans)</span><br><span class="line">            <span class="built_in">dfs</span>(sum + <span class="number">1</span>, cur);</span><br><span class="line">        cnt[cur]++;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        cin &gt;&gt; cnt[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="题目二-最长旋律"><a href="#题目二-最长旋律" class="headerlink" title="题目二 最长旋律"></a>题目二 最长旋律</h2><p>小强喜欢弹钢琴，一段旋律中的每个音符都可以用一个小写英文字母来表示。当组成一段旋律的字符ASCII码是非递减的，旋律被称为高昂的，例如aaa,bcd。</p><p>现在小强已经学会了n段高昂的旋律，他想利用它们拼接出一个尽可能长的高昂旋律，问最长长度是多少？</p><p><strong>输入描述</strong></p><blockquote><p>第一行一个正整数n，含义如题目所述。<br>接下来n行每行一个字符串，保证每个字符串的字符的ASCII码是非递减的。<br>$1&lt;=n&lt;=10^6$<br>保证所有字符串的长度之和不超过$10^6$且仅由小写字母构成。</p></blockquote><p><strong>输出描述</strong></p><blockquote><p>仅一行一个整数代表答案</p></blockquote><p><strong>示例1</strong><br><strong>输入</strong></p><blockquote><p>4<br>aaa<br>bcd<br>zzz<br>bcdef</p></blockquote><p><strong>输出</strong></p><blockquote><p>11</p></blockquote><p><strong>说明</strong></p><blockquote><p>将1,4,3段字符串拼接到一起，长度为11。</p></blockquote><h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">26</span>][<span class="number">26</span>]{};</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> x = s[<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="type">int</span> y = s.<span class="built_in">back</span>()-<span class="string">'a'</span>;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=x ;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">25</span>; j&gt;=y ;j--){</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][x]+len+dp[y][j]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;dp[<span class="number">0</span>][<span class="number">25</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆、栈和静态存储区</title>
      <link href="/2020/03/19/dui-zhan-he-jing-tai-cun-chu-qu/"/>
      <url>/2020/03/19/dui-zhan-he-jing-tai-cun-chu-qu/</url>
      
        <content type="html"><![CDATA[<p>C/C++程序经过编译链接后形成的二进制映像文件，这文件包含：</p><ul><li>栈</li><li>堆</li><li>数据段（只读数据段，已经初始化读写数据段，未初始化数据段即BBS）</li><li>代码段</li></ul><div align="center" width="35%"><img width="35%" src="//tva3.sinaimg.cn/large/005JD0Ejgy1gcznfj3owhj30jn0mk182.jpg" alt="内存"></div><blockquote><p>“在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区”</p></blockquote><h2 id="静态存储区"><a href="#静态存储区" class="headerlink" title="静态存储区"></a>静态存储区</h2><p>数据段和代码段</p><p><strong>静态变量、常量、全局变量</strong>就是存放在静态存储区，他们在程序编译完成后就已经分配好了，生命周期持续至程序结束。</p><h2 id="动态存储区"><a href="#动态存储区" class="headerlink" title="动态存储区"></a>动态存储区</h2><p>栈和堆</p><p>在程序运行期间根据需要进行动态的分配存储空间的方式。存放<strong>函数形参变量（在调用函数时给形参分配存储空间），局部动态变量(auto register)，函数调用现场保护和返回地址等</strong>。</p><p><strong>自由存储区（free store）</strong><br>是C++两个动态内存区域之一，使用new和delete来予以分配和释放。在自由存储区（free store）中，对象的生存周期可以比存放它的内存区的生存周期短；这也就是说，我们可以获得一片内存区而不用马上对其进行初始化；同时，在对象被销毁之后，也不用马上收回其占用的内存区。在对象被销毁而其占用的内存区还未被收回的这段时间内，我们可以通过void*型的指针访问这片区域，但是其原始对象的非静态成员以及成员函数（即使我们知道了它们的地址）都不能被访问或者操纵。</p><blockquote><p>自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。</p></blockquote><h2 id="1-栈区-stack"><a href="#1-栈区-stack" class="headerlink" title="1.栈区(stack):"></a>1.栈区(stack):</h2><p>由<strong>编译器自动分配释放</strong>，存放<strong>函数的参数值，局部变量</strong>等值。其操作方式类似于数据结构中的栈。</p><h2 id="2-堆区-heap"><a href="#2-堆区-heap" class="headerlink" title="2.堆区(heap):"></a>2.堆区(heap):</h2><p>堆允许程序在运行时动态地申请某个大小的内存。存放<strong>动态变量</strong>。</p><p>即堆是通过 new 算符和 malloc 函数分配得到的空间。</p><p>一般由<strong>程序员分配释放</strong>，若程序员不释放，则可能会引起内存泄漏。</p><p>分配方式类似于链表。</p><p>要注意，虽然在特定的编译器里缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，</p><p>但是堆（heap）与自由存储区（free &nbsp; store）是不同的: 在某一个区域内被分配的内存不能在另一个区域内被安全的回收。</p><p>堆（heap）中被分配的内存一般用于对类对象进行placement-new的构造和explicit的析构。堆中对象的生存周期与自由存储区（free &nbsp; store）中的类似。</p><blockquote><p>堆是操作系统维护的一块内存</p></blockquote><blockquote><p>堆和栈在内存中分配位置，跟硬件架构和操作系统都有关系。<br>x86中栈都是由高地址向低地址分配，堆是由低地址向高地址分配，不过在 Windows 和 Linux 中堆和栈的位置相反，另外存放静态数据、代码的区域位置也有一些不同。<br>栈是属于线程的，每一个线程会有一个自己的栈。</p></blockquote><h2 id="3-代码段-text-："><a href="#3-代码段-text-：" class="headerlink" title="3.代码段(.text)："></a>3.代码段(.text)：</h2><p>存放函数体的二进制代码。可执行文件代码的内存映射。</p><p>所有的语句编译后会生成CPU指令存储在代码区.</p><h2 id="4-数据段："><a href="#4-数据段：" class="headerlink" title="4.数据段："></a>4.数据段：</h2><ul><li><p><strong>只读数据段：</strong><br>只读数据段是程序使用的一些不会被更改的数据，使用这些数据的方式类似查表式的操作，由于这些变量不需要更改，因此只需要放置在只读存储器中即可。一般是<strong>const修饰的变量以及程序中使用的文字常量</strong>一般会存放在只读数据段中。</p></li><li><p><strong>已初始化的读写数据段：</strong><br>已初始化数据是在程序中声明，并且具有初值的变量，这些变量需要占用存储器的空间，在程序执行时它们需要位于可读写的内存区域内，并且有初值，以供程序运行时读写。在程序中一般为<strong>已经初始化的全局变量，已经初始化的静态局部变量(static修饰的已经初始化的变量)</strong></p></li><li><p><strong>未初始化段（.BSS）：</strong><br>BSS段通常是指用来存放程序中<strong>未初始化的全局变量和静态变量</strong>的一块内存区域。<br>特点是可读写的，在程序执行之前BSS段会自动清0。</p></li></ul><p>未初始化数据是在程序中声明，但是没有初始化的变量，这些变量在程序运行之前不需要占用存储器的空间。与读写数据段类似，它也属于静态数据区。但是该段中数据没有经过初始化。未初始化数据段只有在运行的初始化阶段才会产生，因此它的大小不会影响目标文件的大小。在程序中一般是没有初始化的全局变量和没有初始化的静态局部变量。</p><blockquote><p>附加说明：<br>常量存储区（特殊的常量存储区，属于静态存储区）<br>　　1) 常量占用内存,只读状态,决不可修改<br>　　2) 常量字符串就是放在这里的，程序结束后由系统释放</p></blockquote><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>; <span class="comment">//已初始化的读写数据段</span></span><br><span class="line"><span class="type">char</span> *p1; <span class="comment">//未初始化段 .bss</span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> b;            <span class="comment">// 栈</span></span><br><span class="line"><span class="type">char</span> s[] = <span class="string">"abc"</span>; <span class="comment">// 栈</span></span><br><span class="line"><span class="type">char</span> *p2;         <span class="comment">// 栈</span></span><br><span class="line"><span class="type">char</span> *p3 = <span class="string">"123456"</span>;     <span class="comment">// 123456\0在常量区，p3在栈上。</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> c =<span class="number">0</span>；        <span class="comment">//全局（静态）初始化区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分配得来的10和20字节的区域就在堆区。</span></span><br><span class="line">p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">p2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(p1, <span class="string">"123456"</span>); <span class="comment">//123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNN卷积神经网络</title>
      <link href="/2020/03/19/cnn-juan-ji-shen-jing-wang-luo/"/>
      <url>/2020/03/19/cnn-juan-ji-shen-jing-wang-luo/</url>
      
        <content type="html"><![CDATA[<h2 id="卷积神经网络与传统多层神经网络"><a href="#卷积神经网络与传统多层神经网络" class="headerlink" title="卷积神经网络与传统多层神经网络"></a>卷积神经网络与传统多层神经网络</h2><p>传统意义上的多层神经网络是只有<strong>输入层、隐藏层、输出层</strong>。其中隐藏层的层数根据需要而定，没有明确的理论推导来说明到底多少层合适</p><p>卷积神经网络CNN，在原来多层神经网络的基础上，<strong>加入了更加有效的特征学习部分，具体操作就是在原来的全连接的层前面加入了部分连接的卷积层与池化层</strong>。卷积神经网络出现，使得神经网络层数得以加深，深度学习才能实现</p><blockquote><p>通常所说的深度学习，一般指的是这些CNN等新的结构以及一些新的方法（比如新的激活函数Relu等），解决了传统多层神经网络的一些难以解决的问题.</p></blockquote><h2 id="CNN发展历史"><a href="#CNN发展历史" class="headerlink" title="CNN发展历史"></a>CNN发展历史</h2><p>诞生的原因：</p><p>传统神经网络对于输入的数据X（X视为矩阵）维数太高，如果是一张32x32的灰度图片，一个神经元的权重w就需要32x32，为了提取足够丰富的特征，假设需要20个神经元，则权重W（W视为矩阵）的参数个数就是32x32x20=20480个，显示图片的维度不可能是32，可能是上千，那么W的个数就很容易到上亿，这显然太大了！所以我们需要一种可以显著降低计算量的机制，因此CNN孕育而生。</p><p>发展过程：</p><ul><li>网络结构加深</li><li>加强卷积功能</li><li>从分类到检测</li><li>新增功能模块<br><img src="//tva1.sinaimg.cn/large/005JD0Ejgy1gczi3mee70j315o0jq79y.jpg" alt="CNN历史"></li></ul><h2 id="CNN结构"><a href="#CNN结构" class="headerlink" title="CNN结构"></a>CNN结构</h2><p>神经网络(neural networks)的基本组成包括输入层、隐藏层、输出层。而<strong>卷积神经网络的特点</strong>在于隐藏层分为卷积层和池化层(pooling layer，又叫下采样层)以及激活层。每一层的作用：</p><ul><li>卷积层：通过在原始图像上平移来提取特征</li><li>激活层：增加非线性分割能力</li><li>池化层：压缩数据和参数的量，减小过拟合，降低网络的复杂度，（最大池化和平均池化）<br>为了能够达到分类效果，还会有一个全连接层(FC)也就是最后的输出层，计算损失进行分类（或回归）。</li></ul><h2 id="输入层"><a href="#输入层" class="headerlink" title="输入层"></a>输入层</h2><p>有三种常见的数据预处理方法：</p><ul><li>去均值（demean）</li><li>归一化</li><li>PCA/白化</li></ul><p>对于CNN来说，一般只会做去均值+归一化，尤其是我们输入的是图像数据，我们往往只做去均值，这是为了保持原图像数据的完整性，避免失真。图像数据从数学角度来看，就是不同维度的矩阵，经过去均值后，数据的数学特性更好，对称性更好。在我们用SGD（随机梯度下降法）进行迭代优化的时候，权重w(偏差b同理)初始化的随机值对迭代速度和结果没有影响（如果不demean可能会不收敛或者迭代优化速度慢）。</p><h2 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h2><p>对于卷积层，卷积层（Convolutional layer），卷积神经网络中<strong>每层卷积层由若干卷积单元(卷积核)组成</strong>，每个卷积单元的参数都是通过<strong>反向传播算法</strong>优化得到的。</p><p>卷积运算的<strong>目的是提取输入的不同特征</strong>，第一层卷积层可能只能提取一些低级的特征如边缘、线条和角等层级，更多层的网路能从低级特征中迭代提取更复杂的特征。</p><p><strong>什么是卷积核？</strong><br>本质就是一个<strong>很小的矩阵</strong>，如1<em>1，3</em>3，5*5等。卷积核会在原数据（很高维的大矩阵）上移动，其实就是一个个小的矩阵，在比它大很多的矩阵上移动（移动的步长一般是1，即一次移动1步），每次移动，做一次点乘，得到一个数字。该步骤会一直进行直至遍历完完整的大矩阵（原数据），如下图：</p><div align="center" width="75%"><img width="75%" src="//dbaplus.cn/uploadfile/2016/1013/20161013104034756.gif" alt="卷积核运算"></div><p><strong>卷积核权值共享</strong><br>这里运用了一种思想，我们称之<strong>局部关联，或者说是参数共享机制</strong>。每个神经元看做一个卷积核（又称之感受野，receptive field），<strong>卷积核对局部数据进行计算</strong>。其实很简单的理解，所谓参数共享，就是共享卷积核。不管你原来的数据长啥样，我就用这一组卷积核，一直移动计算，仅此而已。这么做的<strong>好处就是减少了传统神经网络无法解决的大计算量或者说参数数量太多的问题，并且同样可以提取原数据（如图像数据）的有效特征，并且由于计算量计算参数的减少，特征提取往往做的更好。</strong></p><p>卷积操作利用了<strong>图片空间上的局部相关性</strong>，这也就是CNN与传统神经网络或机器学习的一个最大的不同点，特征的自动提取。<br>这也就是为什么卷积层往往会有多个卷积核（甚至几十个，上百个），因为<strong>权值共享后意味着每一个卷积核只能提取到一种特征</strong>，为了增加CNN的表达能力，当然需要多个核。</p><h2 id="激活层"><a href="#激活层" class="headerlink" title="激活层"></a>激活层</h2><p><strong>作用：把卷积层输出结果做非线性映射</strong></p><div align="center" width="75%"><img width="75%" src="//tva2.sinaimg.cn/large/005JD0Ejgy1gcziisw4nhj30ss0i6thh.jpg" alt="非线性映射"></div><p>卷积网络结构采用激活函数。自从网络得到发展之后，大家发现原有的sigmoid这些激活函数并不能达到好的效果，所以采取新的激活函数。</p><div align="center" width="75%"><img width="75%" src="//tvax3.sinaimg.cn/large/005JD0Ejgy1gczij9ml20j30w60g90vz.jpg" alt="激活函数"></div><h2 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h2><p>又称Pooling层，主要的作用是压缩数据和参数的量（<strong>保持最显著的特征</strong>），通过去掉Feature Map中不重要的样本，进一步<strong>减少参数数量</strong>。Pooling的方法很多，通常采用<strong>最大池化</strong></p><ul><li>max_polling:取池化窗口的最大值</li><li>avg_polling:取池化窗口的平均值</li></ul><h2 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h2><p>又称FC层，前面的卷积和池化相当于做<strong>特征工程</strong>，最后的全连接层在整个卷积神经网络中起到“分类器”的作用。</p><ul><li>如果FC层作为最后一层，再加上softmax或者wx+b，则可以分别作为分类或回归的作用，即“分类器”或“回归器”的作用</li><li>如果作为倒数第2，3层的话，FC层的作用是信息融合，增强信息表达。</li></ul><h2 id="CNN优缺点"><a href="#CNN优缺点" class="headerlink" title="CNN优缺点"></a>CNN优缺点</h2><p>优点：</p><ul><li>共享卷积核，优化计算量</li><li>无需手动选取特征，训练好权重，即得特征</li><li>深层次的网络抽取图像信息丰富，表达效果好</li></ul><p>缺点： </p><ul><li>需要调参，需要大样本量， GPU等硬件依赖</li><li>物理含义不明确（可解释性不强）</li></ul><h2 id="keras-在新类上微调InceptionV3"><a href="#keras-在新类上微调InceptionV3" class="headerlink" title="keras: 在新类上微调InceptionV3"></a>keras: 在新类上微调InceptionV3</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.applications.inception_v3 <span class="keyword">import</span> InceptionV3</span><br><span class="line"><span class="keyword">from</span> keras.preprocessing <span class="keyword">import</span> image</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, GlobalAveragePooling2D</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建不带分类器的预训练模型</span></span><br><span class="line">base_model = InceptionV3(weights=<span class="string">'imagenet'</span>, include_top=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加全局平均池化层</span></span><br><span class="line">x = base_model.output</span><br><span class="line">x = GlobalAveragePooling2D()(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个全连接层</span></span><br><span class="line">x = Dense(<span class="number">1024</span>, activation=<span class="string">'relu'</span>)(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个分类器，假设我们有200个类</span></span><br><span class="line">predictions = Dense(<span class="number">200</span>, activation=<span class="string">'softmax'</span>)(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建我们需要训练的完整模型</span></span><br><span class="line">model = Model(inputs=base_model.<span class="built_in">input</span>, outputs=predictions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先，我们只训练顶部的几层（随机初始化的层）</span></span><br><span class="line"><span class="comment"># 锁住所有 InceptionV3 的卷积层</span></span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> base_model.layers:</span><br><span class="line">    layer.trainable = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译模型（一定要在锁层以后操作）</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">'rmsprop'</span>, loss=<span class="string">'categorical_crossentropy'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在新的数据集上训练几代</span></span><br><span class="line">model.fit_generator(...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在顶层应该训练好了，让我们开始微调 Inception V3 的卷积层。</span></span><br><span class="line"><span class="comment"># 我们会锁住底下的几层，然后训练其余的顶层。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让我们看看每一层的名字和层号，看看我们应该锁多少层呢：</span></span><br><span class="line"><span class="keyword">for</span> i, layer <span class="keyword">in</span> <span class="built_in">enumerate</span>(base_model.layers):</span><br><span class="line">   <span class="built_in">print</span>(i, layer.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们选择训练最上面的两个 Inception block</span></span><br><span class="line"><span class="comment"># 也就是说锁住前面249层，然后放开之后的层。</span></span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> model.layers[:<span class="number">249</span>]:</span><br><span class="line">   layer.trainable = <span class="literal">False</span></span><br><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> model.layers[<span class="number">249</span>:]:</span><br><span class="line">   layer.trainable = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们需要重新编译模型，才能使上面的修改生效</span></span><br><span class="line"><span class="comment"># 让我们设置一个很低的学习率，使用 SGD 来微调</span></span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD</span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=SGD(lr=<span class="number">0.0001</span>, momentum=<span class="number">0.9</span>), loss=<span class="string">'categorical_crossentropy'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们继续训练模型，这次我们训练最后两个 Inception block</span></span><br><span class="line"><span class="comment"># 和两个全连接层</span></span><br><span class="line">model.fit_generator(...)</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卷积神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new和malloc的区别</title>
      <link href="/2020/03/19/new-he-malloc-de-qu-bie/"/>
      <url>/2020/03/19/new-he-malloc-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>new和malloc都可以申请一段动态内存空间：</p><ul><li>new的使用<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 get_size 确定分配多少个 int</span></span><br><span class="line"><span class="type">int</span> *pia = <span class="keyword">new</span> <span class="type">int</span>[<span class="built_in">get_size</span>()];   <span class="comment">//pia 指向第一个 int</span></span><br></pre></td></tr></tbody></table></figure></li><li>malloc的使用<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同上，调用 get_size 确定分配多少个 int</span></span><br><span class="line"><span class="type">int</span> *pia = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">get_size</span>()*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></tbody></table></figure></li></ul><p>但二者存在区别：</p><h2 id="1-申请的内存所在位置不同"><a href="#1-申请的内存所在位置不同" class="headerlink" title="1. 申请的内存所在位置不同"></a>1. 申请的内存所在位置不同</h2><p>new操作符是  从<strong>自由储存区</strong>(free store)上  为对象  动态分配  内存空间  ，而malloc函数  从<strong>堆</strong>上  动态分配  内存空间。</p><blockquote><p>自由存储区是C++基于new操作符的一个抽象概念。其定义  是  凡是通过new操作符进行内存申请，该内存即为自由存储区。</p><p>堆  是操作系统的  术语  ，是操作系统所维护的一块特殊内存，用于程序的内存动态分配。在C语言中，使用malloc从堆上分配内存，然后使用free释放已经分配的内存。</p></blockquote><p><strong>那么，自由存储区  能否与  堆  等价？</strong> </p><ol><li>自由存储是C++中通过new与delete动态分配和释放对象的抽象概念，而堆（heap）是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。</li><li>new所申请的内存区域在C++中称为自由存储区。藉由堆实现的自由存储，可以说new所申请的内存区域在堆上。</li><li>堆与自由存储区还是有区别的，它们并非等价。</li></ol><p><a href="/2020/03/19/dui-zhan-he-jing-tai-cun-chu-qu/">关于堆、栈、静态存储区更详细的介绍</a></p><p><strong>placement new（定位 new）</strong><br>特殊地，经过重载的new运算符可以不为对象分配内存：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (place_address)  type</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在使用new关键字建立一个新的对象的时候，在编译器的第二步就是调用对象的构造函数生成类对象。这一步使用的就是placement new来实现的，即在取得了一块可以容纳指定类型对象的内存之后，在这块内存上构造一个对象。</span><br><span class="line"></span><br><span class="line">&gt; 如果要使用placement new， 需要包含头文件&lt;new&gt;或者&lt;new.h&gt;</span><br><span class="line"></span><br><span class="line">使用placement new的方法:</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">type *a = new (place_address) type;</span><br><span class="line">type *b = new (place_address) type (initializers);</span><br><span class="line">type *c = new (place_address) type [size];</span><br><span class="line">type *d = new (place_address) type [size] { braced initializer list };</span><br></pre></td></tr></tbody></table></figure><ul><li><code>place_address</code> 是个指针</li><li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li></ul><h2 id="2-返回类型的安全性不同"><a href="#2-返回类型的安全性不同" class="headerlink" title="2. 返回类型的安全性不同"></a>2. 返回类型的安全性不同</h2><ul><li>new操作符内存分配成功时，返回的是<strong>对象类型的指针</strong>，类型严格与对象严格匹配，无需进行类型转换，故new是符合类型安全性的操作符。</li><li>malloc内存分配成功时则是返回<strong>void</strong>*，需要进行强制类型转换成我们需要的类型。</li></ul><blockquote><p>类型安全很大程度上等价于内存安全，类型安全的代码不会试图分配自己没被授权的内存区域。</p></blockquote><h2 id="3-内存分配失败时的返回值"><a href="#3-内存分配失败时的返回值" class="headerlink" title="3. 内存分配失败时的返回值"></a>3. 内存分配失败时的返回值</h2><ul><li>new内存分配失败时，会抛出bad_alloc<strong>异常</strong>，它不会返回NULL;  </li><li>malloc分配内存失败时，则<strong>返回NULL</strong>。因此，在C语言中习惯在分配内存之后判断是否分配成功。<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a = (<span class="type">int</span> *) <span class="built_in">malloc</span>( <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span>( <span class="literal">NULL</span> == a)</span><br><span class="line">{</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="4-是否需要指定内存块大小"><a href="#4-是否需要指定内存块大小" class="headerlink" title="4. 是否需要指定内存块大小"></a>4. 是否需要指定内存块大小</h2><ul><li>new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息<strong>自动计算</strong></li><li>malloc<strong>需要显示地指出内存的尺寸</strong>，如上的  sizeof(int)</li></ul><h2 id="5-是否调用构造函数-析构函数"><a href="#5-是否调用构造函数-析构函数" class="headerlink" title="5. 是否调用构造函数/析构函数"></a>5. 是否调用构造函数/析构函数</h2><ul><li>new操作符来分配对象会经历3个步骤：</li></ul><ol><li>调用<code>operator new</code>函数（对于数组是<code>operator new[]</code>）分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象</li><li>编译器运行相应的<strong>构造函数</strong>以构造对象，并为其传入初值</li><li>对象构造完成后，返回一个指向该对象的指针</li></ol><ul><li>delete操作符释放对象内存经历2个步骤：</li></ul><ol><li>调用对象的<strong>析构函数</strong></li><li>编译器调用<code>operator delete</code> (或 <code>operator delete[]</code>)函数来释放内存空间。</li></ol><h2 id="6-对数组的处理"><a href="#6-对数组的处理" class="headerlink" title="6. 对数组的处理"></a>6. 对数组的处理</h2><ul><li>C++提供了 <code>new[]</code>和<code>delete[]</code>专门来处理数组类型。</li><li>至于malloc，它并不知道你在这块内存上要放数组还是啥东西，反正它就给你一块原始的内存，再给你一个内存的地址就完事了。所以在动态分配一个数组的内存，还需要<strong>手动指定数组的大小</strong>。</li></ul><h2 id="7-new与malloc是否可以相互调用"><a href="#7-new与malloc是否可以相互调用" class="headerlink" title="7. new与malloc是否可以相互调用"></a>7. new与malloc是否可以相互调用</h2><ul><li><code>operator new</code> 或 <code>operator delete</code> 的实现可以基于malloc</li><li>而malloc的实现不可以去调用new。</li></ul><p>下面是编写<code>operator new</code>和<code>operator delete</code>的一种简单方式：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">void</span>* mem=<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != mem)</span><br><span class="line">        reutrn mem;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* mem)</span><span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">free</span>(mem);  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="8-是否可以被重载"><a href="#8-是否可以被重载" class="headerlink" title="8. 是否可以被重载"></a>8. 是否可以被重载</h2><ul><li><code>operator new</code> / <code>operator delete</code>可以被重载。</li></ul><p>new 和 delete共有8个重载版本：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这些版本可能抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span></span>;</span><br><span class="line"><span class="type">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="type">void</span> * )</span><span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="type">void</span> * <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *<span class="number">0</span>）<span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">//这些版本承诺不抛出异常</span></span><br><span class="line"><span class="type">void</span> * <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="type">size_t</span> ,<span class="type">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="type">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>, <span class="type">nothrow_t</span>&amp; );</span><br><span class="line"><span class="type">void</span> * <span class="keyword">operator</span> <span class="built_in">delete</span> (<span class="type">void</span> *,<span class="type">nothrow_t</span>&amp; )<span class="keyword">noexcept</span>;</span><br><span class="line"><span class="type">void</span> * <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *<span class="number">0</span>,<span class="type">nothrow_t</span>&amp; ）<span class="keyword">noexcept</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>malloc / free 不允许重载</li></ul><h2 id="9-能否直观地重新分配内存"><a href="#9-能否直观地重新分配内存" class="headerlink" title="9. 能否直观地重新分配内存"></a>9. 能否直观地重新分配内存</h2><ul><li>malloc分配内存之后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配，以实现内存的扩充。<br>realloc函数先判断当前指针所指的内存是否有足够的连续空间。如果有，原地扩大可分配的内存地址。如果没有，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，最后释放原来的内存区域。</li><li>new 没有这样直观的配套函数来扩充内存。</li></ul><h2 id="10-用户处理内存分配不足"><a href="#10-用户处理内存分配不足" class="headerlink" title="10. 用户处理内存分配不足"></a>10. 用户处理内存分配不足</h2><ul><li>对于malloc，用户不能去编程决定不足以分配时要干什么事，只能看着malloc返回NULL。</li><li>对于new，内存分配失败，抛出异常之前，它会调用一个用户指定的错误处理函数，这就是new_handler。<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">{</span><br><span class="line">     <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>　　new_handler是一个指针类型，指向了一个没有参数没有返回值的函数，即为错误处理函数。为了指向错误处理函数，客户需要调用<code>set_new_handler</code>函数，它是声明于标准库里的函数。<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">{</span><br><span class="line">     <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p )</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="总结到一个表格"><a href="#总结到一个表格" class="headerlink" title="总结到一个表格"></a>总结到一个表格</h2><p>共有10个区别，如表格中所示：</p><div align="center" width="75%"><img width="75%" src="//tvax4.sinaimg.cn/large/005JD0Ejgy1gczgg9joirj30nt0n5whs.jpg" alt="new和malloc区别"></div><p>malloc 诞生于 C 语言，new 诞生于 C++ 语言，那么两者的区别中肯定有一些是基于 C 语言和 C++ 语言的区别的。</p><ul><li><p>C++语言是面向对象的，一个类型的实例就是一个对象，new 在分配内存时会调用构造函数构造出一个对象然后返回该对象的指针，正因为如此，返回的指针是那个对象类型的指针。</p></li><li><p>C 语言面向过程，malloc 则不管你要分配的内存空间里存放的是什么类型，反正它就给你分配一块原始的内存空间，因此你需要指定整个内存块的大小，不仅包括分配多少个该类型的空间，还要指定类型占多大，也就是使用 sizeof() 函数来确定，并且返回的指针是 void类型的，需要强制转换成需要的类型，因此也不会专门处理数组类型，而 new 则提供了 new[] 来处理数组类型。</p></li><li><p>C++ 语言引入了异常机制，是 C 语言的 setjmp 和 longjmp 函数的更加结构化的版本。故如果 new 分配内存时如果失败会抛出bad_alloc异常，并且在抛出异常之前可以执行用户设置的 handler 来执行错误处理函数。而 malloc 在分配内存失败时只会返回一个空指针 NULL。</p></li><li><p>C++ 语言支持重载，因此 new 函数也可以重载为可能抛出异常和承诺不会抛出异常的函数。此外，new 的实现可以基于 malloc。</p></li><li><p>C++ 还有一个名为自由存储区的抽象概念，new 所申请的内存区域在C++中称为自由存储区。如果由堆实现自由存储区，那么可以说 new 所申请的内存区域在堆上。</p></li><li><p>最后，在内存不足时，malloc有配套的 realloc 函数进行内存重新分配，而 new 则没有。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复原IP地址</title>
      <link href="/2020/03/16/fu-yuan-ip-di-zhi/"/>
      <url>/2020/03/16/fu-yuan-ip-di-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（leetcode-93-复原IP地址）"><a href="#题目（leetcode-93-复原IP地址）" class="headerlink" title="题目（leetcode 93. 复原IP地址）"></a>题目（<a href="https://leetcode-cn.com/problems/restore-ip-addresses/">leetcode 93. 复原IP地址</a>）</h2><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p><strong>示例:</strong></p><blockquote><p>输入: “25525511135”<br>输出: [“255.255.11.135”, “255.255.111.35”]</p></blockquote><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>从第一个数字出发，要么往后加一个数字，要么加一个<code>'.'</code>开始下一部分。当然，加够3个数字后只能加<code>'.'</code>。如果在递归的过程中发现不符合IP地址格式，那么把这条枝剪掉，退回上一层重新寻找。</p><p>嗯，思路很简单，但是需要注意的细节不少。<br><strong>问题：</strong></p><ol><li>IP地址：A.B.C.D  每一部分的字符串最大长度为3。</li><li>A、B、C、D都必须小于256。</li><li>这些ABCD都不能有前导0，比如 02.00.01.03。（卡样例”010010”）</li><li>剪枝：不能有连续的<code>'.'</code>、首尾不能有<code>'.'</code>、<code>'.'</code>最多出现三次。（调试时才发现）</li></ol><p>一开始用了布尔变量limit来限制小于256的范围，写了一堆才发现不能从百位到十位再到个位这样来判断，因为并不是所有的IP地址都是 xxx.xxx.xxx.xxx的格式，太傻了。</p><p>然后重写，每次将当前部分保存为数字，每次进入递归时判断是否小于等于255。然后就开始填坑之旅……<br><strong>解答：</strong></p><blockquote><ol><li>用一个整型cnt来记录长度，大于等于3时只能加<code>'.'</code>，否则加数字加<code>'.'</code>都行</li><li>整型one来记录当前部分的数值，每次进入递归函数时检查是否小于等于255。</li><li>在加数字前检查是否有前导0：当前数字是第2位且前面一位是0。</li><li>目前想到的是在加<code>'.'</code>前进行检查前一个字符是否位<code>'.'</code>，以及下标cur是否大于0。然后每次进入递归函数时检查递归深度deep是否大于3。</li></ol></blockquote><ul><li><p>递归出口：cur检查完字符串s且<code>'.'</code>出现了三次</p></li><li><p>字符串now表示到目前为止形成的IP地址。</p></li><li><p><strong>加数字操作：</strong><br>now加上当前检查的字符，下标cur加1，数字长度cnt加1，当前数字one乘10后加上当前字符代表的数字，递归深度deep不变。</p></li><li><p><strong>加<code>'.'</code>操作：</strong><br>now加上<code>'.'</code>，下标cur不变，数字长度cnt和当前数字one清零，递归深度加1。</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;string&gt; &amp;ans, <span class="type">const</span> string &amp;s, string now, <span class="type">int</span> cur, <span class="type">int</span> cnt, <span class="type">int</span> one, <span class="type">int</span> deep)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; s.<span class="built_in">length</span>() || deep &gt; <span class="number">3</span> || one &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur == s.<span class="built_in">length</span>() &amp;&amp; deep == <span class="number">3</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(now.<span class="built_in">back</span>()==<span class="string">'.'</span>)<span class="keyword">return</span> ;  <span class="comment">// 尾部不能有'.'</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(now);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur&gt;<span class="number">0</span> &amp;&amp; now.<span class="built_in">back</span>()!=<span class="string">'.'</span>)   <span class="comment">// 首部不能有'.'，且不能有2个连续'.'</span></span><br><span class="line">            <span class="built_in">solve</span>(ans, s, now + <span class="string">'.'</span>, cur, <span class="number">0</span>, <span class="number">0</span>, deep + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cnt&lt;<span class="number">3</span> &amp;&amp; !(cnt ==<span class="number">1</span> &amp;&amp; now.<span class="built_in">back</span>()==<span class="string">'0'</span>))    <span class="comment">//未有连续三个数字 且 不能有前导0</span></span><br><span class="line">            <span class="built_in">solve</span>(ans, s, now + s[cur], cur + <span class="number">1</span>, cnt + <span class="number">1</span>, one = one * <span class="number">10</span> + s[cur] - <span class="string">'0'</span>, deep);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="built_in">solve</span>(ans, s, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串相乘</title>
      <link href="/2020/03/14/zi-fu-chuan-xiang-cheng/"/>
      <url>/2020/03/14/zi-fu-chuan-xiang-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（leetcode-43-字符串相乘）"><a href="#题目（leetcode-43-字符串相乘）" class="headerlink" title="题目（leetcode 43. 字符串相乘）"></a>题目（<a href="https://leetcode-cn.com/problems/multiply-strings/">leetcode 43. 字符串相乘</a>）</h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: num1 = “2”, num2 = “3”<br>输出: “6”</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: num1 = “123”, num2 = “456”<br>输出: “56088”</p></blockquote><p><strong>说明：</strong><br>    1. num1 和 num2 的长度小于110。<br>    2. num1 和 num2 只包含数字 0-9。<br>    3. num1 和 num2 均不以零开头，除非是数字 0 本身。<br>    4. <strong>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</strong></p><h2 id="优化的竖式模拟"><a href="#优化的竖式模拟" class="headerlink" title="优化的竖式模拟"></a>优化的竖式模拟</h2><p>很容易可以想到直接按照竖式计算的方式来编写一个程序，但是竖式相乘不仅要计算乘积还要计算累积和，所以直接竖式模拟还要写一个计算两个字符串相加的函数。</p><p>通常，我们将乘数个位与完整的被乘数相乘，得到一个积，再将乘数十位与完整的被乘数相乘，以此类推…..最后将各个乘积相加。但是，其实将最后相加那一步分解到每次相乘的时候来执行，程序实现反而更简单。</p><p>比如，被乘数个位 与 乘数个位 相乘，由九九八十一知乘积最多只有两位。因此，每次相乘后只需要处理两个进位。<strong>需要注意的是，n位被乘数与m位乘数相乘，结果最多m+n位，而且最高位肯定不会出现需要进位的现象</strong>，因此，只需要考虑第一位的进位。</p><p>另外，就是下标怎么走的问题，由图可以很清楚地明白。其中 <code>i+j+1</code> 是第一位，<code>i+j</code>是第二位。</p><p><img src="//tva4.sinaimg.cn/large/005JD0Ejgy1gctbj61ybkj31xg1ab44s.jpg" alt="竖式优化"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>{</span><br><span class="line">        <span class="type">int</span> len1 = num1.<span class="built_in">length</span>(), len2 = num2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(num1 == <span class="string">"0"</span> || num2 == <span class="string">"0"</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(len1+len2,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len2<span class="number">-1</span>; i &gt;= <span class="number">0</span>;i--){</span><br><span class="line">            <span class="type">int</span> y = num2[i]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=len1<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">                <span class="type">int</span> x = num1[j]-<span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> sum = ans[i+j+<span class="number">1</span>] + x*y; <span class="comment">//将相乘的积和相加的和统一放在“个位”计算 </span></span><br><span class="line">                ans[i+j+<span class="number">1</span>] = sum%<span class="number">10</span>;</span><br><span class="line">                ans[i+j] += sum/<span class="number">10</span>;    <span class="comment">//最后，最高位m+n肯定不大于10，不用考虑进位</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        string answer = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;len1+len2; i++){</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; ans[i] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            answer+=(ans[i]+<span class="string">'0'</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP三次握手和四次挥手</title>
      <link href="/2020/03/12/tcp-san-ci-wo-shou-he-si-ci-hui-shou/"/>
      <url>/2020/03/12/tcp-san-ci-wo-shou-he-si-ci-hui-shou/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>我们知道tcp建立连接要进行“三次握手”，即交换三个分组。</p><p>首先，服务器必须准备好接受外来的连接。这通常是通过调用<code>socket</code>、<code>bind</code>和<code>listen</code>这3个函数来完成，我们称之为被动打开(passive open)。</p><p>三次握手流程如下：</p><ul><li>客户端向服务器发送一个SYN J。<blockquote><p>客户通过调用connect发起主动打开(active open)。这导致客户TCP发送一个SYN(同步)分节，它告诉服务器客户将在（待建立的）连接中发送的数据的初始序列号。通常SYN分节不携带数据，其所在IP数据报只含有一个IP首部、一个TCP首都及可能有的TCP选项。</p></blockquote></li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1。<blockquote><p>服务器必须确认（ACK）客户的SYN，同时自己也得发送一个SYN分节，它含有服务器将在同一连接中发送的数据的初始序列号。服务器在单个分节中发送 SYN 和对客户SYN的 ACK（确认）。</p></blockquote></li><li>客户端再向服务器发一个确认ACK K+1</li></ul><p>这就完了三次握手，但是这三次握手发生在socket的那几个函数中呢？请看下图：</p><div align="center" width="60%"><img width="60%" src="//tva4.sinaimg.cn/large/005JD0Ejgy1gctbsm9xt8j30c406ddfy.jpg" alt="socket中发送的TCP三次握手"></div><p>客户的初始序列号为 J，服务器的初始序列号为 K。ACK中的确认号是发送这<br>个ACK的一端所期待的下一个序列号。</p><p>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求并向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</p><blockquote><p>总结：客户端的connect在三次握手的第二次返回，而服务器端的accept在三次握手的第三次返回。</p></blockquote><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程：</p><ul><li>某个应用进程首先调用close主动关闭连接。这时TCP发送一个FIN M，表示数据发送完毕。</li><li>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认（ACK）。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li><li>接收到这个FIN的源发送端TCP对它进行确认。</li></ul><p>这样每个方向上都有一个FIN和ACK。</p><div align="center" width="55%"><img width="55%" src="//tva4.sinaimg.cn/large/005JD0Ejgy1gctbtt46saj30a606d74c.jpg" alt="socket中发送的TCP四次握手"></div>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据链路层</title>
      <link href="/2020/03/11/shu-ju-lian-lu-ceng/"/>
      <url>/2020/03/11/shu-ju-lian-lu-ceng/</url>
      
        <content type="html"><![CDATA[<p><strong>物理线路</strong><br>数据电路是一条点到点的，由传输信道及其两端的 DCE 构成的物理电路。</p><p><strong>数据链路</strong><br>在一条通信线路上传送数据时，除了一定有一条物理线路外，还必须有必要的通信协议来控制这些数据的传输。所以数据链路是在数据电路的基础上增加了传输控制功能构成的。</p><p>基本数据单元：帧</p><p>主要信道<br><strong>点对点信道：</strong></p><ul><li>点对点协议：用户计算机和ISP通信时所使用的协议。</li></ul><p><strong>广播信道：</strong></p><ul><li>硬件地址（物理地址，mac地址）</li><li>单播帧（unicast）（一对一）：收到的帧的mac地址与本站的硬件地址相同。</li><li>广播帧（broadcast）（一对全体）：发送给本局域网上所有站点的帧。</li><li>多播帧（multicast）（一对多）：发送给本局域网上一部分站点的帧。</li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>链路管理：</li><li>寻址：</li><li>帧同步（帧定界）：</li><li>透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符）。</li><li>流量控制：发送方发送数据的速率必须使接收方来得及接收。由于通信的随机性，会出现短时间内 大量数据到达某个节点的情况。当接收方来不及接收时，就必须及时控制发送方发送数据的 速率。这种功能称作流量控制(flow control)。</li><li>差错控制：降低误码率，广泛使用循环冗余检测。在计算机通信中，一般都要求有极低的比特差错率，以保证通信的可靠性和可用性。为 此，广泛地采用了编码技术进行差错控制。在数据链路层所用到的差错控制的方式主要是的检错重发和前向纠错。</li><li>数据和控制信息识别：</li></ul><h3 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h3><p>方法：数据信号的识别，特定字符或比特流的识别（分界符），外部信号状态的识别等。</p><h3 id="流量控制（重要）"><a href="#流量控制（重要）" class="headerlink" title="流量控制（重要）"></a>流量控制（重要）</h3><p>目的是发送方的数据能让接收方来得及收。</p><h4 id="停止-等待流量控制方式"><a href="#停止-等待流量控制方式" class="headerlink" title="停止-等待流量控制方式"></a>停止-等待流量控制方式</h4><p>每发一帧都要停下来等待确认。</p><ul><li>实用的停止-等待协议<div align="center" width="6" 0%=""><img width="60%" src="//tva2.sinaimg.cn/large/005JD0Ejgy1gcni1ghqwnj311j0s74l5.jpg" alt="实用的停止-等待"></div></li></ul><h4 id="滑动窗口控制方式"><a href="#滑动窗口控制方式" class="headerlink" title="滑动窗口控制方式"></a>滑动窗口控制方式</h4><ol><li><p><strong>连续ARQ</strong><br>如果出现差错，则从出现差错的数据帧开始全部重发。</p><blockquote><p><strong>关键点</strong>：gobackend<br>接收窗口尺寸恒等于1<br>发送窗口尺寸大于1,$且&lt;=2^n-1$ （用 n 个比特进行编号）</p></blockquote></li><li><p><strong>选择ARQ</strong><br>只重传出错的数据帧或计时器超时的数据帧。</p><blockquote><p>接收窗口尺寸大于1，且$&lt;= 2^n/2$<br>发送窗口尺寸也大于1，且$&lt;= 2^n/2$</p></blockquote></li></ol><ul><li>当$W_R=2^n/2$ 时， $W_T=2^n/2$</li></ul><h2 id="点对点信道的数据链路层协议"><a href="#点对点信道的数据链路层协议" class="headerlink" title="点对点信道的数据链路层协议"></a>点对点信道的数据链路层协议</h2><p>(PPP | PPPOE)拨号上网</p><h3 id="面向比特"><a href="#面向比特" class="headerlink" title="面向比特"></a>面向比特</h3><h3 id="面向字符"><a href="#面向字符" class="headerlink" title="面向字符"></a>面向字符</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引</title>
      <link href="/2020/03/11/shu-ju-ku-suo-yin/"/>
      <url>/2020/03/11/shu-ju-ku-suo-yin/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><p>数据库索引是为了增加查询速度而对表字段附加的一种标识，是对数据库表中一列或多列的值进行排序的一种结构。</p><p>DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ul><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>一般分为B+树索引和哈希索引。</p><ul><li><p>B+树索引：在B-tree上改进得到，其非叶子节点均为key值，叶子节点是key-data键值对。叶子节点前后相连且有序。</p></li><li><p>哈希索引：通过对key进行hash(crc/MD5/sha1/sha256…)而将记录存储在不同的bucket中，可以做到常数时间的查找，但要注意哈希冲突的避免（链表法、线性探测、二次探测、公共溢出区的方法）。其中MD5 128位，和sha1/256码都较长不太适合作为hash函数。默认无序。</p></li><li><p><strong>为什么有了B+树索引还要hash索引？</strong></p></li></ul><ol><li>B+树默认有序，hash默认无序，所以哈希索引无法用于排序；</li><li>哈希索引O(1)在速度上毋庸置疑要快于B+树近似O(logn);</li><li>哈希索引只能进行等值查询（因为他要计算hash(key)再去匹配）而B+树索引可以进行等值、部分前缀、范围查询；</li><li>底层实现结构不同：B+树是非线性结构，hash桶是线性结构。</li><li>对于某些场景如热点页/活跃查询页，需要借助哈希索引来实现快速查询。</li></ol><h2 id="索引越多越快？"><a href="#索引越多越快？" class="headerlink" title="索引越多越快？"></a>索引越多越快？</h2><p>索引并非是虚无缥缈的，是实实在在的一种数据结构（B+树/hash桶）要占内存、维护它要系统开销，一般的插入删除都要进行结构的调整，这要消耗时间，所以索引太多反而拖慢查找时间。有时候，见数据量不多时，建立索引还不如全表查询。索引加快了检索的速度，但是插入删除修改都需要DBMS动态更新内部索引结构，要耗费开销。</p><h2 id="添加索引原则"><a href="#添加索引原则" class="headerlink" title="添加索引原则"></a>添加索引原则</h2><ul><li>在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li><li>只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li><li>定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。</li><li>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li></ul><h2 id="在MySQL中具体使用"><a href="#在MySQL中具体使用" class="headerlink" title="在MySQL中具体使用"></a>在MySQL中具体使用</h2><p>……</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2020/03/10/duo-tai/"/>
      <url>/2020/03/10/duo-tai/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a>什么是多态？</h2><p>多态，就是指<strong>程序中定义的引用变量所指向的具体类型</strong>和<strong>通过该引用变量发出的方法调用</strong>在编程时并不确定，而是在程序运行时确定。</p><p>即一个引用变量到底会指向哪个类的实例对象，调用哪个类的实现方法，在程序运行期间才确定。</p><p>比如举一个静态多态的例子，就是我想写一个计算圆面积的函数，但是半径 R 的类型是不确定的，那么我可以通过函数模板将半径 R 的类型设为 T ，然后在程序运行时，调用对应半径的类型的函数版本，半径的类型可以是整型、浮点型、都变了型等等。静态多态是在编译时就能确定函数调用哪个运行版本。</p><h2 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h2><p>提高代码的可复用性。</p><h2 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h2><p>多态的实现主要分为<strong>静态多态</strong>和<strong>动态多态</strong>。</p><ul><li>静态多态主要是重载，在编译时就已经确定</li><li>动态多态是使用虚函数机制实现的，在运行期间动态绑定。</li></ul><h3 id="静态多态（重载、模板）"><a href="#静态多态（重载、模板）" class="headerlink" title="静态多态（重载、模板）"></a>静态多态（重载、模板）</h3><p>重载：函数名相同，但是参数列表不同（形参个数、类型），返回类型可以不同，在同一作用域中。<br>模板：使用模板实现参数多态性</p><h3 id="动态多态（虚函数）"><a href="#动态多态（虚函数）" class="headerlink" title="动态多态（虚函数）"></a>动态多态（虚函数）</h3><p><strong>为什么要有虚函数？</strong><br>对于某些函数，基类希望它的派生类各自定义适合自身的版本（也就是对其进行覆盖），此时基类就将这些函数声明为虚函数。</p><p><strong>如何声明虚函数?</strong><br>基类通过在其成员函数的声明语句之前加上关键字<code>virtual</code>使得该函数执行动态绑定（使用类的引用或指针调用虚成员函数）。任何构造函数之外的非静态函数都可以是虚函数。</p><p>关键字<code>virtual</code>只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数，可以不写<code>virtual</code>。</p><p>对于没有被声明为虚函数的成员函数，其解析过程发生在编译时，而非运行时。</p><p><strong>虚函数需要注意哪些点？</strong></p><ul><li><p>当我们通过具有一个普通类型（非引用非指针）的表达式调用函数时，在编译时就会将调用的版本确定下来。</p></li><li><p>相反的，当我们使用指针或引用调用虚函数时，编译器产生的代码直到运行时才能确定应该调用哪个版本。</p></li><li><p>使用域运算符可以强制执行虚函数的某个版本。</p></li><li><p>一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。同样，返回类型也要匹配，但是有一个例外，就是<strong>返回类型</strong>是类本身的指针或引用时。</p></li><li><p><code>override</code>关键字用于说明派生类中的虚函数。放在函数定义的圆括号之后。不能用于普通函数。</p></li><li><p><code>final</code>关键字用于说明任何尝试进行覆盖此函数的操作都会引起错误。除了<code>override</code>，还有在派生类重新定义一个与基类同名的带<code>final</code>的普通函数。</p></li><li><p>虚函数也拥有<strong>默认实参</strong>，如果我们通过基类引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行时的是派生类中的函数版本也是如此。</p></li></ul><h3 id="虚函数的实现"><a href="#虚函数的实现" class="headerlink" title="虚函数的实现"></a>虚函数的实现</h3><p>在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表（位于程序只读段），表中存放了虚函数的地址，实际的虚函数在代码段（.text）中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中的虚函数的时候，会将继承到的虚函数表中的地址替换为重新写的函数地址。</p><h3 id="虚函数和静态函数的区别"><a href="#虚函数和静态函数的区别" class="headerlink" title="虚函数和静态函数的区别"></a>虚函数和静态函数的区别</h3><p>虚函数不能是静态函数</p><ul><li>静态函数在编译的时候就已经确定了运行时机</li><li>虚函数在运行时动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存的开销。</li></ul><h3 id="虚函数与析构函数"><a href="#虚函数与析构函数" class="headerlink" title="虚函数与析构函数"></a>虚函数与析构函数</h3><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们新建一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p><p>C++的默认析构函数不是虚函数，是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有要当需要作为父类时，设置为虚函数。</p><h3 id="虚函数与纯虚函数"><a href="#虚函数与纯虚函数" class="headerlink" title="虚函数与纯虚函数"></a>虚函数与纯虚函数</h3><ul><li>虚函数是有具体实现的（包括空实现），其作用就是为了能让这个函数在它的子类是可被覆盖的。这样，编译器就可以在运行时绑定，达到多态。而，纯虚函数只是一个接口，是一个函数声明而已，具体实现必须由子类来完成。</li><li>对于有虚函数的基类，派生类在继承接口的同时也继承了基类的实现。而，纯虚函数关注的只是接口的统一性。</li><li>带纯虚函数的类称为抽象类，这种类不能直接生成对象，只能被继承并重写虚函数后，才能使用。抽象类的子类可以继续是抽象类，或者普通类。</li></ul><h3 id="模板类、成员模板、虚函数"><a href="#模板类、成员模板、虚函数" class="headerlink" title="模板类、成员模板、虚函数"></a>模板类、成员模板、虚函数</h3><ul><li>模板类中可以使用虚函数</li><li>一个类（普通类、类模板）的成员模板（本身是模板的成员函数）不能是虚函数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象(OPP)</title>
      <link href="/2020/03/09/mian-xiang-dui-xiang-opp/"/>
      <url>/2020/03/09/mian-xiang-dui-xiang-opp/</url>
      
        <content type="html"><![CDATA[<h2 id="OPP核心思想"><a href="#OPP核心思想" class="headerlink" title="OPP核心思想"></a>OPP核心思想</h2><p>三个核心思想是数据抽象、继承、和动态绑定。</p><ul><li><p>通过数据抽象，我们可以将类的接口和实现分离。</p></li><li><p>通过继承，可以定义相似的类型并对相似关系进行建模。这样，我们可以更容易地定义与其他类相似但不完全相同的类。</p></li><li><p>通过动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。在使用彼此相似的类编写程序时，我们可以在一定程度上忽略它们的区别。</p></li></ul><h3 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h3><p>数据抽象也是类的基本思想之一（另一个思想是封装）。数据抽象是一种依赖于接口和实现分离的编程（以及设计）技术。即仅向用户暴露接口而把具体实现隐藏起来的机制。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>通过继承联系到一起的类构成一种层次关系。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为运行时绑定。</p><p>在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时，将发生动态绑定。</p><h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>我们把具有继承关系的多个类型称为多态类型，因为我们能使用这些类型的“多种形式”而无须在意它们的差异。引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本所在。</p><p>当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类对象也可能是一个派生类对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断的依据是引用或指针所绑定的对象的真实类型。</p><p>另一方面，对非虚函数的调用在编译时进行绑定。</p><p>类似的，通过对象进行的函数（虚函数或非虚函数）调用也在编译时进行绑定。因为对象的类型是确定不变的，我们无论如何都不能令对象的动态类型与静态类型不一致。因此，通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上。</p><p>当且仅当通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不一致。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关系代数中的运算</title>
      <link href="/2020/03/08/guan-xi-dai-shu-zhong-de-yun-suan/"/>
      <url>/2020/03/08/guan-xi-dai-shu-zhong-de-yun-suan/</url>
      
        <content type="html"><![CDATA[<h2 id="传统的集合运算"><a href="#传统的集合运算" class="headerlink" title="传统的集合运算"></a>传统的集合运算</h2><p>并、交、差，和笛卡尔积。<br>并交差需要两个表的结构一致。</p><h2 id="专门的关系运算"><a href="#专门的关系运算" class="headerlink" title="专门的关系运算"></a>专门的关系运算</h2><ul><li>创建数据库<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="number">2</span>_4Student(Sno <span class="type">varchar</span>(<span class="number">10</span>),Sname <span class="type">varchar</span>(<span class="number">10</span>), Ssex <span class="type">varchar</span>(<span class="number">10</span>), Sage <span class="type">int</span>(<span class="number">3</span>), Sdept <span class="type">varchar</span>(<span class="number">3</span>)); </span><br></pre></td></tr></tbody></table></figure></li><li>插入数据<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="number">2</span>_4Student <span class="keyword">values</span>("201215121","LiYong","male", <span class="number">20</span>, "CS");</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="number">2</span>_4Student <span class="keyword">values</span>("201215122","LiuYi","female", <span class="number">19</span>, "CS");</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="number">2</span>_4Student <span class="keyword">values</span>("201215123","WangMin","female", <span class="number">18</span>, "MA");</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="number">2</span>_4Student <span class="keyword">values</span>("201215124","ZhangLi","male", <span class="number">19</span>, "IS");</span><br></pre></td></tr></tbody></table></figure></li><li>查看表<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="number">2</span>_4Student;</span><br></pre></td></tr></tbody></table></figure><div align="center" width="60%"><img width="60%" src="//tva4.sinaimg.cn/large/005JD0Ejgy1gcmhezpnw2j30ni08lgm5.jpg" alt="创建表"></div></li></ul><h3 id="选择（selection）"><a href="#选择（selection）" class="headerlink" title="选择（selection）"></a>选择（selection）</h3><p>可以选取出多个行。</p><ul><li><strong>例2.4  查询信息系 (IS 系）全体学生：</strong></li></ul><p>\[σ_{ Sdept=“ IS ” }(Student)\]</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="number">2</span>_4Student <span class="keyword">where</span> Sdept<span class="operator">=</span>"IS";</span><br></pre></td></tr></tbody></table></figure><div align="center" width="60%"><img width="60%" src="//tvax4.sinaimg.cn/large/005JD0Ejgy1gcmhpp8srij30oe06xaad.jpg" alt="例2.4"></div><ul><li><strong>例2.5 查询年龄小于 20 岁的学生：</strong></li></ul><p>\[σ_{ Sage&lt;20 }(Student)\]</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="number">2</span>_4Student <span class="keyword">where</span> Sage<span class="operator">&lt;</span><span class="number">20</span>;</span><br></pre></td></tr></tbody></table></figure><div align="center" width="60%"><img width="60%" src="//tvax3.sinaimg.cn/large/005JD0Ejgy1gcmhtv1u0zj30oe08c3z3.jpg" alt="例2.5"></div><h3 id="投影（Projection）"><a href="#投影（Projection）" class="headerlink" title="投影（Projection）"></a>投影（Projection）</h3><p>可以选取出多个列。</p><ul><li><strong>例2.6 查询学生的姓名和所在系，即求 Student 关系上学生姓名和所在系两个属性<br>上的投影：</strong></li></ul><p>\[Π_{ Sname,Sdept }(Student)\]</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sname,Sdept <span class="keyword">from</span> <span class="number">2</span>_4Student;</span><br></pre></td></tr></tbody></table></figure><div align="center" width="60%"><img width="60%" src="//tva3.sinaimg.cn/large/005JD0Ejgy1gcmi0z1gxtj30n509ht92.jpg" alt="例2.6"></div><ul><li><strong>例 2.7 查询学生关系 Student 中都有哪些系，即查询关系 Student 上所在系屈性上<br>的投影:</strong></li></ul><p>\[Π_{ Sdept }(Student)\]</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> Sdept <span class="keyword">from</span> <span class="number">2</span>_4Student;</span><br></pre></td></tr></tbody></table></figure><p>Student 关系原来有 4 个元组，而投影结果取消了重复的 CS 元 组，因此只有三个元组。</p><div align="center" width="60%"><img width="60%" src="//tva4.sinaimg.cn/large/005JD0Ejgy1gcmi860vlyj30nj08kaa9.jpg" alt="例2.7"></div><h3 id="连接（join）"><a href="#连接（join）" class="headerlink" title="连接（join）"></a>连接（join）</h3><p>将两个表进行拼接。</p><ul><li><strong>例 2.S8 表R 和 表S:</strong><div align="center" width="40%"><img width="40%" src="//tvax2.sinaimg.cn/large/005JD0Ejgy1gcmjggk7zfj30ga0k8js1.jpg" alt="R和S"></div></li></ul><p>等值连接：<br>当两个表某一属性相等时。会舍弃只出现在一个表中的项。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="number">2</span>_7R,<span class="number">2</span>_7S <span class="keyword">where</span> <span class="number">2</span>_7R.B<span class="operator">=</span><span class="number">2</span>_7S.B;</span><br></pre></td></tr></tbody></table></figure><div align="center" width="55%"><img width="55%" src="//tva4.sinaimg.cn/large/005JD0Ejgy1gcmjo1g00zj30pp09tt94.jpg" alt="等值连接"></div><p>非等值连接：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="number">2</span>_7R,<span class="number">2</span>_7S <span class="keyword">where</span> <span class="number">2</span>_7R.C<span class="operator">&lt;</span><span class="number">2</span>_7S.E;</span><br></pre></td></tr></tbody></table></figure><div align="center" width="55%"><img width="55%" src="//tvax1.sinaimg.cn/large/005JD0Ejgy1gcmk4nu7w6j30q60aq3z0.jpg" alt="自然连接"></div><p>自然连接：<br>相同属性只显示一次。注意，自然连接中没有判断语句。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="number">2</span>_7R <span class="keyword">natural</span> <span class="keyword">join</span> <span class="number">2</span>_7S;</span><br></pre></td></tr></tbody></table></figure><div align="center" width="55%"><img width="55%" src="//tva2.sinaimg.cn/large/005JD0Ejgy1gcmk22qhdyj30nb09paae.jpg" alt="自然连接"></div><p>（全）外连接：<br>只出现在一个表中的项也会显示，未定义的值设为null。Mysql暂不支持这种语法：</p><div align="center" width="45%"><img width="45%" src="//tvax2.sinaimg.cn/large/005JD0Ejgy1gcmkeg5v22j30ep0e2ju3.jpg" alt="外连接"></div><p>左（自然）连接：<br>保留左表。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="number">2</span>_7R <span class="keyword">natural</span> <span class="keyword">left</span> <span class="keyword">join</span> <span class="number">2</span>_7S;</span><br></pre></td></tr></tbody></table></figure><div align="center" width="55%"><img width="55%" src="//tvax1.sinaimg.cn/large/005JD0Ejgy1gcmjx3ja3dj30om0aagm1.jpg" alt="左（自然）连接"></div><p>右（自然）连接:<br>保留右表。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="number">2</span>_7R <span class="keyword">natural</span> <span class="keyword">right</span> <span class="keyword">join</span> <span class="number">2</span>_7S;</span><br></pre></td></tr></tbody></table></figure><div align="center" width="55%"><img width="55%" src="//tvax3.sinaimg.cn/large/005JD0Ejgy1gcmjyudfafj30qg0afwex.jpg" alt="右（自然）连接"></div><h3 id="除运算（division）"><a href="#除运算（division）" class="headerlink" title="除运算（division）"></a>除运算（division）</h3><p>Mysql没有直接的对应语句。需要根据题目的实际含义书写复杂的SQL，通常都会包含子查询。</p><div align="center" width="65%"><img width="65%" src="//tvax1.sinaimg.cn/large/005JD0Ejgy1gcmlf43of7j30t00jfk3t.jpg" alt="除运算"></div><ul><li><strong>例 2.10 查询至少选修 l 号课程和 3 号课程的学生号码。</strong></li></ul><div align="center" width="50%"><img width="50%" src="//tva3.sinaimg.cn/large/005JD0Ejgy1gcmqtxdneij30gb0afdg7.jpg" alt="例2.10"></div><div align="center" width="50%"><img width="50%" src="//tva4.sinaimg.cn/large/005JD0Ejgy1gcmr2idxzrj30v20e2qbc.jpg" alt="例2.10"></div><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Sno <span class="keyword">from</span> <span class="number">2</span>_4SC </span><br><span class="line">  <span class="keyword">where</span> Cno<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> <span class="keyword">exists</span>(</span><br><span class="line">    <span class="keyword">select</span> Sno <span class="keyword">from</span> <span class="number">2</span>_4SC <span class="keyword">where</span> Cno<span class="operator">=</span><span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure><div align="center" width="65%"><img width="65%" src="//tvax1.sinaimg.cn/large/005JD0Ejgy1gcmqxkxn1vj30q70803yt.jpg" alt="例2.10"></div>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fork()创建进程</title>
      <link href="/2020/03/05/fork-chuang-jian-jin-cheng/"/>
      <url>/2020/03/05/fork-chuang-jian-jin-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="fork-创建进程"><a href="#fork-创建进程" class="headerlink" title="fork()创建进程"></a>fork()创建进程</h2><p><code>fork()</code>通过拷贝当前进程创建一个子进程。</p><p>子进程与父进程的区别仅仅在于PID（每个进程唯一）、PPID（父进程的进程号，子进程将其设置为被拷贝进程的PID）和某些资源和统计量（例如，挂起的信号，它没有必要被继承）。</p><p><code>exec()</code>函数负责读取可执行文件并将其载入到地址空间开始运行。</p><p>把这两个函数组合起来的效果跟其他系统使用单一函数的效果相似。</p><h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h3><p>传统的fork()系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，因为它拷贝的数据也许并不共享，更糟的情况是，如果新进程打算立即执行一个新的映像，那么所有的拷贝都将前功尽弃。</p><p>Linux的<code>fork()</code>使用写时拷贝（copy-on-write）页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。</p><p>只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才执行，在此之前，只是以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候才进行，在页根本不会被写入的情况下（比如<code>fork()</code>后立即调用<code>exec()</code>），它们就无须复制了。</p><p><code>fork()</code>的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。</p><p>在一般情况下，进程创建后都会马上运行一个可执行的文件，这种优化可以避免拷贝大量根本就不会被使用的数据（地址空间里常常包含数十兆的数据）。由于Unix强调进程快速执行的能力，所以这个优化是很重要的。</p><blockquote><p>新创建的子进程会被首先唤醒并让其投入运行。内核有意选择子进程首先执行。因为一般子进程都会马上调用<code>exec()</code>函数，这样可以避免写时拷贝的额外开销，如果父进程首先执行的话，有可能会开始向地址空间写入。</p></blockquote><h2 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a>vfork()</h2><p><code>vfork()</code>也是通过拷贝当前进程创建一个子进程。与<code>fork()</code>唯一不同是：不拷贝父进程的页表项。</p><p>子进程作为父进程的一个单独的线程在它的地址空间里运行，父进程被阻塞，直到子进程退出或执行<code>exec()</code>。子进程不能向地址空间写入。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程读书笔记1</title>
      <link href="/2020/03/03/ruan-jian-gong-cheng-du-shu-bi-ji-1/"/>
      <url>/2020/03/03/ruan-jian-gong-cheng-du-shu-bi-ji-1/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-软件的本质（THE-NATURE-OF-SOFTWARE）"><a href="#第一章-软件的本质（THE-NATURE-OF-SOFTWARE）" class="headerlink" title="第一章 软件的本质（THE NATURE OF SOFTWARE）"></a>第一章 软件的本质（THE NATURE OF SOFTWARE）</h2><ul><li><p>Today, software takes on a dual role. It is a product, and at the same time, the vehicle for delivering a product.<br>软件既是产品，也是交付产品的载体。</p></li><li><p>Why does it take so long to get software ﬁnished?<br>为什么软件需要如此长的开发时间？</p></li><li><p>Why are development costs so high?<br>为什么开发成本居高不下？</p></li><li><p>Why can’t we ﬁnd all errors before we give the software to our customers?<br>为什么在将软件交付顾客使用之前，我们无法找到所有的错误？</p></li><li><p>Why do we spend so much time and effort maintaining existing programs?<br>为什么维护已有的程序要花费如此多的时间和人工？</p></li><li><p>Why do we continue to have difﬁculty in measuring progress as software is being developed and maintained?<br>为什么软件开发和维护的进度仍旧难以衡量？</p></li><li><p>Software is not susceptible to the environmental maladies that cause hardware to wear out.<br>软件不会被引起硬件磨损的环境问题所影响，即不会”wear out”.</p></li><li><p>But it does  deteriorate!<br>但软件退化确实存在！</p></li><li><p>the software is deteriorating due to change.<br>不断地变更是软件退化的根本原因</p></li><li><p>There are no software spare parts. Every software failure indicates an error in design or in the process through which design was translated into machine executable code.<br>软件不存在备用部件。每个软件的缺陷都暗示设计的缺陷或者在从设计转化到机器可执行代码过程中产生的错误。</p></li><li><p>Therefore, the software maintenance tasks that accommodate requests for change involve considerably more complexity than hardware maintenance.<br>因此，软件维护要应对变更请求，比硬件维护更为复杂。</p></li><li><p>The proliferation of such systems is causing headaches for large organizations who ﬁnd them costly to maintain and risky to evolve.<br>遗留软件系统维护代价高且系统演化风险高</p></li><li><p>Hence, legacy software is characterized by longevity and business criticality.<br>遗留软件具有生命周期长以及业务关键性的特点。</p></li><li><p>Unfortunately, there is sometimes one additional characteristic that is present in legacy software—-poor quality<br>遗留软件的另一个特点–质量差</p></li><li><p>However, as time passes, legacy systems often evolve for one or more of the following reasons:<br>遗留系统因下述原因而发生演化；</p></li><li><p>The software must be adapted to meet the needs of new computing environments or technology.<br>软件需要进行适应性调整，从而可以满足新的计算环境或技术的需求。</p></li><li><p>The software must be enhanced to implement new business requirements.<br>软件必须升级以实现新的商业需求</p></li><li><p>The software must be extended to make it interoperable with other more modern systems or databases.<br>软件必须扩展以使之具有更多新的系统和数据库的互操作能力</p></li><li><p>The software must be re-architected to make it viable within a evolving computing environment.<br>软件架构必须进行改建以使之适应不断演化的计算环境。</p></li></ul><h2 id="第二章-软件工程（SOFTWARE-ENGINEERING）"><a href="#第二章-软件工程（SOFTWARE-ENGINEERING）" class="headerlink" title="第二章  软件工程（SOFTWARE ENGINEERING）"></a>第二章  软件工程（SOFTWARE ENGINEERING）</h2><ul><li><p>Understand the problem before you build a solution.<br>在建立解决方案前应理解问题。</p></li><li><p>It follows that a concerted effort should be made to understand the problem before a software solution is developed.<br>因此，在确定软件方案之前，需要共同努力来理解问题</p></li><li><p>Both quality and maintainability are an outgrowth of good design.<br>质量和可维护性都是良好设计的产物。</p></li><li><p>It follows that design becomes a pivotal activity.<br>设计已经成为关键活动</p></li><li><p>It follows that software should exhibit high quality.<br>软件应该具有高质量</p></li><li><p>It follows that software should be maintainable.<br>软件应该具有可维护性</p></li><li><p>[Software engineering is] the establishment and use of sound engineering principles in order to obtain economically software that is reliable and works efficiently on real machines.<br>软件工程是建立和使用合理的工程原理，以便以经济的方式获得可靠的软件，并在实际机器上有效地工作。</p></li><li><p>Software Engineering: (1) The application of a systematic, disciplined, quantiﬁ able approach to the development, operation, and maintenance of software; that is, the application of engineering to software. (2) The study of approaches as in (1).<br>软件工程是：（1）将系统化的、规范的、可量化的方法应用于软件的开发、运行和维护，即将工程化的方法应用于软件；（2）对（1）中所述方法的研究。</p></li><li><p>We need discipline, but we also need adaptability and agility.<br>我们需要规范，也需要可适应性和灵活性。</p></li><li><p>Software engineering encompasses a process, methods for managing and engineering software, and tools.<br>软件工程包括过程、管理和构建软件的方法和工具</p></li><li><p>The bedrock that supports software engineering is a quality focus.<br>支持软件工程的根基在于质量关注点</p></li><li><p>The foundation for software engineering is the process  layer.<br>软件工程的基础是过程层</p></li><li><p>Software engineering  methods  provide the technical how-to’s for building software.<br>软件工程方法为构建软件提供技术上的解决方法（如何做）</p></li><li><p>Software engineering  tools  provide automated or semi-automated support for the process and the methods.<br>软件工程工具为过程和方法提供自动化或半自动化的支持。</p></li><li><p>A  process  is a collection of activities, actions, and tasks that are performed when some work product is to be created.<br>软件过程是工作产品构建时所执行的一系列活动、动作、任务的集合。</p></li><li><p>A  process framework  establishes the foundation for a complete software engineering process by identifying a small number of  framework activities  that are applicable to all software projects, regardless of their size or complexity. In addition, the process framework encompasses a set of  umbrella activities  that are applicable across the entire software process.<br>过程框架定义了若干个框架活动，为实现完整的软件工程过程建立了基础。这些活动可广泛应用于所有软件开发项目，无论项目的规模和复杂性如何。此外，一个过程框架还包含一些适用于整个软件过程的普适性活动。</p></li><li><p>framework activities: Communication，Planning，Modeling，Construction，Deployment<br>框架活动：沟通、策划、建模、构建、部署</p></li><li><p>umbrella activities: Software project tracking and control, Risk management, Software quality assurance, Technical reviews, Measurement, Software configuration management, Reusability management, Work product preparation and production<br>普适性活动：软件项目跟踪和控制，风险管理，软件质量保证，技术评审，测量，软件配置管理，可复用管理，工作产品的准备和生产。</p></li><li><p>Umbrella activities occur throughout the software process and focus primarily on project management, tracking, and control.<br>普适性活动贯穿整个软件过程，主要关注项目管理、跟踪和控制</p></li><li><p>Software process adaptation is essential for project success.<br>对软件的适应性调整是项目成功的关键。</p></li></ul><p><strong>Adapting a Process Model 过程的适应性调整</strong></p><ul><li>a process adopted for one project might be signiﬁ cantly different than a process adopted for another project.<br>不同项目所采取的项目过程可能有很大的不同。</li></ul><ol><li>the overall flow of activities, actions, and tasks and the interdependencies among them<br>活动、动作和任务的总体流程和相互依赖关系。</li><li>the degree to which actions and tasks are defined within each framework activity<br>在每一个框架活动中，动作和任务细化的程度。</li><li>the degree to which work products are identified and required<br>工作产品的定义和要求的程度。</li><li>the manner which quality assurance activities are applied<br>质量保证活动应用的方式。</li><li>the manner in which project tracking and control activities are applied<br>项目跟踪和控制活动应用的方式。</li><li>the overall degree of detail and rigor with which the process is described<br>过程描述的详细程度和严谨程度。</li><li>the degree to which the customer and other stakeholders are involved with the project<br>客户和利益相关者对项目的参与程度。</li><li>the level of autonomy given to the software team<br>软件团队所获得的自主权。</li><li>the degree to which team organization and roles are prescribed<br>队伍组织和角色的明确程度。</li></ol><p><strong>The Essence of Practice 软件工程实践</strong><br>1.Understand the problem (communication and analysis).<br>理解问题（沟通和分析）<br>2.Plan a solution (modeling and software design).<br>策划解决方案（建模和软件设计）<br>3.Carry out the plan (code generation).<br>实施计划（代码生成）<br>4.Examine the result for accuracy (testing and quality assurance).<br>检查结果的准确性（测试和质量保证）</p><p><strong>理解问题 Understand the problem</strong></p><ul><li>Who has a stake in the solution to the problem? That is, who are the stakeholders?<br>谁将从问题的解决中获益？也就是说，谁是利益相关者？</li><li>What are the unknowns? What data, functions, and features are required to properly solve the problem?<br>有哪些是未知的？那些数据、功能和特性是解决问题所必需的。</li><li>Can the problem be compartmentalized? Is it possible to represent smaller problems that may be easier to understand?<br>问题可以被划分吗？是否可以描述为更小、更容易理解的问题。</li><li>Can the problem be represented graphically? Can an analysis model be created?<br>问题可以图形化描述吗？可以建立分析模型吗？</li></ul><p><strong>策划解决方案 Plan a solution</strong></p><ul><li><p>Have you seen similar problems before? Are there patterns that are recognizable in a potential solution? Is there existing software that implements the data, functions, and features that are required? </p></li><li><p>Has a similar problem been solved? If so, are elements of the solution reusable?</p></li><li><p>Can subproblems be defined? If so, are solutions readily apparent for the subproblems?</p></li><li><p>Can you represent a solution in a manner that leads to effective implementation? Can a design model be created?</p></li></ul><p><strong>实施计划 Carry out the plan</strong></p><ul><li><p>Does the solution conform to the plan? Is source code traceable to the design model?</p></li><li><p>Is each component part of the solution provably correct? Has the design and code been reviewed, or better, have correctness proofs been applied to algorithm?</p></li></ul><p><strong>检查结果 Examine the result for accuracy</strong></p><ul><li><p>Is it possible to test each component part of the solution? Has a reasonable testing strategy been implemented?</p></li><li><p>Does the solution produce results that conform to the data, functions, and features that are required? Has the software been validated against all stakeholder requirements?</p></li></ul><p><strong>General Principles 通用原则</strong></p><ol><li>The Reason It All Exists<br>存在价值。</li><li>KISS (Keep It Simple, Stupid!)<br>保持简洁</li><li>Maintain the Vision<br>保持愿景</li><li>What You Produce, Others Will Consume<br>关注使用者</li><li>Be Open to the Future<br>面向未来</li><li>Plan Ahead for Reuse<br>提前计划复用</li><li>Think!<br>认真思考</li></ol><h2 id="第三章-软件过程（THE-SOFTWARE-PROCESS）"><a href="#第三章-软件过程（THE-SOFTWARE-PROCESS）" class="headerlink" title="第三章 软件过程（THE SOFTWARE PROCESS）"></a>第三章 软件过程（THE SOFTWARE PROCESS）</h2><ul><li><p>The hierarchy of technical work within the software process is activities, encompassing actions, populated by tasks.<br>在软件过程中，技术工作的层次包括活动，活动由动作构成，动作又由任务构成。</p></li><li><p>Different projects demand different task sets. The software team chooses the task set based on problem and project characteristics.<br>不同的项目需要不同的任务集。软件团队根据问题和项目的特点选择任务集</p></li><li><p>each a collection of software engineering work tasks, related work products, quality assurance points, and project milestones.<br>每一个任务集都由软件工程工作任务、相关工作产品、质量保证点和项目里程碑构成。</p></li><li><p>A process pattern describes a process-related problem that is encountered during software engineering work, identiﬁes the environment in which the problem has been encountered, and suggests one or more proven solutions to the problem.<br>过程模式描述了软件工程工作中遇到的过程相关的问题，明确了问题环境并给出了针对该问题的一种或几种可证明的解决方案。</p></li></ul><p><strong>A pattern template provides a consistent means for describing a pattern.<br>模式模板提供了描述模式的一般性方法</strong></p><ul><li><p>Stated in more general terms, a process pattern provides you with a template [Amb98]—a consistent method for describing problem solutions within the context of the software process.<br>通俗地讲，过程模式提供一个模板，一种在软件过程背景下统一描述问题解决方案的方法。</p></li><li><p>Stage patterns—defines a problem associated with a framework activity for the process.<br>步骤模式——定义了与过程的框架活动相关的问题。</p></li><li><p>Task patterns—defines a problem associated with a software engineering action or work task and relevant to successful software engineering practice<br>任务模式——定义了与软件工程动作或工作任务相关，关系软件工程实践成败的问题。</p></li><li><p>Phase patterns—define the sequence of framework activities that occur with the process, even when the overall flow of activities is iterative in nature.<br>阶段模式——定义了在过程中发生的框架活动序列，即使这些活动流本质上是迭代的。</p></li></ul><p><strong>A number of different approaches to software process assessment and improvement have been proposed over the past few decades:<br>在过去的几十年中，已经提出了许多不同的方法来评估和改进软件过程：</strong></p><ul><li><p>Standard CMMI Assessment Method for Process Improvement (SCAMPI) — provides a five step process assessment model that incorporates five phases: initiating, diagnosing, establishing, acting and learning.<br>用于过程改进的标准CMMI评估方法（SCAMPI）——提供了包含五个阶段的五个步骤的过程评估模型：启动，诊断，建立，执行和学习。</p></li><li><p>CMM-Based Appraisal for Internal Process Improvement (CBA IPI)—provides a diagnostic technique for assessing the relative maturity of a software organization; uses the SEI CMM as the basis for the assessment [Dun01]<br>基于CMM的内部流程改进评估（CBA IPI）——提供一种诊断技术，用于评估软件组织的相对成熟度；使用SEI CMM作为评估的基础[Dun01]</p></li><li><p>SPICE—The SPICE (ISO/IEC15504) standard defines a set of requirements for software process assessment. The intent of the standard is to assist organizations in developing an objective evaluation of the efficacy of any defined software process. [ISO08]<br>SPICE-SPICE（ISO / IEC15504）标准定义了一组软件过程评估要求。该标准的目的是帮助组织对任何定义的软件过程的有效性进行客观评估。[ISO08]</p></li><li><p>ISO 9001:2000  for Software—a generic standard that applies to any organization that wants to improve the overall quality of the products, systems, or services that it provides. Therefore, the standard is directly applicable to software organizations and companies. [Ant06]<br>ISO 9001:2000软件——一种通用标准，适用于希望提高其提供的产品，系统或服务的整体质量的任何组织。因此，该标准直接适用于软件组织和公司。[Ant06]</p></li><li><p>Assessment attempts to understand the current state of the software process with the intent of  improving it.<br>评估试图了解软件过程的当前状态，以进行改进。</p></li></ul><h2 id="第四章-过程模型（PROCESS-MODELS）"><a href="#第四章-过程模型（PROCESS-MODELS）" class="headerlink" title="第四章 过程模型（PROCESS MODELS）"></a>第四章 过程模型（PROCESS MODELS）</h2><ul><li><p><strong>The purpose of process models is to try to reduce the chaos present in developing new software products.<br>过程模型的作用减少新软件产品开发时的混乱</strong></p></li><li><p>A prescriptive process model strives for structure and order in software development. Activities and tasks occur sequentially with deﬁned guidelines for progress.<br>惯用过程模型力求达到软件开发的结构和秩序，其活动和任务都是都是按照过程的特定指引顺序进行的。</p></li><li><p><strong>Prescriptive process models deﬁne a prescribed set of process elements and a predictable process work ﬂow.<br>惯用过程模型定义了一组规定的过程元素和一个可预测的过程工作流</strong></p></li><li><p>The waterfall model, sometimes called the  classic life cycle , suggests a systematic, sequential approach to software development that begins with customer speciﬁcation of requirements and progresses through planning, modeling, construction, and deployment, culminating in ongoing support of the completed software<br>瀑布模型，又称经典生命模型，它提出了一个系统的、顺序的软件开发方法，从用户需求规格说明开始，通过策划、建模、构建、部署的过程，最终提供完整的软件支持。</p></li><li><p>A variation in the representation of the waterfall model is called the V-model.the V-model [Buc99] depicts the relationship of quality assurance actions to the actions associated with communication, modeling, and early construction activities.<br>瀑布模型的一个变体是V模型。V模型描述了质量保证动作同沟通、建模和早期构建相关动作的关系。</p></li><li><p><strong>The V-model illustrates how veriﬁcation and validation actions are associated with earlier engineering actions.<br>V模型阐明了验证和确认动作如何与早期工程动作相关联。</strong></p></li><li><p><strong>The incremental model delivers a series of releases, called increments, that provide progressively more functionality for the customer as each  increment is delivered.<br>增量模型交付一系列称为增量的版本，随着每个版本的交付，逐步为用户提供更多的功能。</strong>、</p></li><li><p><strong>Evolutionary process models produce an increasingly more complete version of the software with each iteration.<br>演化过程模型中，每一个迭代产生软件的一个更完整的版本</strong></p></li><li><p>the spiral model is an evolutionary software process model that couples the iterative nature of prototyping with the controlled and systematic aspects of the waterfall model. It provides the potential for rapid development of increasingly more complete versions of the software.<br>螺旋模型是一种演进式软件过程模型。它结合了原型的迭代性质和瀑布模型的可控性和系统性特点。它具有快速开发越来越完善的软件版本的潜力。 </p></li><li><p><strong>The spiral model can be adapted to apply throughout the entire life cycle of an application, from concept development to maintenance.<br>螺旋模型能运用在应用系统开发的整个生命周期，从概念开发到概念维护。</strong></p></li><li><p>The  concurrent development model,  sometimes called  concurrent engineering,allows a software team to represent iterative and concurrent elements of any of the process models described in this chapter.<br>并发开发模型（ concurrent development model ）有时也叫作并发工程，它允许软件团队表述本章所描述的任何过程模型中的迭代元素和并发元素。</p></li><li><p><strong>Project plans must be viewed as living documents; progress must be assessed often and revised to take changes into account.<br>必须将项目计划看成是活的文档，必须经常对进度进行评估并考虑变支情况，从而对其进行修改。</strong></p></li><li><p>THE UNIFIED PROCESS: use case driven, architecturecentric, iterative and incremental” software process<br>统一过程：用例驱动，以架构为核心，迭代并且增量的软件过程</p></li></ul><p><strong>Phases of the Uniﬁed Process  统一过程的阶段</strong></p><ul><li><strong>UP  phases  are similar in intent to the generic framework activities deﬁned in this book.<br>UP阶段的目的与本书中定义的通用框架活动的目的是类似的。</strong></li></ul><ol><li><p>The inception phase of the UP encompasses both customer communication and planning activities.<br>UP 的起始阶段（ inception phase）包括客户 沟通和策划活动。 </p></li><li><p>The elaboration phase  encompasses the communication and modeling activities of the generic process model.<br>细化阶段（ Elaboration Phase）包括沟通和通用过程模型的建模活动.</p></li><li><p>The construction phase  of the UP is identical to the construction activity deﬁ ned for the generic software process.<br>UP 的构建阶段（ construction phase）与通用软件过程中的构建活动相同。</p></li><li><p>The transition phase  of the UP encompasses the latter stages of the generic construction activity and the ﬁrst part of the generic deployment (delivery and feedback) activity.<br>UP 的转换阶段（ transition phase）包括通用构建活动的后期阶段以及通用部署（交付和 反馈）活动的第一部分。 </p></li><li><p>The production phase  of the UP coincides with the deployment activity of the generic process.<br>UP 的生产阶段（ production phase）与通用过程的部署活动一致。</p></li></ol><h2 id="第五章-敏捷开发（AGILE-DEVELOPMENT）"><a href="#第五章-敏捷开发（AGILE-DEVELOPMENT）" class="headerlink" title="第五章 敏捷开发（AGILE DEVELOPMENT）"></a>第五章 敏捷开发（AGILE DEVELOPMENT）</h2>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串的排列包含</title>
      <link href="/2020/03/03/zi-fu-chuan-de-pai-lie-bao-han/"/>
      <url>/2020/03/03/zi-fu-chuan-de-pai-lie-bao-han/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（leetcode-567-字符串的排列）"><a href="#题目（leetcode-567-字符串的排列）" class="headerlink" title="题目（leetcode 567. 字符串的排列）"></a>题目（<a href="https://leetcode-cn.com/problems/permutation-in-string">leetcode 567. 字符串的排列</a>）</h2><p>给定两个字符串&nbsp;s1&nbsp;和&nbsp;s2，写一个函数来判断 s2 是否包含 s1&nbsp;的排列。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><p><strong>示例1:</strong></p><blockquote><p>输入: s1 = “ab” s2 = “eidbaooo”<br>输出: True<br>解释: s2 包含 s1 的排列之一 (“ba”).&nbsp;</p></blockquote><p><strong>示例2:</strong></p><blockquote><p>输入: s1= “ab” s2 = “eidboaoo”<br>输出: False&nbsp;</p></blockquote><p><strong>注意：</strong></p><ol><li>输入的字符串只包含小写字母</li><li>两个字符串的长度都在 [1, 10,000] 之间</li></ol><h2 id="滑动窗口-map"><a href="#滑动窗口-map" class="headerlink" title="滑动窗口+map"></a>滑动窗口+map</h2><p>  求是否存在字符串s1的排列使得成为另一个字符串s2的子串，可以想到的暴力解法是先把字符串的所有排列求出来，然后挨个与s2进行比较，比较的过程是一个滑动窗口不断地对s2取子串，然后判断与那个排列是否相等。</p><p>  排列的求法可以直接用<code>next_permutation()</code>，而取子串用<code>string.substr()</code>，时间复杂度估计是一个全排列乘上字符串s2的长度。看了题目提示，说字符串的每种排列都有相同统计规律，所以可以用散列表（太菜还是想不到咋做wwww…）。不管咋样先写出来试试。</p><p>  数组越界：<code>s1.length()-s2.length()</code>如果小于零，实际上得到了一个取模数，我看了一下<code>string.length()</code>的类型是<code>size_t</code>，这是一个无符号类型。所以还是用<code>int</code>变量先保存各自的长度再相减。</p><p>  写出来测试时发现果然会超时，不然就会超内存，全排列实在太大了。</p><p>  不过想到了题目提示的解法，用<code>map</code>来实现滑动窗口，我们可以维护一个大小为<code>s1</code>长度的窗口，然后用<code>map</code>记录这个窗口中<code>s2</code>的字符出现的次数，然后与<code>s1</code>的字符出现次数相比较，如果出现相等直接返回<code>true</code>。那么这里的问题是如何快速比较两个map是否相等。我们先把<code>s1</code>的<code>map</code>求出来，然后在滑动的时候，遇到一个字符就将<code>map</code>对应元素减一，最后检查一下<code>map</code>是否为空就知道存不存在对应的排列了。这里如果遇到一个<code>map</code>没有的字符可以直接退出当层循环进行下一检查。</p><p>  我洒了，直接比较两个map是否相等就行了，但是如果有一个字符的次数将为0时就要用<code>earse</code>函数去除。滑动窗口的下标变化和暴力的不一样，没画草稿，被自己误导了。</p><p>  最后，就是初始化后窗口后就要直接判断两个<code>map</code>是否相等，否则出现 <code>a</code>，<code>ab</code>这种例子判断错误。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; cnt,tmp;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len_s2 = s2.<span class="built_in">length</span>(), len_s1 = s1.<span class="built_in">length</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(len_s1 &gt; len_s2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len_s1 == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化窗口</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len_s1;i++){</span><br><span class="line">            tmp[s2[i]]++;</span><br><span class="line">            cnt[s1[i]]++;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(tmp == cnt)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;i&lt;len_s2;i++){</span><br><span class="line">            tmp[s2[i-len_s1]]--;</span><br><span class="line">            <span class="keyword">if</span>(tmp[s2[i-len_s1]] == <span class="number">0</span>)tmp.<span class="built_in">erase</span>(s2[i-len_s1]);</span><br><span class="line"></span><br><span class="line">            tmp[s2[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(tmp == cnt)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/2020/03/03/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/"/>
      <url>/2020/03/03/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（leetcode-3-无重复字符的最长子串）"><a href="#题目（leetcode-3-无重复字符的最长子串）" class="headerlink" title="题目（leetcode 3. 无重复字符的最长子串）"></a>题目（<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">leetcode 3. 无重复字符的最长子串</a>）</h2><p>给定一个字符串，请你找出其中不含有重复字符的&nbsp;最长子串&nbsp;的长度。</p><p><strong>示例&nbsp;1:</strong></p><blockquote><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是&nbsp;“wke”，所以其长度为 3。</p></blockquote><blockquote><p>请注意，你的答案必须是 子串 的长度，”pwke”&nbsp;是一个子序列，不是子串。</p></blockquote><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>  题意比较简单，所以一开始就面向示例编程…考虑第一个示例<code>"abcabcbb"</code>，可以看到有三个最长子串<code>abc</code>,<code>bca</code>,<code>abc</code>，那么要考虑的算法应能够所有的无重复最长子串找出来，只是找到第一个的时候就退出算法了。</p><p>  先考虑空字符串和单个字符的情况，接着用滑动窗口。</p><p>  我们用一个窗口，<code>st</code>表示窗口左边界，<code>ed</code>表示窗口右边界，先从左往右遍历，当字符不重复时<code>ed</code>不断向右生长：<code>a</code>,<code>ab</code>,<code>abc</code>,<code>abca</code>，好了到这里我们发现第1个字符和第4个字符都是相同的字符<code>a</code>，至今能得到最长子串是<code>abc</code>，所以更新一下<code>ans</code>，和它取个最大值。那么就需要重新调整这个窗口的左端，以便右端能够正常生长。此时整个窗口左边界就应该是第一个字符<code>a</code>的下一个字符，也就是<code>b</code>。但是考虑到一种情况是：<code>...abcabcbb</code>,那么就需要保存字符<code>a</code>的位置，然后才能调整窗口左边界，用一个<code>map</code>来保存字符到数字的映射，命名为<code>pos</code>。这个<code>map</code>用来判断是否有字符重复，即使用<code>conut</code>成员函数。</p><p>  那么就能将窗口左边界重新调整为 <code>pos['a']+1</code>。当时有一点没想到，就是<code>st...abca</code>，那么我们需要把<code>'a'</code>之前的位置映射都清除。</p><p>  在删除了第一个<code>a</code>后，我们就需要更新<code>'a'</code>的位置映射为第2个<code>a</code>。最后窗口右边界<code>ed</code>就自增，因为此时第二个字符<code>a</code>已经不重复了。</p><p>  在映射里，上面说的第一个字符<code>a</code>就对应<code>st</code>，而第二个<code>a</code>对应<code>ed</code>，但是我们在实际编程的时候用<code>ed</code>比较多，因为<code>st</code>不一定是发生重复的字符，而<code>ed</code>一定是发生重复的字符，正是因为新加一个字符才使得字符串发生重复。</p><p>  还需要注意的是在窗口右端不断生长需要判断是否越界了。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">""</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.<span class="built_in">length</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pos;</span><br><span class="line">        pos[s[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> st = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(ed &lt; s.<span class="built_in">length</span>() &amp;&amp; st&lt;=ed){</span><br><span class="line">            <span class="keyword">while</span>(!pos.<span class="built_in">count</span>(s[ed])){<span class="comment">//当字符无重复时窗口不断向右生长</span></span><br><span class="line">                pos[s[ed]] = ed;</span><br><span class="line">                <span class="keyword">if</span>(ed == s.<span class="built_in">length</span>()){<span class="comment">//注意判断字符串边界</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">max</span>(ans,ed-st);</span><br><span class="line">                }</span><br><span class="line">                ed++;</span><br><span class="line">            }</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,ed-st);</span><br><span class="line">            <span class="comment">// 将从左到右第一个发生重复的字符的前面那些字符的位置清除</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = st ; i &lt; pos[s[ed]];i++)pos.<span class="built_in">erase</span>(s[i]);</span><br><span class="line">            </span><br><span class="line">            st = pos[s[ed]]+<span class="number">1</span>;  <span class="comment">//调整窗口左边界为从左到右第一个发生重复的字符的下一个位置</span></span><br><span class="line">            pos[s[ed]] = ed; <span class="comment">//更新发生重复字符的最新位置</span></span><br><span class="line">            ed++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长公共前缀</title>
      <link href="/2020/03/01/zui-chang-gong-gong-qian-zhui/"/>
      <url>/2020/03/01/zui-chang-gong-gong-qian-zhui/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（leetcode-14-最长公共前缀）"><a href="#题目（leetcode-14-最长公共前缀）" class="headerlink" title="题目（leetcode 14. 最长公共前缀）"></a>题目（<a href="https://leetcode-cn.com/problems/longest-common-prefix/">leetcode 14. 最长公共前缀</a>）</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><p><strong>示例&nbsp;1:</strong></p><blockquote><p>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”</p></blockquote><p><strong>示例&nbsp;2:</strong></p><blockquote><p>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。</p></blockquote><p><strong>说明:</strong></p><blockquote><p>所有输入只包含小写字母&nbsp;<code>a-z</code>&nbsp;。</p></blockquote><h2 id="方法一-水平扫描法（暴力）"><a href="#方法一-水平扫描法（暴力）" class="headerlink" title="方法一 水平扫描法（暴力）"></a>方法一 水平扫描法（暴力）</h2><p>纵向遍历vector，然后横向遍历字符串，依次比较各个字符。正常情况下需要知道最小的字符串长度，但是并不需要再单独用一个循环求出，修改一下判断条件即可。</p><p>仔细想想，你要求所有字符串的最长公共前缀，那么至少要把所有字符串中的最长公共前缀部分都比较一遍才行，所以时间复杂度 O(n*minStrLen) </p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//水平扫描法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>{</span><br><span class="line">        <span class="comment">//string s="";  保留下标最后取子串就好了</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="keyword">if</span>(strs.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(strs.<span class="built_in">size</span>()==<span class="number">1</span>)<span class="keyword">return</span> strs.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根本不需要找最短字符串</span></span><br><span class="line">        <span class="comment">// int s_min=INT_MAX;</span></span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;strs.size();i++){  // 取所有字符串长度的最小值</span></span><br><span class="line">        <span class="comment">//     s_min=min( (int)strs.at(i).length(), s_min );</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;strs[<span class="number">0</span>].<span class="built_in">length</span>();j++)  <span class="comment">// 遍历字符串</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;strs.<span class="built_in">size</span>();i++)  <span class="comment">// 遍历vector</span></span><br><span class="line">            {</span><br><span class="line">                ch=strs.<span class="built_in">at</span>(i)[j];</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= strs[i].<span class="built_in">length</span>() || ch != strs.<span class="built_in">at</span>(i<span class="number">-1</span>)[j])</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>,ans);  <span class="comment">// 如果有一个字符不一致，说可以直接返回答案了</span></span><br><span class="line">                }            </span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果 所有字符串都遍历完了，说明这个字符是最长公共前缀的一部分</span></span><br><span class="line">            ans++;</span><br><span class="line">         }</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>,ans);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="方法二-分治（时间复杂度也没减少）"><a href="#方法二-分治（时间复杂度也没减少）" class="headerlink" title="方法二 分治（时间复杂度也没减少）"></a>方法二 分治（时间复杂度也没减少）</h2><p>仔细想想最长公共前缀问题满足“分解-求解-组合”，我们先对字符串两两进行求最长公共前缀，然后合并，即对两两求出来的再次两两求公共前缀，直到合并成一个答案。这里两两字符串求公共前缀归属到合并的部分，如果分解到只有一个字符串就直接返回。</p><p>需要注意的是，当分治到只有一条字符串的区间时是直接返回字符串，所以返回的结果并不一定能求出最长公共前缀，也有可能只是把问题规模缩小了，比如返回 flow flede，那么就不能直接取两者最小的字符串了.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">common_prefix</span><span class="params">(string a,string b)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">min</span>(a.<span class="built_in">length</span>(),b.<span class="built_in">length</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">            <span class="keyword">if</span>(a[i] != b[i]){</span><br><span class="line">                <span class="keyword">return</span> a.<span class="built_in">substr</span>(<span class="number">0</span>,i); </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">substr</span>(<span class="number">0</span>,n);</span><br><span class="line">    }</span><br><span class="line">    <span class="function">string <span class="title">divide_strs</span> <span class="params">(vector&lt;string&gt;&amp; strs,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(l == r){</span><br><span class="line">            <span class="keyword">return</span> strs[l];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r -l == <span class="number">1</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">common_prefix</span>(strs[l],strs[r]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        string left = <span class="built_in">divide_strs</span>(strs, l, mid);</span><br><span class="line">        string right = <span class="built_in">divide_strs</span>(strs, mid+<span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">// if(left.length() &lt; right.length()){ </span></span><br><span class="line">        <span class="comment">//     return left;      //注意，当分治到只有一条字符串的区间时是直接返回字符串</span></span><br><span class="line">        <span class="comment">// }                     //所以返回的结果并不一定能求出最长公共前缀，也有可能只是把问题规模缩小了</span></span><br><span class="line">        <span class="comment">// else return right;    //比如返回 flow flede，那么就不能取两者最小的字符串了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">common_prefix</span>(left, right);</span><br><span class="line">    }</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(!strs.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">divide_strs</span>(strs,<span class="number">0</span>,strs.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="方法三-二分查找（更慢）"><a href="#方法三-二分查找（更慢）" class="headerlink" title="方法三 二分查找（更慢）"></a>方法三 二分查找（更慢）</h2><p>二分字符串长度。先求出最短字符串长度，然后二分，每次检查这个长度下所有字符串是否存在公共前缀，如果存在则往高区间检查，否则往低区间检查。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket实现简易TCP服务端客户端</title>
      <link href="/2020/02/29/shi-xian-jian-yi-tcp-fu-wu-duan-ke-hu-duan/"/>
      <url>/2020/02/29/shi-xian-jian-yi-tcp-fu-wu-duan-ke-hu-duan/</url>
      
        <content type="html"><![CDATA[<h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而<code>socket()</code>用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p><ul><li>domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li><li>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</li><li>protocol：顾名思义，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。</li></ul><p>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p><p>当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用<code>bind()</code>函数，否则就当调用<code>connect()</code>、<code>listen()</code>时系统会自动随机分配一个端口。</p><h2 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h2><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>函数的三个参数分别为：</p><ul><li>sockfd：即socket描述字，它是通过<code>socket()</code>函数创建了，唯一标识一个socket。<code>bind()</code>函数就是将给这个描述字绑定一个名字。</li><li>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> {</span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;   <span class="comment">/* internet address */</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> {</span><br><span class="line">    <span class="type">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>ipv6对应的是：<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> { </span><br><span class="line">    <span class="type">sa_family_t</span>     sin6_family;   <span class="comment">/* AF_INET6 */</span> </span><br><span class="line">    <span class="type">in_port_t</span>       sin6_port;     <span class="comment">/* port number */</span> </span><br><span class="line">    <span class="type">uint32_t</span>        sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span> </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;     <span class="comment">/* IPv6 address */</span> </span><br><span class="line">    <span class="type">uint32_t</span>        sin6_scope_id; <span class="comment">/* Scope ID (new in 2.4) */</span> </span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span> { </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   s6_addr[<span class="number">16</span>];   <span class="comment">/* IPv6 address */</span> </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>Unix域对应的是：<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX    108</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> { </span><br><span class="line">    <span class="type">sa_family_t</span> sun_family;               <span class="comment">/* AF_UNIX */</span> </span><br><span class="line">    <span class="type">char</span>        sun_path[UNIX_PATH_MAX];  <span class="comment">/* pathname */</span> </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li><li>addrlen：对应的是地址的长度。</li></ul><p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用<code>bind()</code>，而客户端就不会调用，而是在<code>connect()</code>时由系统随机生成一个。</p><blockquote><p>网络字节序与主机字节序<br><strong>主机字节序</strong>就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：<br>a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br>b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。<br><strong>网络字节序</strong>：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。<strong>由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。</strong>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。<br><strong>所以</strong>：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。</p></blockquote><h2 id="listen函数、connect函数"><a href="#listen函数、connect函数" class="headerlink" title="listen函数、connect函数"></a>listen函数、connect函数</h2><p>如果作为一个服务器，在调用<code>socket()</code>、<code>bind()</code>之后就会调用<code>listen()</code>来监听这个socket，如果客户端这时调用<code>connect()</code>发出连接请求，服务器端就会接收到这个请求。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p><p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p><h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><p>TCP服务器端依次调用<code>socket()</code>、<code>bind()</code>、<code>listen()</code>之后，就会监听指定的socket地址了。TCP客户端依次调用<code>socket()</code>、<code>connect()</code>之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用<code>accept()</code>函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p><p><strong>注意</strong>：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为<strong>监听socket描述字</strong>；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个<strong>已连接socket描述字</strong>，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭</p><h2 id="read函数、write函数"><a href="#read函数、write函数" class="headerlink" title="read函数、write函数"></a>read函数、write函数</h2><p>万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p><ul><li><code>read()</code>/<code>write()</code></li><li><code>recv()</code>/<code>send()</code></li><li><code>readv()</code>/<code>writev()</code></li><li><code>recvmsg()</code>/<code>sendmsg()</code></li><li><code>recvfrom()</code>/<code>sendto()</code></li></ul><p>它们的声明如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</p><p>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</p><h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p><p>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p><h2 id="使用Socket-API建立简易TCP服务器"><a href="#使用Socket-API建立简易TCP服务器" class="headerlink" title="使用Socket API建立简易TCP服务器"></a>使用Socket API建立简易TCP服务器</h2><ol><li>建立一个Socket</li><li>绑定接受客户端连接的端口 bind</li><li>监听网络端口 listen</li><li>等待接收客户端连接 accept</li><li>向客户端发送一条数据 send</li><li>关闭Socket closesocket</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _WINSOCK_DEPRECATED_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//启动Windows Socket 2.x 环境</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="comment">//----------------</span></span><br><span class="line"><span class="comment">// 1 建立一个Socket 套接字</span></span><br><span class="line">SOCKET _sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM,IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == _sock) {</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Fail to new a Socket...\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Success: New a Socket...\n"</span>);</span><br><span class="line">}</span><br><span class="line">       <span class="comment">//IPv4的网络套接字 //面向数据流 //TCP协议</span></span><br><span class="line"><span class="comment">// 2 bind 绑定接受客户端连接的端口 </span></span><br><span class="line">sockaddr_in _sin = {};</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>); <span class="comment">//host to net unsigned short</span></span><br><span class="line">_sin.sin_addr.S_un.S_addr = INADDR_ANY;<span class="comment">//net_addr("127.0.0.1");</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">bind</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(sockaddr_in))) {</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"错误:绑定网络端口失败...\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"绑定网络端口成功...\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 3 listen 监听网络端口 </span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">listen</span>(_sock, <span class="number">5</span>)){</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"错误:监听网络端口失败...\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"监听网络端口成功...\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 4 accept等待接收客户端连接 </span></span><br><span class="line">sockaddr_in clientAddr = {};</span><br><span class="line"><span class="type">int</span> nAddrLen = <span class="built_in">sizeof</span>(sockaddr);</span><br><span class="line">SOCKET _cSock = INVALID_SOCKET;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> msgBuf[] = <span class="string">"Hello, I'm Server."</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">_cSock = <span class="built_in">accept</span>(_sock, (sockaddr*)&amp;clientAddr, &amp;nAddrLen);</span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == _cSock) {</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"错误:接收到无效客户端SOCKET...\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"新客户端加入：IP = %s \n"</span>, <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr));</span><br><span class="line"><span class="comment">// 5 send 向客户端发送一条数据 </span></span><br><span class="line"><span class="built_in">send</span>(_cSock, msgBuf, <span class="built_in">strlen</span>(msgBuf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 6 关闭套接字Socket closesocket</span></span><br><span class="line"><span class="built_in">closesocket</span>(_sock);</span><br><span class="line"><span class="comment">//----------------</span></span><br><span class="line"><span class="comment">//清除windows socket 环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="使用Socket-API建立简易TCP客户端"><a href="#使用Socket-API建立简易TCP客户端" class="headerlink" title="使用Socket API建立简易TCP客户端"></a>使用Socket API建立简易TCP客户端</h2><ol><li>建立一个Socket</li><li>connect 连接服务器 </li><li>recv 接收服务器信息</li><li>关闭Socket closesocket</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//启动Windows Socket 2.x 环境</span></span><br><span class="line">WORD ver = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSADATA dat;</span><br><span class="line"><span class="built_in">WSAStartup</span>(ver, &amp;dat);</span><br><span class="line"><span class="comment">//----------------</span></span><br><span class="line"><span class="comment">//-- 使用Socket API建立简易TCP客服端</span></span><br><span class="line"><span class="comment">// 1 建立一个Socket</span></span><br><span class="line">SOCKET _sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == _sock) {</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Fail to new a Socket...\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Success: New a Socket...\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 2 connect 连接服务器 </span></span><br><span class="line">sockaddr_in _sin = {};</span><br><span class="line">_sin.sin_family = AF_INET;</span><br><span class="line">_sin.sin_port = <span class="built_in">htons</span>(<span class="number">4567</span>);</span><br><span class="line">_sin.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">connect</span>(_sock, (sockaddr*)&amp;_sin, <span class="built_in">sizeof</span>(sockaddr_in));</span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == ret) {</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ERROR: Fail to connect to Server...\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Success: Connect to Server...\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 3 recv 接收服务器信息</span></span><br><span class="line"><span class="type">char</span> recvBuf[<span class="number">256</span>];</span><br><span class="line"><span class="type">int</span> nlen = <span class="built_in">recv</span>(_sock, recvBuf, <span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (nlen &gt; <span class="number">0</span>) {</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Receive Data: %s \n"</span>, recvBuf);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 4 关闭Socket closesocket</span></span><br><span class="line"><span class="built_in">closesocket</span>(_sock);</span><br><span class="line"><span class="comment">//----------------</span></span><br><span class="line"><span class="comment">//清除windows socket 环境</span></span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><div align="center" width="60%"><img width="60%" src="//tvax4.sinaimg.cn/large/005JD0Ejgy1gcdoxi7loej30pv0fpdgm.jpg" alt="服务端"></div><div align="center" width="60%"><img width="60%" src="//tvax3.sinaimg.cn/large/005JD0Ejgy1gcdoxy5g1bj30qb0fgq3l.jpg" alt="客户端"></div>]]></content>
      
      
      <categories>
          
          <category> Socket </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的遍历例题</title>
      <link href="/2020/02/24/shu-de-bian-li-li-ti/"/>
      <url>/2020/02/24/shu-de-bian-li-li-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（leetcode-116-填充每个节点的下一个右侧节点指针）"><a href="#题目（leetcode-116-填充每个节点的下一个右侧节点指针）" class="headerlink" title="题目（leetcode 116. 填充每个节点的下一个右侧节点指针）"></a>题目（<a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">leetcode 116. 填充每个节点的下一个右侧节点指针</a>）</h2><p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> {</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有&nbsp;next 指针都被设置为 <code>NULL</code>。</p><p><strong>提示：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><p><img src="//tvax3.sinaimg.cn/large/005JD0Ejgy1gc7funu388j30te0a1dge.jpg" alt="示例"></p><h2 id="方法1：层次遍历"><a href="#方法1：层次遍历" class="headerlink" title="方法1：层次遍历"></a>方法1：层次遍历</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> nows=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()){</span><br><span class="line">            Node *node=que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node==<span class="literal">nullptr</span>)<span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            cnt++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt&lt;nows)</span><br><span class="line">                node-&gt;next = que.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                nows*=<span class="number">2</span>;</span><br><span class="line">                cnt=<span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="方法2：深度遍历"><a href="#方法2：深度遍历" class="headerlink" title="方法2：深度遍历"></a>方法2：深度遍历</h2><p>利用建立的next指针指向上一级的左孩子。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> _connect(Node* root,Node *nxt) {</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        root-&gt;next=nxt;</span><br><span class="line">        _connect(root-&gt;left,root-&gt;right);</span><br><span class="line">        _connect(root-&gt;right, root-&gt;next?root-&gt;next-&gt;left:<span class="literal">nullptr</span> );</span><br><span class="line">    }</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        _connect(root,<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计数排序与基数排序</title>
      <link href="/2020/02/23/ji-shu-pai-xu-yu-ji-shu-pai-xu/"/>
      <url>/2020/02/23/ji-shu-pai-xu-yu-ji-shu-pai-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>前提：知道数据的范围。</p><ol><li>统计每个数字出现的次数</li><li>求其前缀和，就能得到偏移</li><li>从尾开始放数据。</li></ol><p>伪代码：</p><div align="center" width="50%"><img width="50%" src="//tvax3.sinaimg.cn/large/005JD0Ejgy1gc6nzaxhm9j30st0ifjya.jpg"></div><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>前提：知道数据最大是多少位的数字。</p><ul><li>从个位开始对每一位进行一次稳定排序。</li></ul><p>用到的一个技巧是，除以1,10,100…使数字的各位依次降到个位，然后对10取余即可得到个位上的数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计数排序，假设每个数都是 [0,k] 之间的数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">B</span><span class="params">(A.size())</span>,<span class="title">C</span><span class="params">(k+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:A){ <span class="comment">//统计个数</span></span><br><span class="line">        C[it]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;C.<span class="built_in">size</span>();i++){ <span class="comment">//求前缀和，那么C数组保存的就是位置</span></span><br><span class="line">        C[i]+=C[i<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">        B[C[A[i]]<span class="number">-1</span>]=A[i];     <span class="comment">//排的是A数组，故A[i]，且将下标1转回下标0，故减1</span></span><br><span class="line">        C[A[i]]--;              <span class="comment">//同元素的位置应减一</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改版的计数排序，作为基数排序的调用</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counting_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> k,<span class="type">int</span> radix)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">B</span><span class="params">(A.size())</span>,<span class="title">C</span><span class="params">(k+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:A){ <span class="comment">//统计个数</span></span><br><span class="line">        <span class="type">int</span> x=it/radix %<span class="number">10</span>;    <span class="comment">//不同之处：基数排序从个位开始往上，故/1...%10</span></span><br><span class="line">        C[x]++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;C.<span class="built_in">size</span>();i++){ <span class="comment">//求前缀和，那么C数组保存的就是位置</span></span><br><span class="line">        C[i]+=C[i<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">        <span class="type">int</span> x=A[i]/radix%<span class="number">10</span>;</span><br><span class="line">        B[C[x]<span class="number">-1</span>]=A[i];     <span class="comment">//排的是A数组，故A[i]，且将下标1转回下标0，故减1</span></span><br><span class="line">        C[x]--;              <span class="comment">//同元素的位置应减一</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//基数排序，其中每一个数字都是 d 位的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radix_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> radix=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=d;i++){</span><br><span class="line">       A=<span class="built_in">counting_sort</span>(A,<span class="number">10</span>,radix); <span class="comment">//从个位开始，对每个数位进行稳定排序</span></span><br><span class="line">       radix*=<span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A{<span class="number">225</span>,<span class="number">14</span>,<span class="number">113</span>,<span class="number">31</span>,<span class="number">21</span>,<span class="number">11</span>,<span class="number">4</span>};</span><br><span class="line">    <span class="comment">//vector&lt;int&gt; ans=counting_sort(A,1000);</span></span><br><span class="line">    <span class="built_in">radix_sort</span>(A,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:A)cout&lt;&lt;it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map计数与最大公约数</title>
      <link href="/2020/02/23/map-ji-shu-yu-zui-da-gong-yue-shu/"/>
      <url>/2020/02/23/map-ji-shu-yu-zui-da-gong-yue-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（Leetcode-914-卡牌分组）"><a href="#题目（Leetcode-914-卡牌分组）" class="headerlink" title="题目（Leetcode 914. 卡牌分组）"></a>题目（<a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/">Leetcode 914. 卡牌分组</a>）</h2><p>给定一副牌，每张牌上都写着一个整数。</p><p>此时，你需要选定一个数字 <code>X</code>，使我们可以将整副牌按下述规则分成 1 组或更多组：</p><ul><li>每组都有&nbsp;<code>X</code>&nbsp;张牌。</li><li>组内所有的牌上都写着相同的整数。<br>仅当你可选的 <code>X &gt;= 2</code> 时返回&nbsp;<code>true</code>。</li></ul><p><strong>示例 1：</strong></p><blockquote><p>输入：[1,2,3,4,4,3,2,1]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：[1,1,1,2,2,2,3,3]<br>输出：false<br>解释：没有满足要求的分组。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：[1]<br>输出：false<br>解释：没有满足要求的分组。</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>输入：[1,1]<br>输出：true<br>解释：可行的分组是 [1,1]</p></blockquote><p><strong>示例 5：</strong></p><blockquote><p>输入：[1,1,2,2,2,2]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[2,2]</p></blockquote><p><strong>提示：</strong></p><blockquote><ol><li>1 &lt;= deck.length &lt;= 10000</li><li>0 &lt;= deck[i] &lt;&nbsp;10000</li></ol></blockquote><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>考察读题意的一道题，统计每种数字的个数，并求它们的最大公约数，若不为1则true。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> x==<span class="number">0</span>?y:<span class="built_in">gcd</span>(y%x,x);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; deck)</span> </span>{</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;deck.<span class="built_in">size</span>();i++)cnt[deck[i]]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt.<span class="built_in">size</span>()==deck.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator it=cnt.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> atom=it-&gt;second;</span><br><span class="line"></span><br><span class="line">        it++;</span><br><span class="line">        <span class="keyword">for</span>(;it!=cnt.<span class="built_in">end</span>();it++){</span><br><span class="line">            <span class="comment">//if(it-&gt;second%atom!=0)return false;  //不能这么判断，要最大公约数</span></span><br><span class="line">            <span class="comment">//错误判断1：每种数字的个数相等</span></span><br><span class="line">            <span class="comment">//错误判断2：每种数字的个数是最小个数的整数倍</span></span><br><span class="line">            <span class="comment">//最终：求所有个数的最大公约数，若存在则true</span></span><br><span class="line">            atom=<span class="built_in">gcd</span>(atom,it-&gt;second);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(atom!=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数学 </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Top(k)-问题</title>
      <link href="/2020/02/22/pre-k-wen-ti/"/>
      <url>/2020/02/22/pre-k-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（leetcode-面试题-17-14-最小k个数）"><a href="#题目（leetcode-面试题-17-14-最小k个数）" class="headerlink" title="题目（leetcode 面试题 17.14.最小k个数）"></a>题目（<a href="https://leetcode-cn.com/problems/smallest-k-lcci/">leetcode 面试题 17.14.最小k个数</a>）</h2><p>设计一个算法，找出数组中最小的k个数，并从小到大排序后输出。</p><p><strong>示例：</strong></p><blockquote><p>输入： [1,3,5,7,2,4,6,8]<br>输出： [1,2,3,4]</p></blockquote><p><strong>提示：</strong></p><ul><li>0 &lt;= len(array) &lt;= 100000</li><li>0 &lt;= k &lt;= min(100000, len(array))</li></ul><h2 id="直接全部排序（只适用于内存够的情况）"><a href="#直接全部排序（只适用于内存够的情况）" class="headerlink" title="直接全部排序（只适用于内存够的情况）"></a>直接全部排序（只适用于内存够的情况）</h2><p>我们使用快速排序，每次将子数组划分为三个部分，左半部分的元素都小于主元，右半部分的元素都大于主元，那么此时主元的位置就是排序好的位置。然后递归地分别对左半部分和右半部分进行排序，即可。</p><p>其中划分操作，假设x为划分的主元（通常为数组最后一个元素），我们需要对数组从左到右具体定义四个区域：<strong>元素&lt;=x的区域**，**元素&gt;x的区域</strong>，<strong>还没有遍历的部分</strong>，<strong>主元x</strong>。</p><p>如下图，我们需要两个哨兵 i 和 j 分别表示前两个区域的右边界。其中 i 初始化为 p-1 。</p><p>j从 p 出发到 r-1，如果遍历到的元素<code>A[j]</code>&lt;=主元x，则使<strong>元素&lt;=x的区域</strong>扩张。</p><p>即<code>i++</code>并将<code>A[i]</code>和<code>A[j]</code>交换。</p><p>此时<code>A[j]</code>将作为<strong>元素&lt;=x的区域**的右边界，而<code>A[i]</code>原来为**元素&gt;x的区域</strong>的左边界，现在作为<strong>元素&gt;x的区域</strong>的右边界。</p><blockquote><p>（注意：i 已经自加过了，所以不是<strong>元素&lt;=x的区域</strong>的左边界了）</p></blockquote><p>最后将主元与<strong>元素&gt;x的区域</strong>的左边界交换即<code>A[i+1]</code>，那么主元将到了正确的位置，这个位置就是i+1。</p><p>算法示例：<br><img src="//tva2.sinaimg.cn/large/005JD0Ejgy1gc530m5bcsj31em15rqiy.jpg" alt="快排思想"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">patition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="type">int</span> key=arr[right];</span><br><span class="line">        <span class="type">int</span> i=left<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> j=left;             <span class="comment">//！局部！</span></span><br><span class="line">        <span class="keyword">for</span>(;j&lt;right;j++){</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;=key){</span><br><span class="line">                i++;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j],arr[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">swap</span>(arr[i+<span class="number">1</span>],arr[right]);</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right){</span><br><span class="line">            <span class="type">int</span> p=<span class="built_in">patition</span>(arr,left,right);</span><br><span class="line">            <span class="built_in">quick_sort</span>(arr,left,p<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">quick_sort</span>(arr,p+<span class="number">1</span>,right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="built_in">quick_sort</span>(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line">            ans.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="快速排序（只适用于内存够的情况）"><a href="#快速排序（只适用于内存够的情况）" class="headerlink" title="快速排序（只适用于内存够的情况）"></a>快速排序（只适用于内存够的情况）</h2><p>使用快速排序时，我们并不需要对所有元素都进行排序，因此可以优化。</p><ol><li><p>因为我们只需要求前k个元素，那么划分出来的区域根本不在前k个元素的范围内，我们就不需要对这个区域进行排序。比如下图的<strong>元素&gt;x的区域</strong>：</p><div align="center" width="50%"><img src="//tva4.sinaimg.cn/large/005JD0Ejgy1gc54mkshoej31010nyq5g.jpg" alt="情况1" width="50%"></div></li><li><p>如果划分的区域<strong>全部</strong>或者<strong>部分</strong>位于 前k个元素 的范围内，那么就需要对这些区域进行<strong>完整的排序</strong>，包括不在 前k个元素范围的部分。比如下图的<strong>元素&gt;x的区域</strong>和上图的<strong>元素&lt;=x的区域</strong>：</p></li></ol><div align="center" width="50%"><img src="//tva3.sinaimg.cn/large/005JD0Ejgy1gc54q374laj30tq0kvwfx.jpg" alt="情况2" width="50%"></div><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">patition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="type">int</span> key=arr[right];</span><br><span class="line">        <span class="type">int</span> i=left<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> j=left;             <span class="comment">//！局部！</span></span><br><span class="line">        <span class="keyword">for</span>(;j&lt;right;j++){</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;=key){</span><br><span class="line">                i++;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j],arr[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">swap</span>(arr[i+<span class="number">1</span>],arr[right]);</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right &amp;&amp; left&lt;k){</span><br><span class="line">            <span class="type">int</span> p=<span class="built_in">patition</span>(arr,left,right);</span><br><span class="line">            <span class="built_in">quick_sort</span>(arr,left,p<span class="number">-1</span>,k);</span><br><span class="line">            <span class="keyword">if</span>(p&lt;k)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">quick_sort</span>(arr,p+<span class="number">1</span>,right,k);    <span class="comment">//注意右边必须是right</span></span><br><span class="line">            }   </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="built_in">quick_sort</span>(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>,k);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line">            ans.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="最大堆法"><a href="#最大堆法" class="headerlink" title="最大堆法"></a>最大堆法</h2><p>先对数组的前k个元素构造一个最大堆，然后遍历其他元素并维护这个最大堆。</p><p>其中，如果遍历到的元素小于堆顶，那么与堆顶交换，然后维护。</p><p>剩下的就是编写最大堆过程中的问题：具体错误位置在注释上。</p><ul><li>…</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lson(i) (i&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson(i) ((i&lt;&lt;1)+1)</span></span><br><span class="line"><span class="comment">//算法导论中的维护堆的函数没有考虑左右孩子下标越界。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">max_heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> i,<span class="type">int</span> heap_sz)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(i&gt;heap_sz)<span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> left=<span class="built_in">lson</span>(i);</span><br><span class="line">        <span class="type">int</span> right=<span class="built_in">rson</span>(i);</span><br><span class="line">        <span class="type">int</span> largest=i;         <span class="comment">//应建最大堆</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left&lt;=heap_sz &amp;&amp; arr[left]&gt;arr[i]){  <span class="comment">//错：下标，错：==size</span></span><br><span class="line">            largest=left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(right&lt;=heap_sz &amp;&amp; arr[right]&gt;arr[largest]){  <span class="comment">//错：下标</span></span><br><span class="line">            largest=right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(largest!=i){</span><br><span class="line">            <span class="built_in">swap</span>(arr[i],arr[largest]);</span><br><span class="line">            <span class="built_in">max_heapify</span>(arr,largest,heap_sz); <span class="comment">//错：交换后largest不再是最大，以它为根的堆可能不再是最大堆</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build_heap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> heap_sz)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=heap_sz/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--){       </span><br><span class="line">            <span class="built_in">max_heapify</span>(arr,i,heap_sz);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">my_heap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        arr.<span class="built_in">insert</span>(arr.<span class="built_in">begin</span>(),<span class="number">0</span>);  <span class="comment">//数组下标从1开始</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">build_heap</span>(arr,k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k+<span class="number">1</span>;i&lt;arr.<span class="built_in">size</span>();i++){   <span class="comment">//多插入了一个元素0，故下标从k+1开始</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;arr[<span class="number">1</span>]){             <span class="comment">//小于 最大堆顶的 应入堆</span></span><br><span class="line">                <span class="built_in">swap</span>(arr[<span class="number">1</span>],arr[i]);</span><br><span class="line">                <span class="built_in">max_heapify</span>(arr,<span class="number">1</span>,k);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//heap_sort</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&gt;<span class="number">1</span>;i--){</span><br><span class="line">            <span class="built_in">swap</span>(arr[i],arr[<span class="number">1</span>]);    <span class="comment">//注意不要用k，k是不变的</span></span><br><span class="line">            <span class="built_in">max_heapify</span>(arr,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>{</span><br><span class="line">        <span class="built_in">my_heap</span>(arr,k);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++){</span><br><span class="line">            ans.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><h2 id="Hash法"><a href="#Hash法" class="headerlink" title="Hash法"></a>Hash法</h2><h2 id="类似题目-leetcode-973-最接近原点的-K-个点"><a href="#类似题目-leetcode-973-最接近原点的-K-个点" class="headerlink" title="类似题目[leetcode 973. 最接近原点的 K 个点]"></a>类似题目[leetcode 973. 最接近原点的 K 个点]</h2><p><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/">题目链接</a></p><ol><li><p>排序</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kClosest</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> K) {</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        points.<span class="built_in">resize</span>(K);</span><br><span class="line">        <span class="keyword">return</span> points;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]*a[<span class="number">0</span>]+a[<span class="number">1</span>]*a[<span class="number">1</span>] &lt; b[<span class="number">0</span>]*b[<span class="number">0</span>]+b[<span class="number">1</span>]*b[<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li><li><p>快排前K个</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; key = points[right];</span><br><span class="line">        <span class="type">int</span> i = left<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> j = left;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; right){</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">cmp</span>(points[j], key)){</span><br><span class="line">                i++;</span><br><span class="line">                <span class="built_in">swap</span>(points[i], points[j]);</span><br><span class="line">            }</span><br><span class="line">            j++;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">swap</span>(points[right], points[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myQuickSort</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> K)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right &amp;&amp; left &lt; K){</span><br><span class="line">            <span class="type">int</span> j = <span class="built_in">partition</span>(points, left, right);</span><br><span class="line">            <span class="built_in">myQuickSort</span>(points, left, j<span class="number">-1</span>, K);</span><br><span class="line">            <span class="keyword">if</span>(j &lt; K)</span><br><span class="line">                <span class="built_in">myQuickSort</span>(points, j+<span class="number">1</span>, right, K);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kClosest</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> K) {</span><br><span class="line">        <span class="built_in">myQuickSort</span>(points, <span class="number">0</span>, points.<span class="built_in">size</span>()<span class="number">-1</span>, K);</span><br><span class="line">        <span class="comment">//sort(points.begin(), points.end(), cmp);</span></span><br><span class="line">        points.<span class="built_in">resize</span>(K);</span><br><span class="line">        <span class="keyword">return</span> points;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]*a[<span class="number">0</span>]+a[<span class="number">1</span>]*a[<span class="number">1</span>] &lt;= b[<span class="number">0</span>]*b[<span class="number">0</span>]+b[<span class="number">1</span>]*b[<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 最大堆 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 分治 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML基本语法</title>
      <link href="/2020/02/21/html-ji-ben-yu-fa/"/>
      <url>/2020/02/21/html-ji-ben-yu-fa/</url>
      
        <content type="html"><![CDATA[<p>HTML的基本语法单元称为标签。通常，标签用于指定内容的类别。对于每种标签，浏览器都有针对指定内容的默认外观规范。标签的语法是标签名称，并用尖括号（&lt;和&gt;）括起来。标签名称必须全部用小写字母书写。大多数标签成对出现：一个开始标签和一个结束标签。结束标记的名称（如果需要的话）是其对应的开始标记的名称，并在其开头加上斜杠。例如，如果标记名称为p，则其结束标记为&lt;/ p&gt;。标签及其结束标签之间出现的是标签的内容。HTML文档的浏览器显示可显示所有文档标签的内容；这是文档要描述的信息。并非所有标签都可以包含内容。</p><p>开头标签及其结束标签一起为它们所包围的内容指定了一个容器。容器及其内容一起称为元素。例如，考虑以下元素：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> This is simple stuff. <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>用于指定标签替代含义的属性写在开头标签名称及其右括号之间。它们以关键字形式指定，这意味着该属性的名称后跟一个等号和该属性的值。属性名称（如标签名称）以小写字母书写。属性值必须用双引号分隔。本章的其余部分将提供许多属性示例。</p><p>程序中的注释增加了这些程序的可读性。HTML中的注释具有相同的目的。它们以HTML形式编写，格式如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 我是被注释掉的内容 --&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>浏览器会忽略HTML注释-它们仅用于人员。注释可以根据需要分布在任意多行中。例如，您可能有以下注释：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    嘻嘻</span></span><br><span class="line"><span class="comment">    我可以多行。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>信息注释在HTML文档中与在程序中一样重要。文档有时会有很长的标记行序列，这些序列一起构成显示的一部分。如果这样的序列前面没有说明其目的的注释，则文档阅读器可能很难确定为什么存在该序列。与程序一样，对每一行进行注释既乏味又适得其反。但是，要使文档（或程序）更易于理解，必须先注释掉标记行的逻辑集合。</p><p>除了注释之外，HTML文档中可能还会出现其他几种浏览器会忽略的文本。浏览器将忽略所有无法识别的标签。他们也忽略换行符。可以指定显示内容中显示的换行符，但只能使用为此目的设计的标签。多个空格和制表符也是如此。</p><p>引入HTML时，程序员发现它有点令人沮丧。在程序中，这些语句准确指定了计算机必须执行的操作。HTML标记被视为对浏览器的建议。如果保留字在程序中拼写错误，则语言实现系统通常会检测到该错误，并且不会执行该程序。但是，拼写错误的标签名称通常会导致该标签被浏览器忽略，而不会向用户表明已遗漏任何内容。甚至允许浏览器忽略他们识别的标签。此外，用户可以配置其浏览器以不同方式对特定标签做出反应。</p><h2 id="标准HTML文档结构"><a href="#标准HTML文档结构" class="headerlink" title="标准HTML文档结构"></a>标准HTML文档结构</h2><p>每个HTML文档的第一行是DOCTYPE命令，该命令指定文档所遵循的特定SGML文档类型定义（DTD）。对于HTML，此声明只是以下内容：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>HTML文档必须包含四个标记<code>&lt;html&gt;</code>，<code>&lt;head&gt;</code>，<code>&lt;title&gt;</code>和<code>&lt;body&gt;</code>。标记标识文档的根元素。因此，HTML文档在DOCTYPE命令之后始终带有<code>&lt;html&gt;</code>标记，并且它们始终以结束html标记&lt;/ html&gt;结尾。html元素包含lang属性，该属性指定编写文档所用的语言，如以下元素所示：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>在此示例中，语言指定为“ en”，表示英语</p><p>HTML文档由两部分组成，即头和主体。head元素提供有关文档的信息，但不提供其内容。head元素始终包含两个简单元素，title元素和meta元素。meta元素用于提供有关文档的其他信息。它没有内容；相反，提供的所有信息均使用属性指定。至少，meta标签会指定用于编写文档的字符集。Web上最流行的国际字符集是8位Unicode转换格式（UTF-8）。该字符集使用1个字节到6个字节来表示一个字符，但与ASCII字符集向后兼容。通过使UTF-8中的所有单字节字符都与ASCII字符相对应，可以实现这种兼容性。以下是必要的meta元素：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>此元素末尾的斜杠表示它没有结束标记，它是一个组合的开始和结束标记。</p><p>标题元素的内容由浏览器显示在其显示窗口的顶部，通常在浏览器窗口的标题栏中.</p><p>body主体提供其内容.</p><p>以下是说明基本结构的骨架文档：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">&lt;!–– File name and document purpose ––&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span> = <span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span> A title for the document <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span> = <span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>注意，我们为文档使用了一种简单的格式设置模式，类似于程序中经常使用的格式设置模式。每当元素嵌套在前一个元素内时，嵌套元素都会缩进。在本书中，我们将嵌套元素缩进两个空格，尽管该数字没有什么特别的。与程序一样，缩进模式用于增强可读性.</p><h2 id="基本的标签"><a href="#基本的标签" class="headerlink" title="基本的标签"></a>基本的标签</h2><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>文本通常组织在文档主体中的段落中。XHTML标准不允许将文本直接放置在文档主体中。相反，文本通常放置在段落元素的内容中，其名称为p。在显示文本时，浏览器会在浏览器窗口中的行中放入尽可能多的单词。浏览器在每行末尾提供一个换行符。如2.2节所述，浏览器会忽略文本中嵌入的换行符。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>   </span><br><span class="line">    Mary </span><br><span class="line">had a little lamb, </span><br><span class="line">its </span><br><span class="line">fleece</span><br><span class="line"> was white as snow. </span><br><span class="line"> And everywhere that  </span><br><span class="line"> Mary went, the lamb was sure to go.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>实际效果如下：</p><blockquote><p>       Mary had a little lamb, its fleece was white as snow.  And everywhere that   Mary went, the lamb was sure to go.</p></blockquote><p>请注意，源段落元素中的多个空格被单个空格代替。</p><h3 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h3><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">Mary had a little lamb, <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    its fleece was white as snow.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>实际效果如下：</p><blockquote><p>Mary had a little lamb, <br>    its fleece was white as snow.</p></blockquote>### 保留空白符有时需要保留文本中的空白，即防止浏览器消除多个空格并忽略嵌入的换行符。可以使用pre标记指定。<p>请注意，pre元素的内容以等宽字体显示，而不是以默认字体显示。pre元素不仅保持源的换行符，还保留字符和行间距。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">Mary</span><br><span class="line">    had a    </span><br><span class="line">        little     </span><br><span class="line">               lamb</span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>实际效果如下：</p><blockquote><pre>Mary    had a            little                    lamb</pre></blockquote>pre元素实际上可以包含任何其他标记，但那些导致段落中断的标记除外，例如段落元素。因为其他标记可以出现在前置元素中，所以必须避免文本内容中的特殊字符，例如&lt;。在2.4.7节中，我们将描述如何安全地包含诸如字符实体之类的字符。<h3 id="标题符"><a href="#标题符" class="headerlink" title="标题符"></a>标题符</h3><p>文本通常通过以标题开头的每个部分将其分为文档中的各个部分。较大的部分有时具有比嵌套在其中的部分的标题更突出的标题。在HTML中，由标签<code>&lt;h1&gt;</code>，<code>&lt;h2&gt;</code>，<code>&lt;h3&gt;</code>，<code>&lt;h4&gt;</code>，<code>&lt;h5&gt;</code>和<code>&lt;h6&gt;</code>指定的标题分为六个级别，其中<code>&lt;h1&gt;</code>指定最高级别的标题。标题通常以黑体字显示，其默认字体大小取决于标题标记中的数字。在大多数浏览器中，<code>&lt;h1&gt;</code>，<code>&lt;h2&gt;</code>和<code>&lt;h3&gt;</code>使用的字体大小大于文本的默认大小，<code>&lt;h4&gt;</code>使用默认的大小，并且<code>&lt;h5&gt;</code>和<code>&lt;h6&gt;</code>使用较小的大小。标题标签始终会中断当前行，因此其内容始终会出现在新行中。浏览器通常在所有标题前后插入一些垂直空间。</p><h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>有时我们希望将文本块与文档中正常文本流分开。在许多情况下，这样的块是长引号。<code>&lt;blockquote&gt;</code>标签是针对这种情况而设计的。浏览器设计者可以确定如何使<code>&lt;blockquote&gt;</code>的内容与周围的文本看起来不同。但是，在大多数情况下，文本的两边都只是缩进。</p><h3 id="字体样式和大小"><a href="#字体样式和大小" class="headerlink" title="字体样式和大小"></a>字体样式和大小</h3><p>早期的Web设计人员使用标记的集合来设置字体样式和大小。例如，<code>&lt;i&gt;</code>指定斜体，而<code>&lt;b&gt;</code>指定粗体。自层叠样式表问世以来（请参见第3章），使用这些标签已成为过去式。有一些仍在广泛使用的字体标签，称为基于内容的样式标签。这些标记称为基于内容的，因为它们指示出现在其内容中的文本样式。三种最常用的基于内容的标签是强调标签，强标签和代码标签。</p><p>强调元素指定其文本内容是特殊的，并应以某种表明这种区别的方式进行显示。大多数浏览器对此类内容使用斜体。</p><p>强元素“强”类似于强调标签，但更是如此。浏览器通常以粗体设置强元素的内容。</p><p>代码元素code用于指定等宽字体，通常用于程序代码。例如，考虑以下元素：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span> cost = quantity * price <span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>实际效果如下：</p><blockquote><code> cost = quantity * price </code></blockquote><p>下标和上标字符可以分别由sub和sup指定。这些不是基于内容的标签。例如，</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X<span class="tag">&lt;<span class="name">sub</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sub</span>&gt;</span><span class="tag">&lt;<span class="name">sup</span>&gt;</span>3<span class="tag">&lt;/<span class="name">sup</span>&gt;</span> + y<span class="tag">&lt;<span class="name">sub</span>&gt;</span>1<span class="tag">&lt;/<span class="name">sub</span>&gt;</span><span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span> </span><br></pre></td></tr></tbody></table></figure><p>实际效果如下：</p><blockquote>X<sub>2</sub><sup>3</sup> + y<sub>1</sub><sup>2</sup> </blockquote><h2 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h2><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">            Wylin</span><br><span class="line">        <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>NEW WEBSITE<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>New headline 1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>some text.some text.some text...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h4</span>&gt;</span>New headline 2<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>some text. some text. some text...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        ...!</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>效果：<br><img src="//tvax4.sinaimg.cn/large/005JD0Ejgy1gc4b596ptij30wo0lmt9v.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议学习</title>
      <link href="/2020/02/21/http-xie-yi-ru-men/"/>
      <url>/2020/02/21/http-xie-yi-ru-men/</url>
      
        <content type="html"><![CDATA[<h2 id="与HTTP关系密切的协议"><a href="#与HTTP关系密切的协议" class="headerlink" title="与HTTP关系密切的协议"></a>与HTTP关系密切的协议</h2><h3 id="负责传输的-IP-协议"><a href="#负责传输的-IP-协议" class="headerlink" title="负责传输的 IP 协议"></a>负责传输的 IP 协议</h3><p>按层次分，IP（Internet Protocol）网际协议位于网络层。Internet Protocol 这个名称可能听起来有点夸张，但事实正是如此，因为几乎 所有使用网络的系统都会用到 IP 协议。TCP/IP 协议族中的 IP 指的就 是网际协议，协议名称中占据了一半位置，其重要性可见一斑。可能 有人会把“IP”和“IP 地址”搞混，“IP”其实是一种协议的名称。</p><p>IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方 那里，则需要满足各类条件。其中两个重要的条件是IP地址和 MAC 地址（Media Access Control Address）。</p><p>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定 地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。</p><p><strong>使用 ARP 协议凭借 MAC 地址进行通信</strong></p><p>IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网 （LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转 才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方 的 IP 地址就可以反查出对应的 MAC 地址。</p><p><strong>没有人能够全面掌握互联网中的传输状况</strong></p><p>在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只 能获悉很粗略的传输路线。<br>这种机制称为路由选择（routing），有点像快递公司的送货过程。想 要寄快递的人，只要将自己的货物送到集散中心，就可以知道快递公 司是否肯收件发货，该快递公司的集散中心检查货物的送达地址，明 确下站该送往哪个区域的集散中心。接着，那个区域的集散中心自会 判断是否能送到对方的家中。</p><p>我们是想通过这个比喻说明，无论哪台计算机、哪台网络设备，它们 都无法全面掌握互联网中的细节。</p><h3 id="确保可靠性的TCP协议"><a href="#确保可靠性的TCP协议" class="headerlink" title="确保可靠性的TCP协议"></a>确保可靠性的TCP协议</h3><p>按层次分，TCP 位于传输层，提供可靠的字节流服务。</p><p>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大 块数据分割成以报文段（segment）为单位的数据包进行管理。而可 靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之， TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够 确认数据最终是否送达到对方。</p><p><strong>确保数据能到达目标</strong></p><p>为了准确无误地将数据送达目标处，TCP 协议采用了三次握手 （three-way handshaking）策略。用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达</p><p>握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。</p><p>发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后， 回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发 送端再回传一个带 ACK 标志的数据包，代表“握手”结束。</p><p>若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发 送相同的数据包。</p><p><strong>三次握手</strong><br><img src="//tva4.sinaimg.cn/large/005JD0Ejgy1gc3ypbofhrj312s0kadz2.jpg"></p><p>除了上述三次握手，TCP 协议还有其他各种手段来保证通信的可靠性。</p><h3 id="负责域名解析的-DNS-服务"><a href="#负责域名解析的-DNS-服务" class="headerlink" title="负责域名解析的 DNS 服务"></a>负责域名解析的 DNS 服务</h3><p>DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的 协议。它提供域名到 IP 地址之间的解析服务。</p><p>计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如 <a href="http://www.hackr.jp./">www.hackr.jp。</a></p><p>用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表 示形式来指定计算机名更符合人类的记忆习惯。</p><p>但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅 长处理一长串数字。</p><p>为了解决上述的问题，DNS 服务应运而生。DNS 协议提供通过域名 查找 IP 地址，或逆向从 IP 地址反查域名的服务</p><h2 id="在浏览器输入网址，回车后发生了什么？"><a href="#在浏览器输入网址，回车后发生了什么？" class="headerlink" title="在浏览器输入网址，回车后发生了什么？"></a>在浏览器输入网址，回车后发生了什么？</h2><p><img src="//tva4.sinaimg.cn/large/005JD0Ejgy1gc3zp7xrl3j30rv14hqua.jpg"></p><h2 id="HTTP包含两个阶段："><a href="#HTTP包含两个阶段：" class="headerlink" title="HTTP包含两个阶段："></a>HTTP包含两个阶段：</h2><p>请求和响应。</p><p>HTTP 协议和 TCP/IP 协议族内的其他众多的协议相同，用于客户端和 服务器之间的通信。</p><p>请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一 端称为服务器端。</p><h2 id="HTTP通信组成"><a href="#HTTP通信组成" class="headerlink" title="HTTP通信组成"></a>HTTP通信组成</h2><ul><li>首部字段包含有关通信的信息；</li><li>内容实体包含通讯数据（如果有）。</li></ul><p><strong>首部字段分类：</strong></p><ol><li>常规：用于常规信息，例如日期</li><li>请求：包含在请求首部字段中，仅在请求报文使用</li><li>响应：用于响应首部字段，仅在响应报文使用</li><li>实体：在请求和响应首部字段中均使用</li></ol><p>一个常见的请求字段是“接受”字段，它指定浏览器对所请求文档的MIME类型的偏好。如果浏览器愿意接受一种以上格式的文档，则可以指定多个“接受”字段。例如，我们可能具有以下任何一项：</p><ul><li>Accept: text/plain</li><li>Accept: text/html</li><li>Accept: image/gif</li></ul><p>If-Modified-Since：date请求字段指定仅在自给定日期以来对其进行了修改的情况下才应发送所请求的文件。</p><p>如果请求具有主体，则必须使用Content-length字段来指定该主体的长度，该字段以字节为单位给出响应主体的长度。POST方法请求需要此字段，因为它们将数据发送到服务器。</p><p>请求的标头必须后跟空白行，该行用于将标头与请求的正文分开。使用GET，HEAD和DELETE方法的请求没有正文。在这些情况下，空行表示请求结束。</p><h3 id="请求报文："><a href="#请求报文：" class="headerlink" title="请求报文："></a><strong>请求报文：</strong></h3><ul><li>请求方法、请求URI、协议版本、</li><li>可选的请求首部字段 （可能多个）</li><li>空白行</li><li>内容实体。</li></ul><h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器 端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保 持原样返回；如果是像 CGI（Common Gateway Interface，通用网关接 口）那样的程序，则返回经过执行后的输出结果。</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>POST最初用于诸如将新闻文章发布到新闻组之类的任务。</p><p>现在，它最常见的用途是将表单数据从浏览器发送到服务器，以及在服务器上执行将处理数据的服务器驻留程序的请求。</p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请 求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。</p><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请 求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。</p><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按 请求 URI 删除指定的资源。</p><p>但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机 制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用 程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。<br><img src="//tvax2.sinaimg.cn/large/005JD0Ejgy1gc4268wo3aj315x0e2grt.jpg" alt="请求报文"></p><h3 id="响应报文："><a href="#响应报文：" class="headerlink" title="响应报文："></a><strong>响应报文：</strong></h3><ul><li>协议版本、状态码（表示请求成功或失败的数字代 码）、用以解释状态码的原因短语</li><li>可选的响应首部字段</li><li>空白行</li><li>实体主体。</li></ul><p>在状态行之后，服务器发送响应报文，其中可以包含有关响应的几行信息，每行都以字段的形式。标头的唯一必填字段是Content-type</p><p>与请求报文一样，响应报文必须后跟空白行。响应数据跟随空白行。在前面的示例中，响应主体将是HTML文件response.html。</p><p>HTTP1.1的默认操作是保持连接开放一段时间，以便客户端可以在短时间内发出多个请求<br>无需重新建立与服务器的通信连接</p><h4 id="状态码的类别"><a href="#状态码的类别" class="headerlink" title="状态码的类别"></a>状态码的类别</h4><p>一种更常见的状态代码是一个用户从不希望看到的代码：404 Not Found，这表示找不到所请求的文件。当然，用户希望看到200 OK，因为这意味着该请求已正确处理。500代码表示服务器遇到问题，无法满足请求。<br><img src="//tvax4.sinaimg.cn/large/005JD0Ejgy1gc41mi4h5ij30yv0bbwh6.jpg" alt="状态码"></p><p><img src="//tva1.sinaimg.cn/large/005JD0Ejgy1gc426qdtnoj315l0mztid.jpg" alt="响应报文"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程--《人月神话》</title>
      <link href="/2020/02/20/ruan-jian-gong-cheng-ren-yue-shen-hua/"/>
      <url>/2020/02/20/ruan-jian-gong-cheng-ren-yue-shen-hua/</url>
      
        <content type="html"><![CDATA[<p>软件工程布置的作业，读完写读后感，感觉能学到一些观点，当然有些也已经略显过时，毕竟1975出版的书，真是历经岁月。</p><p>不得不说的是，作为一本计算机类的书，历经45年后，再读，发现里面的大多数观点也不显过时，实属不易。我觉得，这本书十分适合软件项目管理者学习，当然里面也有些建议是面向个人开发者的。在此前，我接触的计算机书籍都是关于个人编程开发，没有软件团队这方面的。这本书正好填补了我的缺口，算是作为软件工程的启蒙书吧。</p><h2 id="书中主要内容"><a href="#书中主要内容" class="headerlink" title="书中主要内容"></a>书中主要内容</h2><p>作者是FrederickP.Brooks.Jr.。他是一位计算机科学教授，也是“IBM 360系统之父”。在阅读本书的过程中，我也发现，Brooks博士多次以IBM360项目的开发过程为例，以管理者的角度向我们讲述其中的道理。以切身经历作为讲解，更能接近问题的本质，也易于读者理解。不过我更想说的是，Brooks博士的行文更像是一个知识渊博的研究类学者，偏向于物理的那种。比如在说明软件工程的复杂性时，Brooks博士类比了分子的无序性，又比如在未雨绸缪那一章写道：系统软件开发是减少混乱度（减少熵）的过程，所以它本身是处于亚稳态的。软件维护是提高混乱度（增加熵）的过程，即使是最熟练的软件维护工作，也只是放缓了系统退化 到非稳态的进程。Brooks博士将开发一个软件项目比做是物理中的减少熵的过程，而维护软件是增加熵，我觉得十分生动而又恰当。</p><p>通读全书，本书由三部分组成，其中第一部分是原版的《人月神话》，而第二部分则是对上一版本的主要观点的总结、补充和纠错，最后一个部分则是结束语。其中，人月神话作为第二章，作者探讨了大量软件项目缺乏合理的时间进度的原因—-项目管理者认为人力与时间可以互换。也就是当管理者意识项目进度偏离正常轨迹时，通常的做法是加大人力投入。但是这种做法并不是普遍适用的，特殊情况下将无异于火上浇油，从而导致灾难性的循环。</p><p>这种情况就是当前任务的执行先后有限制，必须先完成这个任务才能开始做那一个任务，这就好比数据结构中AOV网。在此时，新加入人员需要与原开发人员进行沟通。作者将这种沟通的负担分为两部分，分别是培训和相互之间的交流。所以过度加入人力可能会得到适得其反的效果。</p><h2 id="令人印象深刻的章节"><a href="#令人印象深刻的章节" class="headerlink" title="令人印象深刻的章节"></a>令人印象深刻的章节</h2><p>Brooks博士有一个十分重要的观点，就是概念的一致性。第 4、5、6 章所讨论的获取概念完整性的途径，就是直接面对这些问题。在一个软件项目中，Brooks博士推崇在概念完整性上实施“独裁专制”，尽管好的创意往往是开发者在实现功能的过程中发现的。但是就像同一个老师教出来的学生，每人的编程风格都各不相同，如果任由开发者挥洒创意，必然会导致软件系统的概念不完整。在我看来，现在能够体现概念一致性的软件系统的概念一致性的例子是苹果公司开发的Mac系统和IOS系统。从界面风格来看，尽管一个是电脑系统一个是手机系统，但是两者作为苹果公司的产品，具有高度的统一性。与此同时，对比Windows系统，Mac系统中的系统软件和用户软件界面十分统一，看起来很舒服，因为Mac系统自诞生以来就强制用户软件界面窗口的设计与系统相统一。而Windows系统，不同时期的界面具有不同时期的风格，就比如从Win10系统运行一个Win XP系统时期开发的软件，其界面与Win10十分不协调。当然目前Win10也在竭力“打补丁”，进行界面统一化，比如推出Microsoft Store，里面的应用都是UWP应用。</p><p>整体与部分章节：好的自顶向下设计从几个方面避免了 bug。首先，清晰的结构和表达方式更容易对需求 和模块功能进行精确的描述。其次，模块分割和模块独立性避免了系统级的 bug。另外，细 节的隐藏使结构上的缺陷更加容易识别。第四，设计在每个精化步骤的层次上是可以测试的， 所以测试可以尽早开始，并且每个步骤的重点可以放在合适的级别上。</p><p>在祸起萧墙那一章：棒球队队长知道，进取这种心理素质，是很多优秀队员和团队不可缺少的。它表现为“要求跑得更快”，“要求移动得更加迅速”，“更加努力尝试”。进取提供了缓冲和储备，使开发队伍能够处理常规的异常事件，可以预计和 防止小的灾祸。</p><p>又比如，Brooks博士在削足适履这一章节中，讲述了一些关于成本的教训。其中一个是关于成员之间的沟通的：在每个模块分配功能之前，已编制了空间的预算。其结果是，任何在规模上碰到问题的程序员，会检查自己的代码，看是否能将其中一部分扔给其他人。因此，控制程序所管理的缓冲区成为了用户空间的一部分。更严重的是，所有的控制模块都有相同的问题，彻底影响了系统的稳定和安全性。</p><p>虽然我还没有进入职场，但我觉得这种情况在实际中是很容易发生的：为了满足目标，程序员过于关注自己负责的开发工作，很难从中跳出来去考虑局部与整体的关系，更糟糕的是，成员之间缺乏有效的沟通，不能及时地发现问题，从而导致更糟糕地结果。这就需要系统结构师时刻保持警惕，以确保连贯的系统完整性。与此同时，也要注意培养开发人员从系统整体出发、面向用户的态度。</p><p>此外，从这个教训中还能得到的启示是，对于每一个模块的功能，都需要有确切的定义，而不是只指明大小是多少。</p><p>削足适履这一章中还提到另一个观点：数据的表现形式是编程的根本。对于这个我深有体会，不过和作者描述的不太一样。作者使用了数据形式的重新表达来阐述这个观点，举的例子是一个年轻人开发控制台解释器，但是他发现用户交互慢且空间昂贵，于是编写了一个解释器的解释器，这个编译器使用密集又专业的代码来表达自身从而节省了外部储存。</p><p>而在我的算法学习过程中，遇到过一个叫最长回文子串的问题。这是一个动态规划的问题，从直观上可以很容易想到其中的分治思想：比如一个子串<code>"aba"</code>，它是一个回文串，而在其左右再加上相同的字符”c”，得到的子串仍然是回文串<code>"cabac"</code>。但是，如何将这种思想转换成实在的代码呢？实际上最大的问题是如何将子串这种数据表现成代码？也就是数据的表现形式。仔细思考一下就会发现，要定位一个子串，一种办法是保存起始下标和末尾下标；另一种方法是保存起始下标，以及子串的长度。显然，无论怎样，都是需要至少二维的信息才能确定一个子串，因此可以用二维数组<code>dp[i][j]</code>，表示<code>i...j</code>的子串是否为回文串。这样，递推方程就能很容易得到了。不过，本人觉得自己在编程语言和数据结构的理解还不够深入，对于如何寻找最佳的数据表现方式还需要不断的学习。</p><h2 id="书中与时代落后的部分"><a href="#书中与时代落后的部分" class="headerlink" title="书中与时代落后的部分"></a>书中与时代落后的部分</h2><p>作者对于原版中的与当代不适合的部分，也都一一指出了，不再赘述。</p><p>比如在干将莫邪那一章，作者写道：系统编程需要什么样的高级语言呢？现在可供合理选择的语言是 PL/I6。看看现在的高级语言，额额，就知道这句话肯定过时了。</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络体系结构:OSI-RM与TCP/IP</title>
      <link href="/2020/02/19/wang-luo-ti-xi-jie-gou/"/>
      <url>/2020/02/19/wang-luo-ti-xi-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是协议？"><a href="#什么是协议？" class="headerlink" title="什么是协议？"></a>什么是协议？</h2><p>协议是指通信双方必须遵守的、控制信息交换的<strong>规则的集合</strong>。<br>协议是网络技术中为数据交换而设置的标准、规则和约定的集合。</p><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如， 如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通 信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之 间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为 协议（protocol）。</p><h2 id="协议包含的三要素"><a href="#协议包含的三要素" class="headerlink" title="协议包含的三要素"></a>协议包含的三要素</h2><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><p>数据和控制信息的格式、编码规则。也就是数据与控制信息的结构或格式，确定通信时采用的数据格式，编码及信号电平等，回答“怎么讲”。</p><h3 id="语义："><a href="#语义：" class="headerlink" title="语义："></a>语义：</h3><p>协议控制信息的具体含义。也就是对构成协议的协议元素含义的解释“讲什么” 。</p><h3 id="同步（定时）："><a href="#同步（定时）：" class="headerlink" title="同步（定时）："></a>同步（定时）：</h3><p>数据和控制信息的收发同步和排序。即规定了事件的执行顺序。</p><h2 id="协议层次结构"><a href="#协议层次结构" class="headerlink" title="协议层次结构"></a>协议层次结构</h2><p>协议：水平范围<br>服务：垂直范围</p><h3 id="网络协议采用分层的形式实现的好处是什么？"><a href="#网络协议采用分层的形式实现的好处是什么？" class="headerlink" title="网络协议采用分层的形式实现的好处是什么？"></a>网络协议采用分层的形式实现的好处是什么？</h3><ul><li>各层相互独立、功能明确。 每一层发生改变不会影响其他层。</li><li>各层对等实体间进行逻辑通信。各种逻辑通信均有对应协议，本层为上层提供服务，也享受下层服务。</li><li>结构上可分割开：功能作为分层基础，每一层只需与上下层相关，各司 其职，各尽其责。</li><li>易于实现和维护。</li><li>能促进标准化工作</li></ul><h3 id="OSI-RM模型"><a href="#OSI-RM模型" class="headerlink" title="OSI-RM模型"></a>OSI-RM模型</h3><p>开放系统互连基本参考模型, 由国际标准化组织（ISO）提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。</p><p>高三层可合并，面向信息处理。低四层面向数据通信。<br><img src="//tvax1.sinaimg.cn/large/005JD0Ejgy1gc20ymafsmj31fg0uvadx.jpg" alt="OSI-RM模型"></p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>为应用程序通过网络服务，它包含了各种用户使用的协议。 </p><h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>用于处理在两个通信系统中交换信息的表示方式，主要包括数据格式变换、数据的加密与解密、数据压缩与恢复等功能。</p><p>直接为应用层提供服务</p><h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>负责维护通信中两个节点之间的会话连接的建立、维护和断开，以及数据的交换。</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>向用户提供端到端（end-to-end）的数据传输服务，实现为上层屏蔽低层的数据传输问题。</p><p>TCP/UDP</p><p>端口到端口的通信</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>为分组交换网络上的不同主机提供通信服务，为以分组为单位的数据报通过通信子网选择适当的路由，并实现拥塞控制、网络互连等功能。</p><p>传输基本单位：分组</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>在物理层提供服务的基础上，在通信的实体间建立数据链路连接，传输以帧(frame)为单位的数据包，并采取差错控制和流量控制的方法，使有差错的物理线路变成无差错的数据链路。</p><p>传输基本单位：帧</p><p>帧比分组长，帧封装了分组</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>利用传输介质为通信的网络节点之间建立、维护和释放物理连接，实现比特流的透明传输，进而为数据链路层提供数据传输服务。</p><p>位于：网卡和网线的接口</p><p>传输基本单位：比特</p><h3 id="TCP-IP体系结构"><a href="#TCP-IP体系结构" class="headerlink" title="TCP/IP体系结构"></a>TCP/IP体系结构</h3><p>TCP/IP模型中的核心协议是TCP、UDP和IP，且呈现漏斗状，IP协议处于漏斗的最窄处。<br><img src="//tvax1.sinaimg.cn/mw690/005JD0Ejgy1gc20m6hl67j31kb0t0adq.jpg" alt="TCP/IP"></p><h4 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h4><p>应用层决定了向用户提供应用服务时通信的活动。</p><p>TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域 名系统）服务就是其中两类。</p><p>应用层的协议相对较多，分别使用传输层中的UDP和TCP协议进行承载，它们位于各自的上方。 </p><p>协议有：SMTP、Telnet、FTP等，SNMP、RIP等, HTTP 协议也处于该层。</p><h4 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h4><p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据 传输。</p><p>协议有：TCP、UDP。</p><p>在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报 协议）。</p><h4 id="互连网络层"><a href="#互连网络层" class="headerlink" title="互连网络层"></a>互连网络层</h4><p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数 据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</p><p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所 起的作用就是在众多的选项内选择一条传输路线。</p><p>网络层除核心协议IP外，还有ICMP、IGMP、ARP和RARP，分别位于IP协议的上下方。</p><p>协议有：ICMP, IGMP  IP   ARP/RARP</p><p>IP协议掩盖了物理网络的差异</p><h4 id="网络接入层"><a href="#网络接入层" class="headerlink" title="网络接入层"></a>网络接入层</h4><p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱 动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在 链路层的作用范围之内。</p><p>各类物理网络，如FDDI, Ethernet等<br><img src="//tva2.sinaimg.cn/large/005JD0Ejgy1gc20wjvmfvj31ft0v177x.jpg" alt="TCP/IP"></p><h2 id="名词常识"><a href="#名词常识" class="headerlink" title="名词常识"></a>名词常识</h2><ul><li><p>ITU：<br>International Telecommunication Union 国际电信联盟</p></li><li><p>IEEE：<br>Institute of Electrical and Electronics Engineers 电气和电子工程师学会</p></li><li><p>3GPP：<br>3rd Generation Partnership Project 第3代移动通信(3G)技术规范机构</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络概述</title>
      <link href="/2020/02/17/ji-suan-ji-wang-luo-gai-shu/"/>
      <url>/2020/02/17/ji-suan-ji-wang-luo-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络定义"><a href="#计算机网络定义" class="headerlink" title="计算机网络定义"></a>计算机网络定义</h2><p>把分布在不同地点且<strong>具有独立功能</strong>的计算机，通过<strong>通信设备和通信线路</strong>连接起来，在<strong>功能完善的网络软件</strong>运行环境下，以实现<strong>资源共享</strong>为目标的系统。</p><h2 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h2><ul><li><strong>通信子网</strong>：网络信息的传输和交换。包括集线器、路由器、交换机等等，通信线路。</li><li><strong>终端系统</strong>：负责信息的处理。包括主机、服务器等。</li></ul><h2 id="计算机通信与网络发展的四个阶段"><a href="#计算机通信与网络发展的四个阶段" class="headerlink" title="计算机通信与网络发展的四个阶段"></a>计算机通信与网络发展的四个阶段</h2><h3 id="1、面向终端的计算机网络"><a href="#1、面向终端的计算机网络" class="headerlink" title="1、面向终端的计算机网络"></a>1、面向终端的计算机网络</h3><p>以主机为中心，主机控制整个系统的全部运行功能和通信过程，终端仅提供输入输出的功能，完全作为主机的从属设备.</p><p>特点：</p><ul><li><strong>系统由主机和终端构成，数据处理和通信处理都是由主机完成。</strong></li><li><strong>主机通信开销较大，通信线路利用率低，对主机系统依赖性较大。</strong></li><li>集中式处理</li><li>有限的数据传输速率</li><li>系统的可靠性和性能取决于主机的可靠性和性能，便于维护、管理。数据的一致性好。</li><li>规模小，终端数量少；</li></ul><h3 id="2、多台计算机互连的计算机网络"><a href="#2、多台计算机互连的计算机网络" class="headerlink" title="2、多台计算机互连的计算机网络"></a>2、多台计算机互连的计算机网络</h3><p>以网络为中心，主机都处在网络的外围。</p><p>成果：</p><ul><li><strong>提出分组交换技术</strong></li><li><strong>形成TCP/IP协议雏形</strong></li><li>提出以太网技术</li></ul><p>特点：</p><ul><li>优点是建立了计算机与计算机的互连与通信，实现了计算机资源的共享。</li><li>但缺点是没有形成统一的互连标准，使网络在规模与应用等方面受到了限制。</li></ul><h3 id="3、面向标准化的计算机网络"><a href="#3、面向标准化的计算机网络" class="headerlink" title="3、面向标准化的计算机网络"></a>3、面向标准化的计算机网络</h3><p>标志性成果：</p><ul><li>制定网络体系结构：开放系统互连基本参考模型（OSI-RM模型）</li><li>形成TCP/IP系统结构</li><li>形成以太网、公用数据网等标准，如X.25标准等X系列建议</li><li>提出Web技术与开发浏览器</li></ul><h3 id="4、面向全球互连的计算机网络"><a href="#4、面向全球互连的计算机网络" class="headerlink" title="4、面向全球互连的计算机网络"></a>4、面向全球互连的计算机网络</h3><p>美国提出构建国家信息高速公路，即建设一个覆盖全美的高速宽带通信与计算机网络。许多国家和地区纷纷效仿。这一切在全球范围内极大地推动了计算机网络及其应用的发展，使计算机网络进入了一个新的发展阶段。</p><p>这一时期在计算机通信与网络技术方面以高速率、高服务质量、高可靠性等为指标，出现了高速以太网、VPN、无线网络、P2P 网络、NGN 等技术</p><h2 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a>网络拓扑结构</h2><ul><li>定义：网络中各节点的互联构形、连接布线的方式。</li><li>分类：星型、树型、总线型、环型、网状型。</li></ul><h3 id="星型"><a href="#星型" class="headerlink" title="星型"></a>星型</h3><p>星型结构的特点是存在一个中心节点，其他计算机与中心节点互连，系统的连通性与中心节点的可靠性有很大的关系。</p><div align="center" width="25%"><img width="25%" src="//tva3.sinaimg.cn/mw690/005JD0Ejgy1gbz979sfzzj30h70kkdgh.jpg"></div><h3 id="树型"><a href="#树型" class="headerlink" title="树型"></a>树型</h3><p>树型结构的特点是从根节点到叶子节点呈现层次性</p><div align="center" width="25%"><img width="25%" src="//tvax2.sinaimg.cn/mw690/005JD0Ejgy1gbz98cj7y3j30js0k3dgy.jpg"></div><h3 id="总线型"><a href="#总线型" class="headerlink" title="总线型"></a>总线型</h3><p>总线型结构的特点是存在一条主干线，所有的计算机连接到主干线上</p><div align="center" width="25%"><img width="25%" src="//tvax3.sinaimg.cn/mw690/005JD0Ejgy1gbz981xt8yj30ia0goaai.jpg"></div><h3 id="环型"><a href="#环型" class="headerlink" title="环型"></a>环型</h3><p>环型结构的网络存在一个环形的总线，节点到节点间存在两条通路</p><div align="center" width="25%"><img width="25%" src="//tva3.sinaimg.cn/mw690/005JD0Ejgy1gbz97nqrmkj30gh0kcgm8.jpg"></div><h3 id="网状型"><a href="#网状型" class="headerlink" title="网状型"></a>网状型</h3><p>网络型是一种不规则的连接，其特点是一个节点到另一个节点之间可能存在多条连接。</p><div align="center" width="25%"><img width="25%" src="//tva3.sinaimg.cn/mw690/005JD0Ejgy1gbz98cj7y3j30js0k3dgy.jpg"></div>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程的区别和联系，与作业的区别和联系</title>
      <link href="/2020/02/16/jin-cheng-yu-xian-cheng-de-qu-bie-he-lian-xi-yu-zuo-ye-de-qu-bie-he-lian-xi/"/>
      <url>/2020/02/16/jin-cheng-yu-xian-cheng-de-qu-bie-he-lian-xi-yu-zuo-ye-de-qu-bie-he-lian-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="进程的定义："><a href="#进程的定义：" class="headerlink" title="进程的定义："></a>进程的定义：</h2><p>　　进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统资源分配、调度和保护的独立单位。</p><p>　　进程是为了描述程序在并发执行时对系统资源的共享，所需的一个描述程序执行时的动态特征的概念。</p><p>　　进程三要素：<strong>程序</strong>、<strong>数据</strong>、<strong>进程控制块</strong></p><blockquote><p>进程上下文（Context）:系统中的每个程序都运行在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p><p>我们知道，操作系统中运行的各个进程是轮流地使用处理器地，进程被抢占后，到再次运行的时候，操作系统通过恢复该进程的进程上下文来使得进程像什么也没发生过一样继续执行未完成的指令。也就是说，进程上下文是内核重新启动一个被抢占的进程所需的状态。</p></blockquote><h2 id="线程的定义："><a href="#线程的定义：" class="headerlink" title="线程的定义："></a>线程的定义：</h2><p>　　线程是进程中的一个运行实体，作为CPU的调度单位，也称为轻量级进程。</p><p>扩展：作业是用户在一次计算过程中，或者一次事务处理中，要求计算机系统所做工作的总称。可由多个进程组成。</p><h2 id="进程与线程的区别与联系："><a href="#进程与线程的区别与联系：" class="headerlink" title="进程与线程的区别与联系："></a>进程与线程的区别与联系：</h2><ol><li><p>进程是资源分配的基本单位。进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。而线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。</p></li><li><p>当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。</p></li><li><p>线程只由相关堆栈寄存器和线程控制块组成。寄存器可被用来存储线程内的局部变量，但不能存储其他线程的相关变量。</p></li><li><p>进程切换时涉及到有关资源指针的保存以及地址空间的变化等问题；线程切换，由于同一进程内的线程共享资源和地址空间，将不涉及资源信息的保存和地址变化问题。而且，进程的调度与切换都是由操作系统内核完成，而线程则既可以由操作系统完成，也可以由用户程序进行。</p></li><li><p>进程间的关系比较疏远。各个进程是在自己独有的地址空间内执行，不但寄存器和堆栈是独有的，动态数据堆、静态数据区和程序代码也相互独立。而线程间的关系则要紧密得多，虽然各线程为保持自己的控制流而独有寄存器和堆栈，但由于两线程从属于同一进程，它们共享同一地址空间，所以动态数据堆、静态数据区和程序代码为各线程共享。</p></li></ol><h2 id="作业与进程的区别和关系"><a href="#作业与进程的区别和关系" class="headerlink" title="作业与进程的区别和关系"></a>作业与进程的区别和关系</h2><ol><li><p>作业是用户向计算机提交任务的实体。而进程是完成用户任务的执行实体，是向系统申请分配资源的基本单位。在用户向计算机提交作业之后，系统将它放入外存中的作业等待队列中等待执行；而任一进程，只要它被创建，总有相应的部分存在于内存中。</p></li><li><p>一个作业可由多个进程组成。且必须至少由一个进程组成，但反过来不成立。</p></li><li><p>作业的概念主要用在批处理系统中，而在Linux分时系统中不存在。进程的概念则存在于几乎所有的多道程序系统中。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的存储引擎</title>
      <link href="/2020/02/16/mysql-de-cun-chu-yin-qing/"/>
      <url>/2020/02/16/mysql-de-cun-chu-yin-qing/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL默认存储引擎"><a href="#MySQL默认存储引擎" class="headerlink" title="MySQL默认存储引擎"></a>MySQL默认存储引擎</h2><p>查看MySQL当前的版本</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> version();</span><br></pre></td></tr></tbody></table></figure><p><img src="//tvax3.sinaimg.cn/mw690/005JD0Ejgy1gbygazvpmqj30hq088wht.jpg" alt="MySQL版本"></p><p>查看MySQL默认存储引擎</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">'%engine%'</span>;</span><br></pre></td></tr></tbody></table></figure><p><img src="//tvax4.sinaimg.cn/mw690/005JD0Ejgy1gbyh9m9s7oj30rf0bcjz0.jpg" alt="默认存储引擎"></p><p>可以看到默认的存储引擎是InnoDB，5.5版本之后都是InnoDB，而在5.5之前是MyISAM。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p><p>数据库引擎是用于存储、处理和保护数据的核心服务。利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。使用数据库引擎创建用于联机事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。</p><h2 id="MySQL支持多种存储引擎"><a href="#MySQL支持多种存储引擎" class="headerlink" title="MySQL支持多种存储引擎"></a>MySQL支持多种存储引擎</h2><p>MySQL默认支持多种存储引擎，用户可以根据应用的需要选择使用不同的存储引擎，以提高效率。这种插件式存储引擎是MySQL数据库最重要的特性之一。</p><h2 id="各种存储引擎的特性"><a href="#各种存储引擎的特性" class="headerlink" title="各种存储引擎的特性"></a>各种存储引擎的特性</h2><p>先上图：<br><img src="//tva2.sinaimg.cn/mw690/005JD0Ejgy1gbyhq0n0cpj31ei0rmkgf.jpg" alt="常用存储引擎对比"></p><p>MySQL存储引擎主要有： MyIsam、InnoDB、Memory、Blackhole、CSV、Performance_Schema、Archive、Federated、Mrg_Myisam。<br>最常用的有4种：InnoDB、MyISAM、MEMERY和MERGE。</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><ul><li>InnoDB支持事务安全，具有提交、回滚、和崩溃恢复能力。</li><li>Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别。</li><li>该引擎还提供了行级锁和外键约束。</li></ul><p>它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当<code>SELECT COUNT(*) FROM TABLE</code>时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。</p><h3 id="InnoDB适用场景"><a href="#InnoDB适用场景" class="headerlink" title="InnoDB适用场景"></a>InnoDB适用场景</h3><ul><li>经常更新的表，适合处理多重并发的更新请求。</li><li>支持事务。</li><li>可以从灾难中恢复（通过bin-log日志等）。</li><li>外键约束。只有它支持外键。</li><li>支持自动增加列属性auto_increment。</li></ul><p>用于事务处理应用程序，支持外键。如果应用对事务完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、删除操作，那么InnoDB是比较合适的选择。</p><p>InnoDB除了有效地降低由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback），对于类似计费系统或财务系统等数据准确性要求比较高的系统，InnoDB都是合适的选择。</p><h3 id="InnoDB特性1-自动增长列"><a href="#InnoDB特性1-自动增长列" class="headerlink" title="InnoDB特性1 :自动增长列"></a>InnoDB特性1 :自动增长列</h3><p>自动增长列和外键约束是InnoDB不同于其他存储引擎的表的特点。</p><p>自动增长列的定义是在创建表的时候某一列加入关键字<code>auto_increment</code></p><ul><li>InnoDB表的自动增长列可以手动插入，但是插入的值如果是空或者0，则实际插入的值是自动增长后的值。</li><li>使用<code>LAST_INSERT_ID()</code>可查询当前线程最后插入记录使用的值</li><li>对于InnoDB表，自动增长列必须是索引。如果是组合索引，也必须是组合索引的第一项。但是对于MyISAM表，自动增长列可以是组合索引的其他列。</li></ul><h3 id="InnoDB特性2-外键约束"><a href="#InnoDB特性2-外键约束" class="headerlink" title="InnoDB特性2 :外键约束"></a>InnoDB特性2 :外键约束</h3><p>在MySQL中支持外键的只有InnoDB。在创建外键时，要求父表必须有对应的索引，子表在创建外键时也会自动生成对应的索引。在创建索引时，可以指定父表在更新或删除时，对子表进行相应的操作。</p><h3 id="InnoDB索引结构"><a href="#InnoDB索引结构" class="headerlink" title="InnoDB索引结构"></a>InnoDB索引结构</h3><p>InnoDB也是B+ Tree索引结构。Innodb的索引文件本身就是数据文件，即B+ Tree的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p>InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>MyISAM不支持事务，也不支持行级锁和外键，其优势是访问的速度快。但当<code>INSERT</code>或<code>UPDATE</code>数据时即写操作需要锁定整个表，效率便会低一些。MyIsam 存储引擎独立于操作系统，也就是可以在windows上使用，也可以比较简单的将数据转移到linux操作系统上去。</p><p>缺点：就是不能在表损坏后主动恢复数据.</p><h3 id="MyISAM适用场景"><a href="#MyISAM适用场景" class="headerlink" title="MyISAM适用场景"></a>MyISAM适用场景</h3><ul><li>不支持事务的设计，但是并不代表着有事务操作的项目不能用MyIsam存储引擎，可以在service层进行根据自己的业务需求进行相应的控制。</li><li>不支持外键的表设计。</li><li>查询速度很快，如果数据库<code>insert</code>和<code>update</code>的操作比较多的话比较适用。</li><li>整天对表进行加锁的场景。</li><li>MyISAM极度强调快速读取操作。</li><li>MyIASM中存储了表的行数，于是<code>SELECT COUNT(*) FROM TABLE</code>时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。</li></ul><h3 id="MyISAM索引结构"><a href="#MyISAM索引结构" class="headerlink" title="MyISAM索引结构"></a>MyISAM索引结构</h3><p>MyISAM索引用的B+ tree来储存数据，MyISAM索引的指针指向的是键值的地址，地址存储的是数据。B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串</title>
      <link href="/2020/02/14/zui-chang-hui-wen-zi-chuan/"/>
      <url>/2020/02/14/zui-chang-hui-wen-zi-chuan/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（Leetcode-5-）"><a href="#题目（Leetcode-5-）" class="headerlink" title="题目（Leetcode 5.）"></a>题目（<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">Leetcode 5.</a>）</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p><strong>示例 1：</strong>  </p><blockquote><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p></blockquote><p><strong>示例 2：</strong> </p><blockquote><p>输入: “cbbd”<br>输出: “bb”</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题意很简洁，就是找一个字符串的最长回文子串。</p><p>  可以知道的是，我们无法事先估计这个子串的长度，以及在原字符串的起始位置。如果要使用枚举法的话，就要枚举所有可能长度的子串，然后检查是不是回文串：首先枚举起始位置<code>i（0..n-1）</code>，然后枚举长度<code>j（1..n-i）</code>，接着遍历子串<code>i..i+j</code>检查是否符合回文串规则。</p><p>  显然，这样的时间复杂度是 $O(n^3)$ ，提交肯定会超时。</p><p>  有没有更好的解法呢？答案是有的。多想几个例子就会发现，这个问题存在<strong>重叠子问题性质</strong>：比如，对于<code>s="fghdscmnanmc"</code>，这个字符串存在多个长度大于1回文子串：<code>"nan"</code>、<code>"mnamn"</code>、<code>"cmnanmc"</code>。可以看到，<code>"mnamn"</code>是由<code>"m"+"nan"+"m"</code>构造而来，<code>"cmnanmc"</code>也是同理。</p><p>  但是，我们在暴力枚举的时候把所有子串都枚举了一遍，并没有使用上面的性质。也就是说，在检查发现<code>"nan"</code>是回文子串后，继续枚举到<code>"mnamn"</code>，依然把<code>"mnamn"</code>整个子串重新遍历一遍来检查是否满足回文串，而不是只检查<code>"nan"</code>左右两旁的字符是否相同。因此时间复杂度可以优化。</p><p>  还有一种可能的例子是：<code>s="fcmnaanmc"</code>。与上一个例子有所不同，就是最长回文子串的中间是一个偶数的回文子串<code>"aa"</code>，而上一个例子是<code>"a"</code>。那么，可知，当问题规模不断减小，直至最小时，应有两种情况：</p><pre><code>1. 子串长度为1：显然只有一个字符的回文串肯定是回文串。2. 子串长度为2：如果这两个字符相同，那么就是一个回文串。</code></pre><p>  现在我们得到最小规模问题的解了，接下来我们试着将问题规模变大，再来求解问题：显然，在已知一个回文串<code>s</code>后，我们需要检查回文串<code>s</code>左右两边的字符是否相等，如果相等，那么新的子串<code>g='A'+s+'A'</code>，其中<code>'A'</code>表示一个字符：</p><p>  这个性质不难想到，但是怎么转换成代码是一个问题。因为我们遍历字符串只能一个一个挨个遍历，不像人眼可以直接看到哪些是对称的。</p><p>  再回到子串本身，如何定位一个子串？一种办法是保存起始下标和末尾下标；另一种方法是保存起始下标，以及子串的长度。显然，无论怎样，都是需要至少二维的信息才能确定一个子串，因此可以用二维数组<code>dp[i][j]</code>，表示<code>i...j</code>的子串是否为回文串。</p><p>  那么递推方程是怎么样的呢？</p><p>  先看初始时:</p><p><code>dp[i][i] = true (for i in 0..n-1)</code></p><p><code>dp[i][i+1] = true (if s[i]==s[i+1]), else false (for i in 0..n-1)</code></p><p>  递推方程：</p><p>  <code>dp[i][j] = (s[i]==s[j] &amp;&amp; dp[i+1][j-1])</code> </p><p>其中<code>i</code>和<code>j</code>分别表示起始下标和末尾下标</p><p>  但是，实际写代码的时候并不是这样写代码，因为：先枚举起始下标i，再枚举末尾下标j，这样递推方程的更新过程是：三元，四元…n元，三元，四元…n元，三元……这就造成了在有一些三元的子串还不知道是否满足回文串，就去更新四元的结果，最终造成错误。</p><p>  举一个例子：<code>"abcba"</code>。</p><p>  最终我们采取定位子串的第二种方案，可以保证三元的所有结果都更新完再更新四元五元等等的结果。</p><p>  <code>dp[i][i+j] = (s[i]==s[i+j] &amp;&amp; dp[i+1][i+j-1])</code></p><p>其中<code>i</code>表示起始下标，<code>j</code>表示子串的长度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="type">bool</span> dp[<span class="number">1001</span>][<span class="number">1001</span>];  <span class="comment">//dp[i][j]表示 i...j 的字串是否为回文串</span></span><br><span class="line">        string ans=<span class="string">""</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">-1</span>;  <span class="comment">//下标初值</span></span><br><span class="line">        <span class="type">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            <span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));  <span class="comment">//运行环境的坑</span></span><br><span class="line">            dp[i][i]=<span class="literal">true</span>;        <span class="comment">//初始化一元的情况</span></span><br><span class="line">            <span class="keyword">if</span>( <span class="number">1</span> &gt; right-left+<span class="number">1</span>){   <span class="comment">//保存结果（下标）max</span></span><br><span class="line">                right=left=i;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&lt;len &amp;&amp; s[i]==s[i+<span class="number">1</span>]){</span><br><span class="line">                dp[i][i+<span class="number">1</span>]=dp[i+<span class="number">1</span>][i]=<span class="literal">true</span>;  <span class="comment">//初始化二元的情况</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][i+<span class="number">1</span>]  &amp;&amp;  <span class="number">2</span> &gt;right-left+<span class="number">1</span>){<span class="comment">//保存结果（下标）max</span></span><br><span class="line">                    left=i;</span><br><span class="line">                    right=i+<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//递推三元以上的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;len;j++){<span class="comment">//长度依次增加</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+j&lt;len;i++){ <span class="comment">//起始下标依次增加</span></span><br><span class="line">                dp[i][i+j]= (s[i]==s[i+j] &amp;&amp; dp[i+<span class="number">1</span>][i+j<span class="number">-1</span>]);<span class="comment">//递推</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][i+j] &amp;&amp; (i+j-i+<span class="number">1</span>) &gt; right-left+<span class="number">1</span>){<span class="comment">//保存结果（下标）max</span></span><br><span class="line">                    left=i;</span><br><span class="line">                    right=i+j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right==<span class="number">-1</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> s.<span class="built_in">substr</span>(left,right-left+<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性auto的用法</title>
      <link href="/2020/02/12/c-11-xin-te-xing-auto-de-yong-fa/"/>
      <url>/2020/02/12/c-11-xin-te-xing-auto-de-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="1-为什么要引入auto？"><a href="#1-为什么要引入auto？" class="headerlink" title="1. 为什么要引入auto？"></a>1. 为什么要引入auto？</h2><p>通常，在把表达式的值赋给变量时，我们需要在声明变量时准确地声明是什么类型。但是，有时候很难知道表达式到底是什么类型的，因此引入了auto类型说明符。auto会让编译器通过初始值来推算变量的类型。</p><h2 id="2-使用auto需要注意的是"><a href="#2-使用auto需要注意的是" class="headerlink" title="2. 使用auto需要注意的是"></a>2. 使用auto需要注意的是</h2><h3 id="auto定义的变量必须有初始值"><a href="#auto定义的变量必须有初始值" class="headerlink" title="auto定义的变量必须有初始值"></a><strong>auto定义的变量必须有初始值</strong></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = val1 + val2;  <span class="comment">//由val1和val2相加的结果可以推断出item的类型 </span></span><br></pre></td></tr></tbody></table></figure><h3 id="一条auto声明语句只能有一个基本数据类型"><a href="#一条auto声明语句只能有一个基本数据类型" class="headerlink" title="一条auto声明语句只能有一个基本数据类型"></a><strong>一条auto声明语句只能有一个基本数据类型</strong></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;  <span class="comment">//正确：i是整数，p是整型指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;  <span class="comment">//错误：sz和pi的类型不一致</span></span><br></pre></td></tr></tbody></table></figure><h3 id="编译器会改变推断结果使其更符合初始化规则"><a href="#编译器会改变推断结果使其更符合初始化规则" class="headerlink" title="编译器会改变推断结果使其更符合初始化规则"></a><strong>编译器会改变推断结果使其更符合初始化规则</strong></h3><p>比如，我们在使用一个引用时，其实就是使用该引用的对象。特别是引用被用作初始值时，真正参加初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r;  <span class="comment">//a是一个整数（r是i的别名，而i是一个整数）</span></span><br></pre></td></tr></tbody></table></figure><h3 id="auto一般会忽略顶层const，保留底层const"><a href="#auto一般会忽略顶层const，保留底层const" class="headerlink" title="auto一般会忽略顶层const，保留底层const"></a><strong>auto一般会忽略顶层const，保留底层const</strong></h3><blockquote><p>顶层const表示指针本身是个常量<br>底层const表示表示指针所指的对象是个常量</p></blockquote><ol><li><p>比如当初始值指向一个常量指针时：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;  <span class="comment">//b是一个整数（ci的顶层特性被忽略掉了）</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;  <span class="comment">//c是一个整数（cr是ci的别名，而ci本身是一个顶层const）</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;  <span class="comment">//d是一个整型指针（整数的地址就是指向整数的指针）</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci; <span class="comment">//e是一个指向整数常量的指针（对常量对象取地址是一种底层const）</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>如果希望推断出的auto类型是一个顶层const，需要明确指出：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci;  <span class="comment">//ci的推演类型是int，f是const int</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>引用的类型设为auto，原来的初始化规则仍然适用</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;g = ci; <span class="comment">//g是一个整型常量引用，绑定到ci</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>; <span class="comment">//错误：不能为非常量引用绑定字面值</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>;  <span class="comment">//正确：可以为常量引用绑定字面值</span></span><br></pre></td></tr></tbody></table></figure><p>设置一个auto类型的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初值绑定一个引用，则此时的常量就不是顶层常量了。</p></li><li><p>要在一条语句中定义多个变量，切记，符号&amp;和*只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> k = ci, &amp;l = i;  <span class="comment">//k是整数，l是整型引用</span></span><br><span class="line"><span class="keyword">auto</span> &amp;m = ci, *p = ci; <span class="comment">//m是整型常量的引用，p是指向整型常量的指针</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n = i, *p2 = &amp;ci; <span class="comment">//错误：i是整型int，而&amp;ci是整型常量const int</span></span><br></pre></td></tr></tbody></table></figure></li></ol><h2 id="3-完整实例代码"><a href="#3-完整实例代码" class="headerlink" title="3. 完整实例代码"></a>3. 完整实例代码</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = val1 + val2;  <span class="comment">//由val1和val2相加的结果可以推断出item的类型 </span></span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;      <span class="comment">//正确：i是整数，p是整型指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;   <span class="comment">//错误：sz和pi的类型不一致</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;    <span class="comment">//b是一个整数（ci的顶层特性被忽略掉了）</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;    <span class="comment">//c是一个整数（cr是ci的别名，而ci本身是一个顶层const）</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;    <span class="comment">//d是一个整型指针（整数的地址就是指向整数的指针）</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;   <span class="comment">//e是一个指向整数常量的指针（对常量对象取地址是一种底层const）</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci;  <span class="comment">//ci的推演类型是int，f是const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g = ci;   <span class="comment">//g是一个整型常量引用，绑定到ci</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>;   <span class="comment">//错误：不能为非常量引用绑定字面值</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>;   <span class="comment">//正确：可以为常量引用绑定字面值</span></span><br><span class="line"><span class="keyword">auto</span> k = ci, &amp;l = i;  <span class="comment">//k是整数，l是整型引用</span></span><br><span class="line"><span class="keyword">auto</span> &amp;m = ci, *p = ci;<span class="comment">//m是整型常量的引用，p是指向整型常量的指针</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n = i, *p2 = &amp;ci; <span class="comment">//错误：i是整型int，而&amp;ci是整型常量const int</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决mathjax与代码高亮的冲突</title>
      <link href="/2020/02/10/jie-jue-mathjax-yu-dai-ma-gao-liang-de-chong-tu/"/>
      <url>/2020/02/10/jie-jue-mathjax-yu-dai-ma-gao-liang-de-chong-tu/</url>
      
        <content type="html"><![CDATA[<p>如果你按照教程安装了代码高亮插件<code>hexo-prism-plugin</code>，单独使用是没有问题的，但如果你又使用了<code>mathjax</code>，并且按照网上教程，安装<code>kramed</code>插件并修改了<code>js</code>文件里的正则表达式（为了解决<code>markdown</code>和<code>mathjax</code>的语法冲突），那你的代码就无法高亮了。解决方法很简单，别用<code>kramed</code>插件了，还用原来自带的<code>marked</code>插件，直接改它的正则表达式就行了。</p><h2 id="卸载kramed插件"><a href="#卸载kramed插件" class="headerlink" title="卸载kramed插件"></a>卸载kramed插件</h2><p>如果没安装就不用这一步。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-kramed --save</span><br></pre></td></tr></tbody></table></figure><h2 id="安装marked插件"><a href="#安装marked插件" class="headerlink" title="安装marked插件"></a>安装marked插件</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-marked --save</span><br></pre></td></tr></tbody></table></figure><h2 id="加数学公式显示"><a href="#加数学公式显示" class="headerlink" title="加数学公式显示"></a>加数学公式显示</h2><p>打开<code>/themes/matery/layout</code>中的<code>post.ejs</code>文件，在最下方粘贴如下代码：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="由于markdown语法与mathjax语法存在冲突，所以还需要修改源文件。"><a href="#由于markdown语法与mathjax语法存在冲突，所以还需要修改源文件。" class="headerlink" title="由于markdown语法与mathjax语法存在冲突，所以还需要修改源文件。"></a>由于<code>markdown</code>语法与<code>mathjax</code>语法存在冲突，所以还需要修改源文件。</h2><p>修改node_modules/marked/lib/marked.js文件中的escape和em两行（在第536行、548行左右），改成下面：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></tbody></table></figure><h2 id="注意！"><a href="#注意！" class="headerlink" title="注意！!"></a>注意！!</h2><p>这时在文章里写数学公式基本没有问题了，但是要注意：</p><p><strong>数学公式中如果出现了连续两个{，中间一定要加空格！</strong></p><p>举个例子:</p><p>行内公式：$y = f(x)$</p><p>代码：</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">$</span>y = f(x)<span class="built_in">$</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>行间公式：</p><p>\[y = {f_{ {g_1}}}(x)\]</p><p>代码：</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">\\</span>[y = {f<span class="built_in">_</span>{ {g<span class="built_in">_</span>1}}}(x)<span class="keyword">\\</span>]</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意上面花括号之间有空格！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安装/配置经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼编码-问题集合</title>
      <link href="/2020/02/10/ha-fu-man-bian-ma-wen-ti-ji-he/"/>
      <url>/2020/02/10/ha-fu-man-bian-ma-wen-ti-ji-he/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是哈夫曼编码？"><a href="#1-什么是哈夫曼编码？" class="headerlink" title="1. 什么是哈夫曼编码？"></a>1. 什么是哈夫曼编码？</h2><p>哈夫曼编码是哈夫曼树的一种应用，广泛用于数据压缩（通常可以节省20%~90%的空间）。</p><p>哈夫曼编码是变长编码 ，也是前缀码。</p><pre><code>变长编码:  每种字符长度不一定相同。前缀码:  没有任何码字是其他码字的前缀</code></pre><p>哈夫曼编码算法使用字符在文件中出现的频率来建立0和1表示字符的最优二进制表示。其思想是<strong>赋予高频字符短码字，赋予低频字符长码字</strong>。</p><h3 id="编码举例"><a href="#编码举例" class="headerlink" title="编码举例"></a>编码举例</h3><p>如果需传送的电文为 ‘ABACCDA’，它只用到四种字符，用两位二进制编码便可分辨。假设 A, B, C, D 的编码分别为 00, 01,10, 11，则上述电文便为 ‘00010010101100’（共 14 位），译码员按两位进行分组译码，便可恢复原来的电文。</p><p>使用哈夫曼编码：首先需要知道每种字符出现的频率，其中 $P(A)=\frac{3}{7}$,$P(B)=\frac{1}{7}$，$P(C)=\frac{2}{7}$，$P(D)=\frac{1}{7}$。</p><p>过程：首先，B和D的频率最小，所以合并成一棵树。此时$P(B+D)=\frac{1}{7}+\frac{1}{7}=\frac{2}{7}$，与$P(C)$相等，却比$P(A)$小，所以与C合并，最后合并A。</p><p><img src="//tva4.sinaimg.cn/mw690/005JD0Ejgy1gbrcrxfi83j306705fq34.jpg" alt="构造出的哈夫曼树"></p><p>从根结点出发可得编码： A：0， C：10，  B：110， D：111 。电文 ‘ABACCDA’ 便为 ‘0110010101110’（共 13 位）。</p><h2 id="2-哈夫曼贪心算法如何实现？"><a href="#2-哈夫曼贪心算法如何实现？" class="headerlink" title="2. 哈夫曼贪心算法如何实现？"></a>2. 哈夫曼贪心算法如何实现？</h2><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="* 伪代码"></a>* 伪代码</h3><p>我们假定C是一个n个字符的集合，而其中每个字符 $c \in C$ 都是一个对象，其属性 c.freq 给出了字符出现的频率。算法自底向上地构造出对应最优编码地二叉树T。它从|C|个结点开始，执行|C|-1个“合并”操作创建出最终的二叉树。算法使用一个以属性freq为关键字最小优先队列Q，以识别两个最低频率的对象将其合并。当合并两个对象时，得到的新对象的频率设置为原来两个对象的频率之和。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HUFFMAN(C)</span><br><span class="line">    n=|C|</span><br><span class="line">    Q=C                 //最小优先队列Q</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span> to n-<span class="number">1</span></span><br><span class="line">        allocate a new node z</span><br><span class="line">        z.left=x=EXTRACT_MIN(Q)</span><br><span class="line">        z.right=y=EXTRACT_MIN(Q)</span><br><span class="line">        z.freq=x.freq+y.freq</span><br><span class="line">        INSERT(Q,z)</span><br><span class="line">    <span class="keyword">return</span> EXTRACT-MIN(Q)</span><br></pre></td></tr></tbody></table></figure><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="* C++代码"></a>* C++代码</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node *left;</span><br><span class="line">    Node *right;</span><br><span class="line">    <span class="type">int</span> freq;</span><br><span class="line">    <span class="built_in">Node</span>():<span class="built_in">freq</span>(<span class="number">0</span>),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>){}</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> v):<span class="built_in">freq</span>(v),<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>){}</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类指针比较  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompareNode</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Node* left,<span class="type">const</span> Node* right)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span>==left)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">return</span> (left-&gt;freq &gt; right-&gt;freq);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> std::priority_queue&lt;Node*,vector&lt;Node*&gt;,CompareNode&gt; <span class="type">queue_t</span>;</span><br><span class="line"></span><br><span class="line">Node* z;</span><br><span class="line"><span class="function">Node* <span class="title">Huffman</span><span class="params">(vector&lt;Node*&gt;&amp; C)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n=C.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">queue_t</span> Q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:C){</span><br><span class="line">        Q.<span class="built_in">push</span>(it);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++){</span><br><span class="line">        z=<span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        z-&gt;left=Q.<span class="built_in">top</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        z-&gt;right=Q.<span class="built_in">top</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        z-&gt;freq=(z-&gt;left-&gt;freq)+(z-&gt;right-&gt;freq);</span><br><span class="line">        Q.<span class="built_in">push</span>(z);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Q.<span class="built_in">top</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_print</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>){</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;root-&gt;freq&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">pre_print</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">pre_print</span>(root-&gt;right);  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;Node*&gt; vec;</span><br><span class="line">    <span class="function">Node <span class="title">a</span><span class="params">(<span class="number">3</span>)</span>,<span class="title">b</span><span class="params">(<span class="number">1</span>)</span>,<span class="title">c</span><span class="params">(<span class="number">1</span>)</span>,<span class="title">d</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(&amp;a);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(&amp;b);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(&amp;c);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(&amp;d);</span><br><span class="line">    Node *root=<span class="built_in">Huffman</span>(vec);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pre_print</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试输出结点（先序遍历）：</p><pre><code>7 3 4 2 2 1 1 </code></pre><p>ok，符合预期。</p><h3 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><ol><li><p>如何重载类指针比较符？（已解决，如上代码）</p></li><li><p>尝试尽可能与伪代码接近时，发现以下代码在编译时出错（已解决）：</p> <figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node* x,y;</span><br><span class="line">x=Q.<span class="built_in">top</span>();</span><br><span class="line">y=Q.<span class="built_in">top</span>();      <span class="comment">//此行报错</span></span><br></pre></td></tr></tbody></table></figure><p> 在显示的出错信息为：</p><pre><code>  error: invalid user-defined conversion from 'const value_type' {aka 'Node* const'} to 'const Node&amp;' </code></pre><blockquote><p>解决：wsl，指针的定义都忘记了：<code>Node *x,*y;</code></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Hexo+GitPage博客记录</title>
      <link href="/2020/02/08/da-jian-hexo-gitpage-bo-ke-ji-lu/"/>
      <url>/2020/02/08/da-jian-hexo-gitpage-bo-ke-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>在写这篇博客时我已经把Hexo博客的主题配置好了，我花了一个白天终于把博客配置成自己喜欢的样子。让我感受最深的是这个配置要改文件有点麻烦，要是有可视化的界面来配置就好了，毕竟自己是一个前端小白hhh</p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>直接百度了一个教程，介绍得十分详细：<a href="https://segmentfault.com/a/1190000017986794">链接</a>。  </p><p>  不过教程有两个步骤的顺序颠倒了，就是先要登录 Github 上添加刚刚生成的SSH key，再确认并添加主机到本机SSH可信列表：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></tbody></table></figure><p>第一次弄这个，所以在这里卡住了，其他的没什么，一步一步走就ok了。</p><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>大部分时间都花在这里，毕竟直接照搬主题太没个性了，还是要改一改的。  </p><p>我用的是matery的主题（<a href="https://github.com/blinkfox/hexo-theme-matery/">链接</a>），布局看起来也很简洁，也是照着教程走，只是我当时看得急把一些步骤看错了。</p><p>主要修改Hexo根目录配置文件和主题目录下的配置文件，这两个名字都为<code>_config.yml</code>，所以别搞混了。</p><h3 id="改网站logo"><a href="#改网站logo" class="headerlink" title="改网站logo"></a>改网站logo</h3><p>其实只要替换主题文件夹里的图片就好了。</p><p>不过我一开始想用网页链接，所以我改了<strong>主题配置文件</strong>，后来改回来的时候/medias漏了’/‘号。</p><p>在找错的时候get到了一个新技能，就是看别人的博客网页时，用浏览器的检查功能可以看到布局信息了 <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 然后照着改就能实现那个网页的效果了。</p><p>另外，想做个圆形的logo及头像，发现win10自带的照片编辑居然没有将照片裁剪成圆形的功能，不过可以用word来做：插入一个圆形的形状，然后填充设置为你想要的图片，再另存为图片就ok了。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>显而易见，个性化强，怎么顺眼怎么改，就是对前端小白不太友好哈哈哈 <span class="github-emoji"><span>😁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>github.io访问有点慢呐！资金够的话还是部署到自己的服务器比较好 <span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="MarkDown表情包"><a href="#MarkDown表情包" class="headerlink" title="MarkDown表情包"></a>MarkDown表情包</h2><p>最后附上markdown表情包哈哈哈，以后可以用。<br><img src="https://img2018.cnblogs.com/blog/1137258/201906/1137258-20190618213943766-1389148263.png" alt="表情包"></p>]]></content>
      
      
      <categories>
          
          <category> 安装/配置经验 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
